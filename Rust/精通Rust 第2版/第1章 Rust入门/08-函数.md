### 1.3.3　函数

函数将一堆指令抽象为具名实体，稍后可以通过其他代码调用这些指令，并帮助用户管理复杂性。我们已经在greet.rs程序中使用了一个函数，即main函数。让我们看看如何定义另一个函数：

```rust
// functions.rs
fn add(a: u64, b: u64) -> u64 {
    a + b
}
fn main() {
    let a: u64 = 17;
    let b = 3;
    let result = add(a, b);
    println!("Result {}", result);
}
```

在上述代码中，我们创建了一个名为add的新函数。关键字fn用于创建函数，随后跟着的是函数名add，圆括号中的a和b是参数，花括号中的是函数体。冒号的右边是参数的类型。函数的返回类型使用->指定，其后跟着的是类型，即u64。如果函数无返回值，那么可以省略该类型声明。函数也有类型，我们的函数add的类型表示为fn (u64,u64) -> u64。类型声明也可以存储在变量中传递给其他函数。

如果你仔细查看add的函数体，会发现我们不需要像其他语言那样使用关键字return来返回a+b，因为最后一个表达式会自动返回。不过Rust中仍有关键字return，但它用于提前退出。函数基本上是返回值的表达式，默认情况下是()（Unit）类型的值，这与C/C++中的void返回类型相似。也可以在其他函数中声明返回值，这用于你很难将某个函数（例如foo）中的某个功能作为语句序列进行推断时。在这种情况下，你可以在本地函数bar中提取这些行，然后在父函数foo中定义它们。

在main函数中，我们用let语句声明两个变量a和b。与b的情况类似，我们甚至可以省略指定类型，因为Rust可以通过检查代码来推断大多数情况下变量的类型。这种情况也适用于result，它是一个类型为u64的值。该特性有助于防止类型签名混乱，并提高代码可读性，特别是当你的类型嵌套在多个具有长名称的其他类型中时。





![18.png](../images/18.png)
**注意**

Rust的类型推断基于Hindly-Milner类型系统。该系统包含一组规则和算法，可以通过编程语言进行类型推断。其采用了一种有效的类型推断方法，在线性时间内执行，使它对大型程序的类型检查具有实际意义。



我们还可以使用能够修改其参数的函数。考虑以下代码：

```rust
// function_mut.rs
fn increase_by(mut val: u32, how_much: u32) {
    val += how_much;
    println!("You made {} points", val);
}
fn main() {
    let score = 2048;
    increase_by(score, 30);
}
```

我们声明了一个变量score，并且为其赋值为2048，然后调用函数increase_by，将score作为第1个参数，30作为第2个参数传递给它。在increase_by中，我们将第1个参数指定为mut val，这表示该参数应该被视为可变的，这允许变量在函数内部被修改。我们的函数increase_by修改了val绑定变量并输出了该值。以下是程序运行后的输出结果：

```rust
$ rustc function_mut.rs
$ ./function_mut
You made 2078 points
```

接下来让我们探索一下闭包。

