### 1.3.7　match表达式

Rust的match（匹配）表达式非常简单、易用。它基本上类似于C语言的switch语句简化版，允许用户根据变量的值，以及是否具有高级过滤功能做出判断。以下是一个使用match表达式的程序：

```rust
// match_expression.rs
fn req_status() -> u32 {
    200
}
fn main() {
    let status = req_status();
    match status {
        200 => println!("Success"),
        404 => println!("Not Found"),
        other => {
            println!("Request failed with code: {}", other);
            //从缓存中获取响应
        }
    }
}
```

在上述代码中有一个req_status函数，它返回一个伪超文本传输协议（HyperText Transfer Protocol，HTTP）请求状态代码200，然后在main函数中调用，并将它分配给变量status。之后使用关键字match匹配此值，关键字后面跟着的是要检查的变量（status），后面跟一对花括号。在花括号内，我们编写表达式——它们被称为匹配臂。这些匹配臂表示匹配的变量可以采用的候选值。每个匹配臂是通过可能写入变量的值来构造的，随后跟着的是一个“=>”，然后右边是表达式。在右侧，你可以在花括号中使用单行表达式或多行表达式。当编写的是单行表达式时，需要用逗号进行分隔。此外，每个匹配臂必须返回相同的类型。在这种情况下，每个匹配臂返回一个Unit类型()。

另一个很好的特性，或者可以称之为match表达式的保证，是我们必须对所有可能匹配的值进行彻底匹配。在本示例中，这将列出所有数字直到i32类型允许的最大值。实际上这是不可能的。如果我们想忽略相关的值，Rust允许我们通过使用catch all变量（这里是other）或者_（下画线）来忽略其余的可能性。当你有多个可能的值，并且需要简洁地进行构造时，match表达式是围绕这些值做出决策的主要方式。与if else 表达式一样，match表达式的返回值也可以在用分号分隔的let语句中为变量赋值，其中所有匹配臂的返回值类型相同。

