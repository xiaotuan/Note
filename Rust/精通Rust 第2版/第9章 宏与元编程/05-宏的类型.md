### 宏的类型

Rust中有不同形式的宏，有些允许你像函数那样调用它，有些则允许你有条件地引用代码，具体情况取决于编译期条件。另一类宏允许你在编译时实现方法的特征。它们大致可以分为两种形式。

+ **声明式宏**：这些是宏的最简单形式。它们是使用macro_rules!宏创建的，其本身就是一个宏。它们提供与调用函数类似的功能，但是很容易通过名称末尾的!予以区分。它们是在项目中快速编写小型宏的首选方法。定义它们的语法与编写match表达式的方式非常相似。它们被称为声明式宏，这意味着你已经拥有了一个迷你型的DSL，然后可以识别标记类型和重复构造，使用它们可以声明式地表达你想要生成的代码。你不需要考虑如何生成代码，因为DSL会替你代劳。
+ **过程宏**：过程宏是宏的一种更高级形式，可以完全控制代码的操作和生成。这些宏没有任何DSL支持，并在某种意义上是程序性的，你必须为给定的标记树输入编写如何生成或转换代码的指令。其缺点是实现起来很复杂，需要对编译器的内部机制，以及程序如何在编译器的内存中表示有一些了解。macro_rules!宏可以在项目的任何位置定义，而过程宏需要通过将Cargo.toml文件中的属性设置为proc−macro = true来生成独立的软件包。

