### 2.3.2　Cargo与依赖项

对于依赖其他程序库的项目，软件包管理器必须找到项目中所有直接依赖项和任何间接依赖项，然后编译，并将它们链接到项目。软件包管理器不仅是帮助用户解决依赖性的工具，还应该确保项目可预测和可重复地构建。在我们介绍构建和运行项目之前，先看看Cargo如何管理依赖项，并确保项目可重复地构建。

Cargo是通过两个文件来管理Rust项目的：Cargo.toml文件（之前介绍过）由开发人员使用semver（如v1.3.*）编写依赖管理及其所需版本，以及一个名为Cargo.lock的锁文件，它由Cargo在构建项目时生成，包含所有直接依赖项和任何间接依赖项的绝对版本（如1.3.15）。此锁文件确保在二进制项目中能够重复构建。Cargo通过引用此锁文件来最小化它必须完成的工作，以便对项目进行任何进一步的更改。因此，建议使二进制项目在其版本库中包含.lock文件，而程序库项目是无状态的，不需要包含它。

可以使用cargo update命令更新依赖关系，这会更新项目的所有依赖项。为了更新单个依赖，我们可以使用命令cargo update -p <crate-name>。如果希望更新单个软件包的某个版本，Cargo会确保更新Cargo.lock文件中与该软件包相关的部分，并保持其他软件包的版本不变。

Cargo遵循语义版本控制系统，其中你的程序库将以“major.minor.patch”格式指定。它们的含义如下。

+ Major：只有在对项目进行新的重大更改时（包括错误修复）才会添加。
+ Minor：仅在以向后兼容的方式添加新功能时才会添加。
+ Patch：仅在以向后兼容的方式修复错误，并且未添加任何功能时才会添加。

例如你可能希望在项目中引用序列化库 serde。在编写本书时，serde 的最新版本是1.0.85，你可能只关心主版本号，因此在Cargo.toml中指定serde="1"作为依赖关系（这将转换为semver格式的1.xx），Cargo将为你解决并在锁文件中将其修复为1.0.85。下次使用cargo update命令更新Cargo.lock时，此版本可能会升级到1.xx匹配的最新版本。如果你对此并不在意，并且只想要最新版本的crate，那么可以使用“”指代版本，但这并不是推荐的做法，因为它会影响构建的可重复性，例如你可能会引入一个与主版本有冲突的变更。发布项目时使用“”声明依赖项版本号的做法也是被禁止的。

为此，我们将了解cargo的构建命令，它主要用于编译、链接及构建我们的项目。此命令为你的项目执行以下操作。

+ 如果你还没有Cargo.lock文件，将为你运行cargo update命令进行更新，并根据Cargo.toml将确切的版本放入锁文件。
+ 下载已在Cargo.lock中解析的依赖项。
+ 构建这些依赖项。
+ 构建项目并将其与依赖项链接。

默认情况下，Cargo会在target/debug/目录下创建项目的调试版本，可以传递--release标记参数，在target/release/目录下为正式上线代码创建优化后的构建。调试版本提供了更短的构建时间，缩短了反馈循环，而正式版本的稍慢，因为编译器对源代码运行了更多的优化步骤。在开发过程中，你需要缩短修复-编译-检查的反馈时间。为此，可以使用 cargo check命令缩短编译时间。它基本上跳过了编译器的代码生成部分，只通过前端阶段运行代码，即编译器的解析和语义分析。另一个命令是cargo run，它会执行双重任务。执行Cargo构建，然后运行target/debug/目录下的程序。为了构建/运行正式发布的版本，你可以使用cargo run --release命令。在我们的imgtool/目录下运行cargo run命令后，可得到以下输出结果：

![29.png](../images/29.png)
