### 7.12.1　内存对齐

这是内存管理方面的知识之一，除非在性能方面有严格的要求，否则你很少会需要关注它们。由于存储器和处理器之间的数据访问存在延迟，当处理器访问存储器中的数据时，它是逐块而不是逐字节进行的，这有助于减少访问内存的次数。块的大小被称为CPU的内存访问粒度。通常，块的大小是1个字（32位），2个字，3个字，4个字，依此类推，它们的大小取决于目标体系结构。根据访问粒度，目标数据驻留在与字大小（word size）的倍数对齐的存储器中。如果不是这种情况，那么CPU必须先读取数据，然后对数据位执行左移或右移操作，并丢弃不需要的数据以读取特定值。这浪费了CPU周期。在大多数情况下，编译器足够“聪明”，可以为我们找出数据对齐方式，但在某些情况下，我们需要下达指令。有两个重要的术语需要我们了解。

+ 字大小：字大小表示微处理器处理单元数据的位数。
+ 内存访问粒度：CPU从内存总线访问的最小数据块被称为内存访问粒度。

所有编程语言中的数据类型都包含大小和对齐方式。基元类型的对齐尺寸和它们的大小相等。因此，一般所有基元类型都是对齐的，并且CPU对它们的对齐读取是没有问题的。但是当我们创建自定义数据类型时，如果它们没有对齐以允许CPU用对齐的方式访问内存，那么编译器通常会在我们的结构体字段之间插入填充物。

了解过数据类型大小和对齐方式之后，让我们研究一下标准库中的std::mem模块，它允许我们对数据类型及其大小进行自检。

