### A.5　二进制和十六进制

十六进制表示法常用于提供更为方便的二进制数据（如内存地址或存储位标记设置的整数）视图。这样做的原因是，每个十六进制位对应于4位。表A.2说明了这种对应关系。

<center class="my_markdown"><b class="my_markdown">表A.2　十六进制数和对应的二进制数</b></center>

| 十六进制位 | 对应的二进制数 |
| :-----  | :-----  | :-----  | :-----  |
| 0 | 0000 |
| 1 | 0001 |
| 2 | 0010 |
| 3 | 0011 |
| 4 | 0100 |
| 5 | 0101 |
| 6 | 0110 |
| 7 | 0111 |
| 8 | 1000 |
| 9 | 1001 |
| A | 1010 |
| B | 1011 |
| C | 1100 |
| D | 1101 |
| E | 1110 |
| F | 1111 |

要将十六进制值转换为二进制，只需将每个十六进制位替换为相应的二进制数即可。例如，十六进制0xA4对应于二进制数10100100。同样，可以轻松地将二进制值转换为十六进制，方法是将每4位转换为对应的十六进制位。例如，二进制值10010101将被转换为0x95。



**Big Endian和Little Endian**

奇怪的是，都使用整数的二进制表示的两个计算平台对同一个值的表示可能并不相同。例如，Intel计算机使用Little Endian体系结构来存储字节，而Motorola处理器、IBM大型机、SPARC处理器和ARM处理器使用Big Endian方案（但最后的两种系统可配置成使用上述任何一种方案）。

术语Big Endian和Little Endian是从“Big End In”和“Little End In”（指内存中单词（通常为两个字节）的字节顺序）衍生而来的。在Intel计算机（Little Endian）中，先存储低位字节，这意味着十六进制值0xABCD在内存中将被存储为0xCD 0xAB。Motorola（Big Endian）计算机按相反的顺序存储，因此0xABCD在内存中被存储为0xAB 0xCD。

这些术语最先出现在Jonathan Swift编写的《Gulliver’s Travels》一书中。为讽刺众多政治斗争的非理性，Swift杜撰了假想国中两个喜欢争论的政治派别：Big Endians和Little Endians，前者坚持认为从大的一头打破鸡蛋更合理，而后者坚持认为从小的一头打破鸡蛋更合理。

作为软件工程师，应了解目标平台的词序，它会影响对通过网络传输的数据的解释方式以及数据在二进制文件中的存储方式。在上面的例子中，二字节内存模式0xABCD在Little Endian计算机上表示十进制值52651，而在Big Endian计算机上表示十进制值43981。

