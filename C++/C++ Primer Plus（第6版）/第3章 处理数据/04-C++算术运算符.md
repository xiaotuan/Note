[toc]

下面是 5 种基本的 C++ 算术运算符：

+ \+ 运算符对操作数执行加法运算。
+ \- 运算符从第一个数中减去第二个数。
+ \* 运算符将操作数相乘。
+ / 运算符用第一个数除以第二个数。
+ % 运算符求模。也就是说，它生成第一个数除以第二个数后的余数。两个操作数必须都是整数，将该运算符用于浮点数将导致编译错误。如果其中一个是负数，则结果的符号满足如下规则：(a/b)*b + a%b == a。

程序清单**3.10 arith.cpp**

```cpp
// arith.cpp -- some C++ arithmetic
#include <iostream>

int main()
{
	using namespace std;
	float hats, heads;

	cout.setf(ios_base::fixed, ios_base::floatfield);	// fixed-point
	cout << "Enter a number: ";
	cin >> hats;
	cout << "Enter another number: ";
	cin >> heads;

	cout << "hats = " << hats << "; heads = " << heads << endl;
	cout << "hats + heads = " << hats + heads << endl;
	cout << "hats - heads = " << hats - heads << endl;
	cout << "hats * heads = " << hats * heads << endl;
	cout << "hats / heads = " << hats / heads << endl;
	return 0;
}
```

下面是该程序的输出：

```console
Enter a number: 50.25
Enter another number: 11.17
hats = 50.250000; heads = 11.170000
hats + heads = 61.419998
hats - heads = 39.080002
hats * heads = 561.292480
hats / heads = 4.498657
```

### 1. 运算符优先级和结合性

算术运算符遵循通常的代数优先级，先乘除，后加减。当然，可以使用括号来执行自己定义的优先级。当两个运算符的优先级相同时，C++ 将看操作数的结合性是从左到右，还是从右到左。从左到右的结合性意味着如果两个优先级相同的运算符被同时用于同一个操作数，则首先应用左侧的运算符。从右到左的结合性则首先应用右侧的运算符。

### 2. 除法分支

除法运算符（/）的行为取决于操作数的类型。如果两个操作数都是整数，则 C++ 将执行整数除法。这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数。如果其中有一个（或两个）操作数是浮点值，则小数部分将保留，结果为浮点数。

程序清单**3.11 divide.cpp**

```cpp
// divide.cpp -- integer and floating-point division
#include <iostream>

int main()
{
	using namespace std;
	cout.setf(ios_base::fixed, ios_base::floatfield);
	cout << "Integer division: 9/5 = " << 9 / 5 << endl;
	cout << "Floating-point division: 9.0/5.0 = ";

	cout << 9.0 / 5.0 << endl;
	cout << "Mixed division: 9.0 / 5 = " << 9.0 / 5 << endl;
	cout << "double constants: 1e7 / 9.0 = ";
	cout << 1.e7 / 9.0 << endl;
	cout << "float constants: 1e7f / 9.0f = ";
	cout << 1.e7f / 9.0f << endl;
	return 0;
}
```

下面是该程序的输出：

```console
Integer division: 9/5 = 1
Floating-point division: 9.0/5.0 = 1.800000
Mixed division: 9.0 / 5 = 1.800000
double constants: 1e7 / 9.0 = 1111111.111111
float constants: 1e7f / 9.0f = 1111111.125000
```

> 注意：如果编译器不接受 setf() 中的 ios_base，请使用 ios。

### 3. 求模运算符

求模运算符返回整数除法的余数。它与整数除法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题。

程序清单**3.12 modulus.cpp**

```cpp
// modulus.cpp -- uses % operator to convert lbs to stone
#include <iostream>

int main()
{
	using namespace std;
	const int Lbs_per_stn = 14;
	int lbs;

	cout << "Enter your weight in pounds: ";
	cin >> lbs;
	int stone = lbs / Lbs_per_stn;	// whole stone
	int pounds = lbs % Lbs_per_stn;	// remainder in pounds
	cout << lbs << " pounds are " << stone
		<< " stone, " << pounds << " pound(s).\n";
	return 0;
}
```

下面是该程序的运行情况：

```console
Enter your weight in pounds: 181
181 pounds are 12 stone, 13 pound(s).
```

### 4. 类型转换

C++丰富的类型允许根据需求选择不同的类型，这也使计算机的操作更复杂。C++ 自动执行很多类型转换：

第一种算术类型的值赋给另一种算术类型的变量时，C++ 将对值进行转换：

+ 表达式中包含不同的类型时，C++ 将对值进行转换；

+ 将参数传递给函数时，C++ 将对值进行转换。

#### 4.1 初始化和赋值进行的转换

C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型。

<center>表3.3 潜在的数值转换问题</center>

| 转换                                                         | 潜在的问题                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 将较大的浮点类型转换为较小的浮点类型，如将 double 转换为 float | 精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。 |
| 将浮点类型转换为整型                                         | 小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的。 |
| 将较大的整型转换为较小的整型，如将 long 转换为 short         | 原来的值可能超出目标类型的取值范围，通常只复制右边的字节。   |

程序清单**3.13 assign.cpp**

```cpp
// init.cpp -- type changes on initialization
#include <iostream>

int main()
{
	using namespace std;
	cout.setf(ios_base::fixed, ios_base::floatfield);
	float tree = 3;	// int converted to float
	int guess(3.9832);	// double converted to int
	int debt = 7.2E12;	// result not defined in C++
	cout << "tree = " << tree << endl;
	cout << "guess = " << guess << endl;
	cout << "debt = " << debt << endl;
	return 0;
}
```

下面是该程序的输出：

```console
tree = 3.000000
guess = 3
debt = 1634811904
```

#### 4.2 以 { } 方式初始化时进行的转换（C++ 11）

C++ 11 将使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。它对类型转换的要求严格。具体地说，列表初始化不允许缩窄，即变量的类型可能无法表示赋给它的值。

```cpp
const int code = 66;
int x = 66;
char c1 {31325};	// narrowing, not allowed
char c2 = {66};	// allowed because char can hold 66
char c3 {code};	// ditto
char c4 = {x};	// not allowed, x is not constant
x = 31325;
char c5 = x;	// allowed by this form of initialization
```

#### 4.3 表达式中的转换

当同一个表达式中包含两种不同的算术类型时，将出现什么情况呢？在这种情况下，C++ 将执行两种自动转换；首先，一些类型在出现时便会自动转换；其次，有些类型在于其他类型同时出现在表达式中时将被转换。

先来看看自动转换。在计算表达式时，C++ 将 bool、char、unsigned char、signed char 和 short 值转换为 int。

下面是 C++ 版本的校验表，编译器将依次查阅该列表。

（1）如果有一个操作数的类型是 long double，则将另一个操作数转换为 long double。

（2）否则，如果有一个操作数的类型是 double，则将另一个操作数转换为 double。

（3）否则，如果有一个操作数的类型是 float，则将另一个操作数转换为 float。

（4）否则，说明操作数都是整型，因此只需整型提升。

（5）在这种情况下，如果两个操作数都是有符号或无符号，且其中一个操作数的级别比另一个低，则转换为级别高的类型。

（6）如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。

（7）否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。

（8）否则，将两个操作数都转换为有符号类型的无符号版本。

#### 4.4 强制类型转换

C++ 还允许通过强制类型转换机制显示地进行类型转换。

```cpp
(long)thorn;	// returns a type long conversion of thorn
long (thorn);	// returns a type long conversion of thorn
```

强制类型转换不会修改 thorn 变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。

```cpp
cout << int('Q');	// displays the integer code for 'Q'
```

强制转换的通用格式如下：

```console
(typeName) value	// converts value to typeName type
typeName (value)	// converts value to typeName type
```

第一种格式来自 C 语言，第二种格式是纯粹的 C++。新格式的想法是，要让强制类型转换就像是函数调用。

C++ 还引入了 4 个强制类型转换运算符，对它们的使用要求更为严格，这将在第15章介绍。在这四个运算符中，static_cast<> 用于将值从一种数值类型转换为另一种数值类型。

```cpp
static_cast<long> (thorn)	// returns a type long conversion of thorn
```

推而广之，可以这样做：

```console
static_cast<typeName> (value)	// converts value to typeName type
```

程序清单**3.14 typecast.cpp**

```cpp
// typecast.cpp -- forcing type changes
#include <iostream>

int main()
{
	using namespace std;
	int auks, bats, coots;

	// the following statement adds the values as double.
	// then coverts the result to int
	auks = 19.99 + 11.99;

	// these statements add values as int
	bats = (int)19.99 + (int)11.99;	// old C syntax
	coots = int(19.99) + int(11.99);	// new C++ syntax
	cout << "auks = " << auks << ", bats = " << bats;
	cout << ", coots = " << coots << endl;

	char ch = 'Z';
	cout << "The code for " << ch << " is "; // print as char
	cout << int(ch) << endl;	// print as int
	cout << "Yes, the code is ";
	cout << static_cast<int>(ch) << endl; // using static_cast
	return 0;
}
```

下面是该程序的运行结果：

```console
auks = 31, bats = 30, coots = 30
The code for Z is 90
Yes, the code is 90
```

### 5. C++ 11 中的 auto 声明

C++ 11 新增了一个工具，让编译器能够根据初始值的类型推断变量的类型。为此，它重新定义了 auto 的含义。 auto 是一个 C 语言关键字，但很少使用，有关其以前的含义，请参阅第 9 章。在初始化声明中，如果使用关键字 auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同：

```cpp
auto n = 100;	// n is int
auto x = 1.5;	// x is double
auto y = 1.3e12L;	// y is long double
```

处理复杂类型，如果标准模块库（STL）中的类型时，自动类型推断的优势才能显现出来。例如，对于下述 C++ 98 代码：

```cpp
std::vector<double> scores;
std::vector<double>::iterator pv = scores.begin();
```

C++ 11 允许您将其重写为下面这样：

```cpp
std::vector<double> scores;
auto pv = scores.begin();
```

