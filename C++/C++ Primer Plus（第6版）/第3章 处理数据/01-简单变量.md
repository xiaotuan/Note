C++提倡使用有一定含义的变量名。必须遵循集中简单的 C++ 命名规则。

+ 在名称中只能使用字母字符、数字和下划线（_）。
+ 名称的第一个字符不能时数字。
+ 区分大写字符和小写字符。
+ 不能将 C++ 关键字用作名称。

以两个下划线或下划线和大写字母打头的名称被保留给实现使用。以一个下划线开头的名称被保留给实现，用作全局标识符。

C++ 对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。如果像用两个或更多的单词组成一个名称，通常的做法时用下划线将单词分开。很多程序员可能会在变量名中加入其他的信息，即描述变量类型或内容的前缀。常以这种方式使用的前缀有：n(整数)、str 或 sz（表示以空字符结束的字符串）、b（表示布尔值）、p（表示指针）和 c （表示单个字符）。

C++提供了一种灵活的标准，它确保了最小长度，如下所示：

+ short 至少 16 位。
+ int 至少与 short 一样长。
+ long 至少 32 位，且至少与 int 一样长。
+ long long 至少 64 位，且至少与 long 一样长。

字节通常指的是 8 位的内存单元。C++ 字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。

要知道系统中整数的最大长度，可以在程序中使用 C++ 工具来检查类型的长度。首先，sizeof 运算符返回类型或变量的长度，单位为字节。其次，头文件 climits 中包含了关于整型限制的信息。

程序清单 **3.1 limits.cpp**

```cpp
// limits.cpp -- some integer limits
#include <iostream>
#include <climits>	// use limits.h for older systems
int main()
{
	using namespace std;
	int n_int = INT_MAX;	// initialize n_int to max int value
	short n_short = SHRT_MAX;	// symbols defined in climits file
	long n_long = LONG_MAX;
	long long n_llong = LLONG_MAX;
	
	// sizeof operator yields size of type or of variable
	cout << "int is " << sizeof (int) << " bytes." << endl;
	cout << "short is " << sizeof n_short << " bytes." << endl;
	cout << "long is " << sizeof n_long << " bytes." << endl;
	cout << "long long is " << sizeof n_llong << " bytes." << endl;
	cout << endl;
	
	cout << "Maximum values: " << endl;
	cout << "int: " << n_int << endl;
	cout << "short: " << n_short << endl;
	cout << "long: " << n_long << endl;
	cout << "long long: " << n_llong << endl << endl;
	
	cout << "Minimum int value = " << INT_MIN << endl;
	cout << "Bits per byte = " << CHAR_BIT << endl;
	return 0;
}
```

 对类型名（如 int）使用 sizeof 运算符时，应将名称放在括号中；但对变量名（如 n_short）使用该运算符，括号时可选的。

<center>表3.1 climits 中的符号常量</center>

|  符号常量  |            表示             |
| :--------: | :-------------------------: |
|  CHAR_BIT  |         char 的位数         |
|  CHAR_MAX  |        char 的最大值        |
|  CHAR_MIN  |        char 的最小值        |
| SCHAR_MAX  |    signed char 的最大值     |
| SCHAR_MIN  |    signed char 的最小值     |
| UCHAR_MAX  |   unsigned char 的最大值    |
|  SHRT_MAX  |       short 的最大值        |
|  SHRT_MIN  |       short 的最小值        |
| USHRT_MAX  |   unsigned short 的最大值   |
|  INT_MAX   |        int 的最大值         |
|  INT_MIN   |        int 的最小值         |
|  UNIT_MAX  |    unsigned int 的最大值    |
|  LONG_MAX  |        long 的最大值        |
|  LONG_MIN  |        long 的最小值        |
| ULONG_MAX  |   unsigned long 的最大值    |
| LLONG_MAX  |     long long 的最大值      |
| LLONG_MIN  |     long long 的最小值      |
| ULLONG_MAX | unsigned long long 的最大值 |

初始化将赋值和声明合并在一起。例如：

```cpp
int n_int = INT_MAX;
```

也可以使用字面值常量来初始化。可以将变量初始化为另一个变量，条件时后者已经定义过。甚至可以使用表达式来初始化变量，条件时当程序执行到该声明时，表达式中所有的值都是已知的：

```cpp
int uncles = 5;	// initialize uncles to 5
int aunts = uncles;	// initialize aunts to 5
int chairs = aunts + uncles + 4;	// initialize chairs to 14
```

C++ 还有另一种 C 语言没有的初始化语法：

```cpp
int owls = 101;	// traditional C initialization, sets owls to 101
int wrens(432);	// alternative C++ syntax, set wrens to 432
```

> 警告：如果不对函数内部定义的变量进行初始化，该变量的值将时不确定的，这意味着该变量的值将时它被创建之前，相应内存单元保存的值。

C++ 11 有一种初始化方式，这种方式用于数组和结构，但在 C++ 98 中，也可用于单值变量：

```cpp
int hamburgers = {24};	// set hamburgers to 24
```

将大括号初始化器用于单值变量的情形还不多，但 C++ 11 标准使得这种情形更多了。首先，采用这种方式时，可以使用等号（=），也可以不使用：

```cpp
int emus{7};	// set emus to 5
int rheas = {12};	// set rheas to 12
```

其次，大括号内可以不包含任何东西。在这种情况下，变量将被初始化为零：

```cpp
int rocs = {};	// set rocs to 0
int psychics{};	// set psychics to 0
```

第三，这有助于更好地防范类型转换错误。

要创建无符号版本的基本整型，只需使用关键字 unsigned 来修改声明即可：

```cpp
unsigned short change;	// unsigned short type
unsigned int rovert;	// unsigned int type
unsigned quarterback;	// also unsigned int
unsigned long gone;		// unsigned long type
unsigned long long lang_lang;	// unsigned long long type
```

程序清单 **3.2 exceed.cpp**

```cpp
// exceed.cpp -- exceeding some integer limits
#include <iostream>
#define ZERO 0	// makes ZERO symbol for 0 value
#include <climits>	// defines INT_MAX as largest int value
int main() 
{
	using namespace std;
	short sam = SHRT_MAX;	// initialize a variable to max value
	unsigned short sue = sam;	// okay if variable sam already defined
	
	cout << "Sam has " << sam << " dollars and Sue has " << sue;
	cout << " dollars deposited." << endl
	     << "Add $1 to each account." << endl << "Now ";
	sam = sam + 1;
	sue = sue + 1;
	cout << "Sam has " << sam << " dollars and Sue has " << sue;
	cout << " dollars deposited.\nPoor Sam!" << endl;
	
	sam = ZERO;
	sue = ZERO;
	cout << "Sam has " << sam << " dollars and Sue has " << sue;
	cout << " dollars deposited." << endl;
	cout << "Take $1 from each account." << endl << "Now ";
	sam = sam - 1;
	sue = sue - 1;
	cout << "Sam has " << sam << " dollars and Sue has " << sue;
	cout << " dollars deposited." << endl << "Lucky Sue!" << endl;
	return 0;
}
```

C++ 能够以三种不同的计数方法来书写整数：基数为10、基数为 8 和基数为 16。

程序清单**3.3 hexoct.cpp**

```cpp
// hexoct1.cpp -- shows hex and octal literals
#include <iostream>
int main()
{
	using namespace std;
	int chest = 42;	// decimal integer literal
	int waist = 0x42;	// hexadecimal integer literal
	int inseam = 042;	// octal integer literal
	
	cout << "Monsieur cuts a striking figure!\n";
	cout << "chest = " << chest << " (42 in decimal)\n";
	cout << "waist = " << waist << "( 0x42 in hex)\n";
	cout << "inseam = " << inseam << " (042 in octal)\n";
	return 0;
}
```

程序清单**3.4 hexoct2.cpp** ——使用 hex 和 oct 以上述是那种格式显示十进制值 42

```cpp
// hexoct2.cpp -- display values in hex and octal
#include <iostream>
using namespace std;
int main()
{
	using namespace std;
	int chest = 42;
	int waist = 42;
	int inseam = 42;
	
	cout << "Monsieur cuts a striking figure!" << endl;
	cout << "chest = " << chest << " (decimal for 42)" << endl;
	cout << hex;	// manipulator for changing number base
	cout << "waist = " << waist << " (hexadecimal for 42)" << endl;
	cout << oct;	// manipulator for changing number base
	cout << "inseam = " << inseam << " (octal for 42)" << endl;
	return 0;
}
```

如何确定常量的类型呢？首先来看看后缀。后缀是放在数字常量后面的字母，用于表示类型。整数后面的 l 或 L 后缀表示该整数为 long 常量， u 或 U 后缀表示 unsigned int 常量，ul （可以采用任何一种顺序，大写小写均可）表示 unsigned long常量（由于小写 l 看上去像 1，因此应使用大写 L 作后缀）。接下来考察长度。

程序清单**3.5 chartype.cpp** ——使用 char 类型

```cpp
// chartype.cpp -- the char type
#include <iostream>
int main() 
{
	using namespace std;
	char ch;	// declare a char variable
	
	cout << "Enter a character: " << endl;
	cin >> ch;
	cout << "Hola! ";
	cout << "Thank you for the " << ch << " character." << endl;
	return 0;
}
```

程序清单**3.6 morechar.cpp** —— 在 C++ 中使用字符字面值：将字符用单引号括起来

```cpp
// morechar.cpp -- the char type and int type contrasted
#include <iostream>
int main()
{
	using namespace std;
	char ch = 'M';	// assign ASCII code for M to ch
	int i = ch;	// store same code in an int
	cout << "The ASCII code for " << ch << " is " << i << endl;
	
	cout << "Add one to the character code: " << endl;
	ch = ch + 1;	// change character code in ch
	i = ch;		// save new character code in i
	cout << "The ASCII code for " << ch << " is " << i << endl;
	
	// using the cout.put() member function to display a char
	cout << "Displaying char ch using cout.put(ch): ";
	cout.put(ch);
	
	// using cout.put() to display a char constant
	cout.put('!');
	
	cout << endl << "Done" << endl;
	return 0;
}
```

cout.put() 成员函数提供了另一种显示字符的方法，可以替代 << 运算符。

<center>表3.2 C++ 转义序列的编码</center>

|  字符名称  | ASCII 符号 | C++ 代码 | 十进制 ASCII 代码 | 十六进制 ASCII 码 |
| :--------: | :--------: | :------: | :---------------: | :---------------: |
|   换行符   |   NL(LF)   |    \n    |        10         |        0xA        |
| 水平制表符 |     HT     |    \t    |         9         |        0x9        |
| 垂直制表符 |     VT     |    \v    |        11         |        0xB        |
|    退格    |     BS     |    \b    |         8         |        0x8        |
|    回车    |     CR     |    \r    |        13         |        0xD        |
|    振铃    |    BEL     |    \a    |         7         |        0x7        |
|   反斜杠   |     \      |    \\    |        92         |       0x5C        |
|    问号    |     ?      |    \?    |        63         |       0x3F        |
|   单引号   |     '      |   \\'    |        39         |       0x27        |
|   双引号   |     "      |   \\"    |        34         |       0x22        |

换行符可替代 endl，用于在输出中重起一行。下面三行代码都将光标移到下一行开头：

```cpp
cout << endl;	// using the endl manipulator
cout << '\n';	// using a character constant
cout << "\n";	// using a string
```

可将换行符嵌入到较长的字符串中，这通常比使用 endl 方便。

> 提示：在可以使用数字转义序列或符号转义序列时，应使用符号序列。数字表示与特定的编码方法相关，而符号表示适用于任何编码方式，其可读性也更强。

程序清单 **3.7 bondini.cpp** —— 演示使用转义序列

```cpp
// bondini.cpp -- using e
#include <iostream>
int main()
{
	using namespace std;
	cout << "\aOperation \"HyperHype\" is now activated!\n";
	cout << "Enter your agent code:______\b\b\b\b\b\b";
	long code;
	cin >> code;
	cout << "\aYou entered " << code << "...\n";
	cout << "\aCode verified! Proceed with Plan Z3!\n";
	return 0;
}
```

通用字符名的用法类似于转义序列。通用字符名可以以 \u 或 \U 打头。\u 后面是 8 个十六进制位，\U 后面则是 16 个十六机制位。这些位表示的是字符的 ISO 10646 码点（ISO 10646 是一种正在制定的国际标准，为大量的字符提供了数值编码）。