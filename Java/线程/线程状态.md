[toc]

线程可以有如下 6 中状态：

+   New（新创建）
+   Runnable（可运行）
+   Blocked （被阻塞）
+   Waiting （等待）
+   Timed waiting（计时等待）
+   Terminated（被终止）

要确定一个线程的当前状态，可调用 `getState()` 方法。

### 1. 新创建线程

当用 `new` 操作符创建一个新线程时，如 `new Thread(r)`，该线程还没有开始运行。这意味着它的状态是 `new`。

### 2. 可运行线程

一旦调用 `start` 方法，线程处于 `runnable` 状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。

现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 `yield` 方法、或者被阻塞或等待时，线程才失去控制权。

### 3. 被阻塞线程和等待线程

当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

+   当一个线程试图获取一个内部的对象锁（而不是 `java.util.concurrent` 库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
+   当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 `Object.wait` 方法或 `Thread.join` 方法，或者是等待 `java.util.concurrent` 库中的 `Lock` 或 `Condition` 时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。
+   有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 和 `Object.wait`、`Thread.join`、`Lock.tryLock` 以及 `Condition.await` 的计时版。

### 4. 被终止的线程

线程因如下两个原因之一而被终止：

+   因为 `run` 方法正常退出而自然死亡。
+   因为一个没有捕获的异常终止了 `run` 方法而意外死亡。