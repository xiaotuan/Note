### 结果分析

本节介绍了3个处理元素的方法，它们应用了一些动作到元素上。这些方法如下。

+ `forEach()` ：这是一个结尾操作，它把一个动作应用到 `Stream` 的所有元素上，并返回一个 `void` 值。要应用到元素上的动作可以是lambda表达式，也可以是 `Consumer` 接口的一个实现。 `forEach()` 无法保证有序的应用动作到流的元素上。
+ `forEachOrdered()` ：这是一个结尾操作，如果一个流是有序的，则它会按流的顺序把一个动作应用到所有元素上，并返回一个 `void` 值。可以在使用 `sorted()` 方法之后再使用该方法。先用 `sorted()` 方法排序流的元素，然后使用 `forEachOrdered()` 方法按顺序应用动作。即使是在并行流上， `forEachOrdered()` 也能保证流有序，但在性能方面它不如处理无序流的 `forEach()` 方法。
+ `peek()` ：这是一个中间操作，返回了一个 `Stream` ，其中的元素和调用该方法的流相同。 `peek()` 应用一个表达式形式的动作到所有被流消费的元素上。动作可以用lambda表达式来指定，也可以用一个 `Consumer` 接口的实现类来指定。请注意，由于中间操作是懒执行的，因此在结尾操作发生时，动作才会真正应用到流消费的元素上。

