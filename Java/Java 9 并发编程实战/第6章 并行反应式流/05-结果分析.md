### 结果分析

下面我们来详细看看在这个案例中用来创建流的所有方法。

+ 使用了 `List` 类的 `parallelStream()` 方法。实际上，该方法定义在 `Collection` 接口中。所有实现该接口的类（比如 `ArrayList` 、 `LinkedList` 、 `TreeSet` ）都实现了该方法。开发者可以用 `stream()` 方法创建一个串行流，也可以用 `parallel Stream()` 方法创建一个并行流。
+ 使用了 `Supplier` 接口的一个实现— `MySupplier` 。这个接口提供了 `get()` 方法。每当流需要处理一个元素时，它都会调用这个方法。由于可以创建一个包含无数元素的流，因此应该使用一个限制元素数量的方法，比如 `limit()` 。
+ 使用了 `Stream` 类的 `of()` 方法。它是一个静态方法，接收变长参数，返回的 `Stream` 对象以这些参数作为元素。
+ 使用了 `BufferedReader` 的 `lines()` 方法。它所返回的流，每个元素都是从 `BufferedReader` 中读取到的一行。我们用 `lines()` 方法读取了文件所有的行，也可以在其他类型的 `BufferedReader` 上使用它。
+ 使用了 `Files` 类的 `list()` 方法。该方法接收一个表示文件夹的 `Path` 对象，并返回 `Path` 对象的流，流中的元素代表着 `Path` 对象背后的文件夹中的内容。请记住，该方法不是递归的，如果这个文件夹有一个或多个子文件夹的话，那么 `list()` 方法是不会处理这些内容的。 `Files` 类还有其他一些处理流的方法，稍后会讲到。
+ 使用了 `Arrays` 类的 `stream()` 方法。它接收一个数组并返回一个包含该数组元素的 `Stream` 。如果这个数组是双精度型、整型或长整型的，它会返回一个 `DoubleStream` 、 `IntStream` 或 `LongStream` 对象。它们都是特殊类型的流，可用于处理相应的数字类型。
+ 生成了一个随机数字流。使用了 `Random` 类的 `doubles()` 方法，向其传递了想要得到的元素数量，其实还可以向其传递元素的最大值和最小值。
+ 最后，使用了 `Stream` 类的 `concat()` 方法。它接收两个流，并返回一个包含了这两个流所有元素的流。

我们还使用了 `Stream` 类的一些方法。后面会更详细地讲述其中的大部分内容，这里也提供了一些基础介绍。

+ `count()` ：该方法返回流中元素的数量。它是一个结尾操作，返回 `long` 型数值。
+ `limit()` ：该方法接收一个数字作为参数。如果流本身的元素数量小于这个数字，就会返回包含所有元素的流，否则返回该参数指定数量元素的流。它是一个中间操作。
+ `forEach()` ：该方法允许指定一个动作，以应用到流的每个元素上。我们使用lambda表达式在这个结尾操作里写一些信息到控制台上。
+ `peek()` ：该方法是一个中间操作，允许在流的每个元素上执行一个动作，并返回一个包含相同元素的流。该方法通常用于调试。由于和所有中间操作一样，它也是懒执行的，因此只有在结尾操作发生时，它所指定的动作才会在元素上执行。
+ `average()` ：这是一个声明在 `IntStream` 、 `DoubleStream` 和 `LongStream` 中的方法，返回一个 `OptionalDouble` 对象。 `OptionalDouble` 表示一个双精度型数字，可以有值也可以没有值。它不会为一个空流产生值。
+ `parallel()` ：这个方法把一个串行流转化为并行流。虽然案例中创建的流大部分都是串行的，但是我们能用 `Stream` 类的 `parallel()` 方法将它们转化成并行流。

