### 结果分析

本节使用如下4个方法过滤流中的元素。

+ `distinct()` ：该方法在当前流上根据元素的 `equals()` 方法去除重复的元素，返回一个新的流。我们在例子中用 `Person` 对象和 `int` 型数字测试了这个方法。前面已经重写了 `Person` 的 `equals()` 和 `hashCode()` 方法。如果不重写，则 `equals()` 只在被比较的两个对象持有相同的引用时才返回 `true` 。请注意，由于这个操作是有状态的，因此无法在并行流上获得性能优势（如Java文档所示，“……在并行计算中，有些流水线会包含有状态的中间操作，要求多次传递数据或需要缓存重要的数据……”）。
+ `filter()` ：该方法接收一个 `Predicate` 作为参数。可以使用一个返回值为 `boolean` 型的lambda表达式来代表它。 `filter()` 方法返回一个流，其元素由 `Predicate` 验证为 `true` 。
+ `limit()` ：该方法接收一个 `int` 值作为参数，返回一个元素数量不超过该值的流。在有序并行流上这个方法的性能会很差，特别是在要获取的元素数量很大的时候，因为这个方法会返回流中靠前的元素，而这意味着会有额外的计算。不过，这个问题不会出现在无序流中，因为无序流中哪个元素被返回都可以。
+ `skip()` ：该方法丢弃流中靠前的一部分元素，返回一个新流。被丢弃的元素数量由参数指定。这个方法的性能问题和 `limit()` 方法相同。

