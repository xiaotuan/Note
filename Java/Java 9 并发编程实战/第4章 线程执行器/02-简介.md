### 4.1　简介

一般来说，使用Java开发一个简单的并发程序时，首先需要创建一些 `Runnable` 实例对象，然后创建相应的 `Thread` 实例对象去执行它们。如果不得不开发一个大量运行并发任务的程序，那么前面所说的方式会带来如下问题。

+ 必须实现全部与代码相关的信息来管理 `Thread` 对象（创建、终止、返回结果）。
+ 必须为每一个任务创建一个 `Thread` 对象，因此执行大量任务会影响应用的吞吐量。
+ 必须高效地控制和管理计算机资源。如果创建了太多的线程，则可能会导致系统负载过高。
+ 从Java 5开始，Java并发API提供了 **Executor（执行器）框架机制** 来致力于解决上述问题，这个机制利用 `Executor` 接口、它的子接口 `ExecutorService` 和实现这两个接口的 `ThreadPoolExecutor` 类来实现相关功能。
+ 这种机制将任务的创建和执行分离开来。在一个执行器中，你只用实现 `Runnable` 或是 `Callable` 对象，并提交给执行器。执行器会使用必需的线程来负责执行和运行这些任务。执行器带来的好处还远不止于此：它使用了线程池来提升性能。一个任务提交给执行器时，执行器会试着去使用池内的线程来执行这个任务，从而避免线程创建的泛滥。执行器的另一个重要优点是它提供了 `Callable` 接口， `Callable` 接口和 `Runnable` 接口类似，但它还有如下两个优势。
      + 接口的主要方法 `call()` ，可以返回一个执行结果。
    + 当提交一个 `Callable` 对象给执行器时，你可以获得一个实现了 `Future` 接口的实例对象。通过该对象，你可以掌控 `Callable` 对象的状态和运行结果。

本章将介绍如何在 `Executor` 框架内使用上面提到的类和其他Java并发API的变种。

