### 结果分析

案例执行后的输出结果如下图所示：

![27.png](../images/27.png)
这个案例所解决的问题比较简单，有一个大矩阵，其元素为0～9的随机整数，想要知道某个数字在其中出现的次数。为了提升查询效率，可以采用分而治之的方法，将矩阵划分为5个子集，采用多线程的方式分别统计每个子集中某个数字出现的次数。这些线程执行的任务为 `Searcher` 对象。

在这里，可以采用一个 `CyclicBarrier` 对象来同步5个线程的完成状态<a class="my_markdown" href="['#anchor33']"><sup class="my_markdown">[3]</sup></a>。对每个线程统计结果进行汇总得到最后结果。

正如之前介绍， `CyclicBarrier` 类定义了内部计数器，它对需要在同步状态点进行同步的线程数进行控制。每当一个线程执行到同步状态点时，它会通过调用 `await()` 通知 `CyclicBarrier` 对象有一个线程已达到同步状态点，这时 `CyclicBarrier` 对象将内部计数器的值减1，并将调用线程休眠，直到所有线程均达到同步状态点。

当所有线程均达到同步状态点后， `CyclicBarrier` 对象将唤醒所有因调用该对象 `await()` 方法而休眠等待的线程，并且该对象还会创建一个新的线程来执行在 `CyclicBarrier` 构造器中传入的 `Runnable` 对象（在本节案例中，这指 `Grouper` 对象）。

