### 其他说明

在 `Semaphore` 类中，还有另外3个版本的 `acquire()` 方法。

+ `acquireUninterruptibly()` ：在信号量内部的计数器的值为0时， `acquire()` 方法会阻塞调用线程，直到有新释放的信号量。在阻塞期间，线程可能被中断。如果发生了线程中断，则该方法会抛出一个 `InterruptedException` 异常。而 `acquireUninterruptibly()` 方法会忽略线程中断且不抛出任何异常。
+ `tryAcquire()` ：该方法会尝试获取信号值，如果能够获取，则返回 `true` ；如果不能获取，则返回 `false` ，取代了阻塞线程并等待信号量释放的方法。开发者有责任根据返回值采取正确的操作。
+ `tryAcquire(long timeout, TimeUnit unit)` ：该方法与上一个方法基本相同，只是它会为信号量等待由参数确定指定的一段时间。如果在这段时间过后，仍然无法获得信号量，它才会返回 `false` 。

`acquire()` 、 `acquireUninterruptibly()` 、 `tryAcquire()` 以及 `release()` 方法，均有一个带有一个整型参数的版本。这个参数代表线程想要获取或释放授权的个数，换句话说，它代表了线程要对信号量的计数器增减的数值的单位个数。

如果计数器的值小于传入的参数，则 `acquire()` 、 `acquireUninterruptibly()` 和 `tryAcquire()` 方法会导致调用线程被阻塞，直到计数器的值大于或等于该参数。

#### 信号量的公平性

Java语言中所有能够导致线程阻塞去等待同步资源释放的类都用到了“公平性”这个概念。一般默认为 **非公平模式** ，在该模式下，当同步资源被释放时，会有一个等待中的线程被选中，得以获得资源。然而，这种选择是没有标准的。与此相反的是公平模式，它会选择等待最久的线程。

`Semaphore` 类提供了重载的构造器，它允许传入第二个参数，该参数是个布尔类型。如果传入参数为 `false` ，则创建的 `Semaphore` 将工作在非公平模式下，这也是不传该参数时的默认模式；如果传入参数为 `true` ，则创建的 `Semaphore` 将工作在公平模式下。

