### 结果分析

`ParkingCounter` 类通过两个原子操作来扩展 `AtomicInteger` 类： `carIn()` 和 `carOut()` 。本案例模拟了一个控制停车场内汽车数量的系统。停车场可以容纳多辆汽车，这由 `maxNumber` 字段表示。

`carIn()` 操作将停车场中的实际汽车数量与最大值进行比较。如果它们相等，则汽车不能进入停车场，并且该方法返回 `false` ；否则，它使用以下原子操作结构。

+ 获取局部变量中原子对象的值。
+ 将新值存储在不同变量中。
+ 使用 `compareAndSet()` 方法尝试用新值替换旧值。如果此方法返回 `true` ，则表示作为参数发送的旧值是该变量的值；因此，它改变了数值。当 `carIn()` 方法返回 `true` 时，表明该操作以原子方式进行。如果 `compareAndSet()` 方法返回 `false` ，则意味着作为参数发送的旧值不是该变量的值（另一个线程对其进行了修改）；因此，该操作不能以原子方式完成。操作再次开始，直到可以以原子方式完成。

`carOut()` 方法类似于 `carIn()` 方法。还实现了两个使用 `carIn()` 和 `carOut()` 方法模拟停车活动的 `Runnable` 对象。当程序执行时，你可以看到停车场中的汽车数从未超过最大值。

