### 其他说明

`volatile` 关键字只在单个线程对共享变量进行修改的时候有作用。如果该变量被多个线程修改，则 `volatile` 关键字将不能从数据竞争条件中保护它。它通常不能让+或-操作具有原子性。例如，++操作符在一个volatile变量上并不是线程安全的。

自从Java 5以来， **Java内存模型** 有一个建立于 `volatile` 关键字的 `happens--before` 保证。该事实有如下两个意义。

+ 当修改一个 `volatile` 变量时，它的值会传到主存。而在同一个线程下之前已经修改过的所有 `volatile` 变量的值也会传到主存中。
+ 编译器无法通过重排序来优化修改了一个 `volatile` 变量的指令语句。它可以重排序之前的操作指令或后续指令，但不可以重排序一个 `volatile` 变量指令。而修改这些变量所带来的变更将会遵循 `happen-before` 规则，对其他指令可见。

