### 结果分析

在本节中，深入理解 `Event` 类的作用是非常有必要的。因为该类设计了唯一的激活时间字段以支持 `Delayed` 接口的实现，所以那些 `Event` 对象可以存储在 `DelayQueue` 队列中。

`getDelay()` 方法返回一个激活时间与当前时间的差值（微秒级）。由于两个时间都是 `Date` 对象，因此可以用 `getTime()` 来返回这些对象的值（以毫秒为单位）。然后，可以用参数传过来的 `TimeUnit` 对象来进行时间单位的转换。 `DelayQueue` 类可以用精确到微秒级的值，但在具体实践中，可以用毫秒级等其他时间单位的值。

`compareTo()` 方法返回的值分3种情况，如果方法调用者的值比参数值要小，则返回−1；否则，返回1。但如果两者的值相等，则返回0。

`Task` 类的作用也不容忽视。该类有一个 `integer` 型的 `id` 值。当 `Task` 对象在执行的时候，它将会把 `id` 值与当前时间的值相加并作为激活时间存储在 `DelayQueue` 队列的 `Task` 对象里面。而在队列中，每个 `Task` 对象通过 `add()` 方法来存储100个事件对象。

`Main` 类的 `main()` 方法创建了5个 `Task` 对象，它们分别在对应的线程中执行。当这些线程完成执行后，用 `poll()` 方法获取所有事件对象并打印相关信息到控制台中。 `poll()` 方法本身会取出并移除队列中的首个元素。如果队列没有任何已激活的元素，则该方法会返回 `null` 值；反之，如果返回的值不为 `null` ，则执行 `counter++` 。需要特别注意的是，当返回 `null` 值时，它会在控制台打印 `counter` 的值，并且对当前线程执行持续时间为0.5s的休眠操作以等待其他可激活事件对象。当队列中的500个事件对象全部出队以后，该程序就执行完成了。

本案例的部分输出结果如下图所示。

![53.png](../images/53.png)
可以看到程序是如何获取100个已激活事件对象的。

> <img class="my_markdown" src="../images/54.png" style="width:73px;  height: 69px; " width="8%"/>
> 注意 `size()方法` 的含义。该方法会返回队列的元素总数，其中包含已激活和未激活的元素。

