### 11.6　委托执行器管理线程

在用Java 5之前的Java 并发API实现并发程序时，我们只能自己管理线程。首先要实现 `Runnable` 接口或继承 `Thread` 类，然后创建线程对象并使用 `start()` 方法启动。还要控制线程状态以确定线程是已执行完还是执行中。

到了 Java5，执行器作为线程池提供者的概念出现了。这种机制由 `Executor` 和 `ExecutorService` 接口， `ThreadPoolExecutor` 和 `ScheduledThreadPool Executor` 类实现，它使得我们可以专注于多线程任务中的业务逻辑的实现。我们实现任务，然后将其发送给执行器。执行器包含一个线程池，正是这个线程池负责线程的创建、管理和终结。到了Java 7，执行器机制的另一种实现在fork/join框架中出现了，fork/join框架专注的领域是将一个问题分解为多个更小的子问题。执行器机制有如下几个优点。

+ 不必再为所有任务单独创建线程。任务发送给执行器之后，池中的线程就会执行它，这节省了创建新线程的时间。如果一个应用程序需要执行大量的任务，那么节省的时间将非常可观，应用程序的性能将得以改善。
+ 创建的线程越少，应用程序使用的内存越少。这也能改善应用程序的性能。
+ 执行器可以执行实现了 `Runnable` 和 `Callable` 接口的并发任务。利用 `Callable` 接口可以实现带有返回结果的任务，这相比传统任务是一个巨大的优势。
+ 我们向执行器发送任务后，它返回了 `Future` 对象，使用该对象可以简单容易地获取任务的状态、返回结果，以及任务的完成情况。
+ 使用 `ScheduledThreadPoolExecutor` 类实现的执行器，能够安排任务按时重复执行。
+ 指定池中的最大线程数，就简单地控制了执行器使用的资源，它不会同时运行超过该数量的任务。

使用执行器比直接使用线程多了许多优点。本节将实现一个例子，用于展示如何使用执行器来获取比手动创建线程更高的性能。

