### 结果分析

分析程序的执行输出不难发现队列内的事件数不断增长，直到 `40` ，然后在 `40` 左右浮动，直到程序结束。当然，这个大小取决于计算机的内核数。本次执行运行在四核处理器上，因此启动了4个 `WriterTask` 任务。

程序一开始便启动了4个 `WriterTask` 线程，每个线程向队列写入一个事件并休眠1s。在第一个 `10` s后，队列中便存储了 `40` 个事件。在这 `10` s中， `CleanerTask` 线程在4个 `WriterTask` 线程休眠时开始执行；由于所有事件均在10s内产生，因此，不会从队列中删除任何事件。在接下来的执行过程中，每一秒， `CleanerTask` 会删除4个事件， `WriterTask` 写入另外4个事件。因此，队列中的事件个数总在 `40` 左右。正如前文所说，案例执行取决于JVM可用内核数，通常而言，这个数等于CPU的内核数。

当然，你也可以修改 `WriterTask` 线程休眠时间，当其休眠时间足够小时， `CleanerTask` 只能获得更少的CPU时间，从而导致 `CleanerTask` 无法及时删除队列事件，队列中的事件数量会不断增长。

