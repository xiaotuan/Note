### 结果分析

本案例的关键在于 `EventStorage` 类的 `set()` 和 `get()` 两个方法。首先通过 `set()` 方法来判断当前存储器中是否还有剩余空间。如果当前存储器已满，则当前线程通过 `wait()` 方法来等待。一旦有其他线程请求了 `notify()` 方法，当前线程将会唤醒并查看当前是否已经满足继续执行的条件，然而仅通过 `notify()` 方法并不能保证可以满足继续执行的条件，因此这一过程将持续重复直到当前线程能够在存储器中创建一个新的事件。

`get()` 方法的作用方式也类似。首先，线程将会查看当前存储器中是否有可以获取的事件，如果 `EventStorage` 类的状态为空，则当前线程需要调用 `wait()` 方法持续等待直到有事件进入存储器中。如果此时有其他线程调用了 `notify()` 方法，则该线程将会唤醒，并检查当前线程是否已经满足了继续执行的条件，该过程将持续重复直到线程能从当前存储器中获得一个事件。

> <img class="my_markdown" src="../images/19.png" style="width:73px;  height: 69px; " width="8%"/>
> 必须不断检查条件并在 `while` 循环中执行 `wait()` 方法。只有在当前条件能够满足时才能终止循环。

执行本案例代码时，虽然生产者和消费者不断地从存储器中插入和获得事件，但存储器存放的事件数量将永远保持在10个以内。

