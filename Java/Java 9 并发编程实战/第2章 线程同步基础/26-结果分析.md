### 结果分析

在本案例中，所有 `Condition` 对象实例都是通过 `Lock` 接口的 `newCondition()` 方法产生的。不过在使用这些条件之前，线程需要获得与该条件变量绑定的锁。因此开发者只能在线程上通过 `Lock` 接口的 `lock()` 方法获得条件变量锁后，才能继续对该条件进行相关的操作。换句话说，必须在线程中调用了同一个 `Lock` 对象的 `lock()` 和 `unlock()` 方法之间使用条件变量。

当线程调用了条件的 `await()` 方法后，将自动释放线程上已经获得的锁，以保证其他线程能够成功进入由同一个锁保护的临界区代码中。

> <img class="my_markdown" src="../images/19.png" style="width:73px;  height: 69px; " width="8%"/>
> 当一个线程调用了条件变量上的 `signal()` 方法或者 `signalAll()` 方法后（译者注：原书对 `signalAll()` 方法名拼写有误），它将会唤醒其他在同一个条件上等待的线程。但是这并不意味着线程唤醒后就满足了继续运行的条件，因此必须把 `await()` 方法添加在 `while` 循环中。如果当前线程继续往下执行的条件不能得到满足，则将通过 `await()` 方法继续保持循环。

开发者需要谨慎处理 `await()` 和 `signal()` 两个方法。若在线程中调用了 `await()` 方法后却没有任何线程调用同一个条件的 `signal()` 方法，则该线程将永远不会被唤醒。

线程通过 `await()` 方法沉睡后可能会由其他线程中断，因此开发者要谨慎处理抛出的 `InterruptedException` 异常。

