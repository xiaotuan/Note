如果使用序列化来保存对象，就需要考虑在程序演化时会有什么问题。例如，1.1 版本可以读入旧文件吗？仍旧使用 1.0 版本的用户可以读入新版本产生的文件吗？显然，如果对象文件可以处理类的演化问题，那它正是我们想要的。

想要这样做，就必须首先获得这个类的早期版本的指纹。我们可以使用 JDK 中的单机程序 `serialver` 来获得这个数字，例如，运行下面的命令：

```shell
$ serialver Employee
Employee:    private static final long serialVersionUID = 450782130437157025L;
```

如果在运行 `serialver` 程序时添加 `-show` 选项，那么这个程序就会产生图形化对话框。

这个类的所有较新的版本都必须把 `serialVersionUID` 常量定义为与最初版本的指纹相同。

```java
class Employee implements Serializable {	// version 1.1
	...
    public static final long serialVersionUID = 450782130437157025L;
}
```

如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有任何问题的。但是，如果数据域产生了变化，那么就可能会有问题。例如，旧文件对象可能比程序中的对象具有更多或更少的数据域，或者数据域的类型可能有所不同。在这些情况中，对象输入流将尽力将流对象转换成这个类当前的版本。

对象输入流会将这个类当前版本的数据域与被序列化的版本中的数据域进行比较，当然，对象流只会考虑非瞬时和非静态的数据域。如果这两部分数据域之间名字匹配而类型不匹配，那么对象输入流不会尝试将一种类型转换成另一种类型，因为这两个对象不兼容；如果被序列化的对象具有在当前版本中所没有的数据域，那么对象输入流会忽略这些额外的数据；如果当前版本具有在被序列化的对象中所没有的数据域，那么这些新添加的域将被设置成它们的默认值。