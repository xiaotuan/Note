`Java` 编程语言中的字符串是 `UTF-16` 编码点的序列，而 `C` 的字符串则是以 `null` 结尾的字节序列，所以在这两种语言中的字符串是很不一样的。`Java` 本地接口有两组操作字符串的函数，一组把 `Java` 字符串转换成 "改良的 UTF-8" 字节序列，另一组将它们转换成 `UTF-16` 数值的数组，也就是说转换成 `jchar` 数组。

如果你的 `C` 代码已经使用了 `Unicode`，那么你可以使用第二组转换函数。另一方面，如果你的字符串都仅限于使用 `ASCII` 字符，你可以使用 “改良的 UTF-8” 转换函数。

带有字符串参数的本地方法实际上都要接受一个 `jstring` 类型的值，而带有字符串参数返回值的本地方法必须返回一个 `jstring` 类型的值。`JNI` 函数将读入并构造出这些 `jstring` 对象。例如，`NewStringUTF` 函数会从包含 ASCII 字符的字符数组，或者是更一般的 “改良的 UTF-8” 编码的字符序列中，创建一个新的 `jstring` 对象。

`JNI` 函数有一个有些古怪的调用惯例。下面是对 `NewStringUTF` 函数的一个调用：

```c
JNIEXPORT jstring JNICALL Java_HelloNative_getGreeting(JNIEnv *env, jclass cl)
{
    jstring jstr;
    char greeting[] = "Hello, Native World\n";
    jstr = (*env)->NewStringUTF(env, greeting);
    return jstr;
}
```

所有对 `JNI` 函数的调用都使用到了 `env` 指针，该指针是每一个本地方法的第一个参数。`env` 指针是指向函数指针表的指针。所以，你必须在每个 `JNI` 调用前面加上 `(*env)->`，以便解析对函数指针的引用。

`NewStringUTF` 函数可以用来构造一个新的 `jstring`，而读取现有 `jstring` 对象的内容，需要使用 `GetStringUTFChars`函数。该函数返回指向描述字符串的 “改良 UTF-8” 字符的 `const jbyte*` 指针。注意，具体的虚拟机可以为其内部的字符串表示方法自由地选择编码机制。所以，你可以得到实际的 `java` 字符串的字符指针。因为 `Java` 字符串是不可变的，所以慎重处理 `const` 就显得非常重要，不要试图将数据写到该字符数组中。另一方面，如果虚拟机使用 `UTF-16` 或 `UTF-32` 字符作为其内部字符串的表示，那么该函数会分配一个新的内存块来存储等价的 “改良 UTF-8” 编码字符。

虚拟机必须知道你何时使用完字符串，这样它就能进行垃圾回收。基于这个原因，你必须调用 `ReleaseStringUTFChars`函数。

另外，可以通过调用 `GetStringRegion` 或 `GetStringUTFRegion` 方法来提供你自己的缓存，以存放字符串的字符。

最后 `GetStringUTFLength` 函数返回字符串的 “改良 UTF-8” 编码所需的字符个数。

**示例程序：**

**Printf2Test.java**

```java
package com.qty;

public class Printf2Test {

    public static void main(String[] args) {
        double price = 44.95;
        double tax = 7.75;
        double amountDue = price * (1 + tax / 100);

        String s = Printf2.sprint("Amount due = %8.2f", amountDue);
        System.out.println(s);
    }

    static {
        System.loadLibrary("libs/Printf2");
    }

}
```

**Printf2.java**

```java
package com.qty;

public class Printf2 {

    public static native String sprint(String format, double x);

}
```

**com_qty_Printf2.h**

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_qty_Printf2 */

#ifndef _Included_com_qty_Printf2
#define _Included_com_qty_Printf2
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_qty_Printf2
 * Method:    sprint
 * Signature: (Ljava/lang/String;D)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_qty_Printf2_sprint
  (JNIEnv *, jclass, jstring, jdouble);

#ifdef __cplusplus
}
#endif
#endif
```

**com_qty_Printf2.c**

```c
#include <string.h>
#include <stdlib.h>
#include <float.h>

#include "com_qty_Printf2.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @param format a string containing a printf format specifier
 *				(such as %8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the '%')
 *		or NULL if there wasn't a unique format specifier
 */
char* find_format(const char format[])
{
	char* p;
	char* q;

	p = strchr(format, '%');
	while (p != NULL && *(p + 1) == '%') /* skip %% */
	{
		p = strchr(p + 2, '%');
	}
	if (p == NULL) return NULL;
	/* now check that % is unique */
	p++;
	q = strchr(p, '%');
	while (q != NULL && *(q + 1) == '%') /* skip %% */
	{
		q = strchr(q + 2, '%');
	}
	if (q != NULL) return NULL;	/* % not unique */
	q = p + strspn(p, " -0+#");	/* skip past flags */
	q += strspn(q, "0123456789"); /* skip past field width */
	if (*q == '.') /* skip past precision */
	{
		q++;
		q += strspn(q, "0123456789");
	}
	/* not a floating-point format */
	if (strchr("eEfFgG", *q) == NULL) return NULL;
	return p;
}


JNIEXPORT jstring JNICALL Java_com_qty_Printf2_sprint
(JNIEnv* env, jclass cl, jstring format, jdouble x)
{
	const char* cformat;
	char* fmt;
	jstring ret;

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);
	if (fmt == NULL)
	{
		ret = format;
	} else {
		char* cret;
		int width = atoi(fmt);
		if (width == 0)
		{
			width = DBL_DIG + 10;
		}
		cret = (char*)malloc(strlen(cformat) + width);
		sprintf_s(cret, strlen(cformat) + width, cformat, x);
		ret = (*env)->NewStringUTF(env, cret);
		free(cret);
	}
	(*env)->ReleaseStringUTFChars(env, format, cformat);
	return ret;
}

#ifdef __cplusplus
}
#endif
```

运行结果如下：

```shell
"C:\Program Files\Java\jdk-11.0.14\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.3\lib\idea_rt.jar=56013:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.3\bin" -Dfile.encoding=UTF-8 -classpath C:\WorkSpace\JavaSpace\Printf2\out\production\Printf2 com.qty.Printf2Test
Amount due =    48.43

Process finished with exit code 0
```

本函数中，我们选择简化错误处理。如果打印浮点数的格式代码不是 `%w.pc` 形式的（其中 c 是 e、E、f、g 或 G 中的一个），那么我们将不对数字进行格式化。

