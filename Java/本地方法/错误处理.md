在 `Java` 编程语言中，使用本地方法对于程序来说是要冒很大的安全风险的。`C` 的运行期系统对数组越界错误、不良指针造成的间接错误等不提供任何防护。所以，对于本地方法的程序员来说，处理所有的出错条件以保持 `Java` 平台的完整性显得格外重要。尤其是，当你的本地方法诊断出一个它无法解决的问题时，那么它应该将此问题报告给 `Java` 虚拟机。然后，在这种情况下，很自然地会抛出一个异常。然而，`C` 语言没有异常，必须调用 `Throw` 或 `ThrowNew` 函数来创建一个新的异常对象。当本地方法退出时，`Java` 虚拟机就会抛出该异常。

要使用 `Throw` 函数，需要调用 `NewObject` 来创建一个 `Throwable` 子类的对象。例如，下面我们分配了一个 `EOFException` 对象，然后将它抛出：

```c
jclass class_EOFException = (*env)->FindClass(env, "java/io/EOFException");
jmethodID id_EOFException = (*env)->GetMethodID(env, class_EOFException, "<init>", "()V");	/* ID of no-argument constructor */
jthrowable obj_exc = (*env)->NewObject(env, class_EOFException, id_EOFException);
(*env)->Throw(env, obj_exc);
```

通常调用 `ThrowNew` 会更加方便，因为只需提供一个类和一个 "改良 UTF-8" 字节序列，该函数就会构建一个异常对象。

```c
(*env)->ThrowNew(env, (*env)->FindClass(env, "java/io/EOFException"), "Unexpected end of file");
```

`Throw` 和 `ThrowNew` 都仅仅只是发布异常，它们不会中断本地方法的控制流。只有当该方法返回时，`Java` 虚拟机才会抛出异常。所以，每一个对 `Throw` 和 `ThrowNew` 的调用语句之后总是紧跟着 `return` 语句。

> 注意：如果用 `C++` 实现本地方法，那么就无法用你的 `C++` 代码抛出 `Java` 异常。在 `C++` 绑定中，是可以实现一个在 `C++` 异常和 `Java` 异常之间的转换的。然而，到目前为止还没有实现这个功能。需要在本地方法中使用 `Throw` 或 `ThrowNew` 函数来抛出 `Java` 异常，并且要确保你的本地方法不抛出 `C++` 异常。

通常，本地代码不需要考虑捕获 `Java` 异常。但是，当本地方法调用 `Java` 方法时，该方法可能会抛出异常。而且，一些 `JNI` 函数也会抛出异常。例如，如果索引越界，`SetObjectArrayElement` 方法会抛出一个 `ArrayIndexOutOfBoundsException` 异常，如果所存储的对象的类不是数组元素类的子类，该方法会抛出一个 `ArrayStoreException` 异常。在这类情况下，本地方法应该调用 `ExceptionOccurred` 方法来确认是否有异常抛出。如果没有任何异常等待处理，则下面的调用：

```c
jthrowable obj_exc = (*env)->ExceptionOccurred(env);
```

将返回 `NULL`。否则，返回一个当前异常对象的引用。如果只要检查是否有异常抛出，而不需要获得异常对象的引用，那么应使用：

```c
jboolean occurred = (*env)->ExceptionCheck(env);
```

通常，有异常出现时，本地方法应该直接返回。那样，虚拟机就会将该异常传送给 `Java` 代码。但是，本地方法也可以分析异常对象，确定它是否能够处理该异常。如果能够处理，那么必须调用下面的函数来关闭该异常：

```c
(*env)->ExceptionClear(env);
```

**示例程序：**
**Printf4.java**

```java
package com.qty;

import java.io.PrintWriter;

public class Printf4 {

    public static native void fprint(PrintWriter ps, String format, double x);

    static {
        System.loadLibrary("libs/Printf4");
    }
}
```

**Printf4Test.java**

```java
package com.qty;

import java.io.PrintWriter;

public class Printf4Test {

    public static void main(String[] args) {
        double price = 44.95;
        double tax = 7.75;
        double amountDue = price * (1 + tax / 100);
        PrintWriter out = new PrintWriter(System.out);
        /* This call will throw an exception--note the %% */
        Printf4.fprint(out, "Amount due = %%8.2f\n", amountDue);
        out.flush();
    }

}
```

**com_qty_Printf4.h**

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_qty_Printf4 */

#ifndef _Included_com_qty_Printf4
#define _Included_com_qty_Printf4
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_qty_Printf4
 * Method:    fprint
 * Signature: (Ljava/io/PrintWriter;Ljava/lang/String;D)V
 */
JNIEXPORT void JNICALL Java_com_qty_Printf4_fprint
  (JNIEnv *, jclass, jobject, jstring, jdouble);

#ifdef __cplusplus
}
#endif
#endif
```

**com_qty_Printf4.c**

```c
#include "com_qty_Printf4.h"
#include <string.h>
#include <stdlib.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @param format string containing a printf format specifier
 * (such as "%8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the '%')
 * or NULL if there wasn't a unique format specifier
 */
char* find_format(const char format[])
{
	char* p;
	char* q;

	p = strchr(format, '%');
	while (p != NULL && *(p + 1) == '%') /* skip %% */
	{
		p = strchr(p + 2, '%');
	}
	if (p == NULL) return NULL;
	/* now check that % is unique */
	p++;
	q = strchr(p, '%');
	while (q != NULL && *(q + 1) == '%') /* skip %% */
	{
		q = strchr(q + 2, '%');
	}
	if (q != NULL) return NULL; /* % not unique */
	q = p + strspn(p, " -0+#");	/* skip past flags */
	q += strspn(q, "0123456789");	/* skip past field width */
	if (*q == '.') {
		q++;
		q += strspn(q, "0123456789");
	}
	/* skip past precision */
	if (strchr("eEfFgG", *q) == NULL) return NULL;
	/* not a floating-point format */
	return p;
}

JNIEXPORT void JNICALL Java_com_qty_Printf4_fprint
(JNIEnv* env, jclass cl, jobject out, jstring format, jdouble x)
{
	const char* cformat;
	char* fmt;
	jclass class_PrintWriter;
	jmethodID id_print;
	char* cstr;
	int width;
	int i;

	if (format == NULL)
	{
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/NullPointerException"), "Printf4.fprint: format is null");
		return;
	}

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);

	if (fmt == NULL)
	{
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/IllegalArgumentException"), "Printf4.fprint: format is invalid");
		return;
	}

	width = atoi(fmt);
	if (width == 0) width = DBL_DIG + 10;
	cstr = (char*)malloc(strlen(cformat) + width);

	if (cstr == NULL)
	{
		(*env)->ThrowNew(env,
			(*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Printf4.fprint: malloc failed");
		return;
	}

	sprintf_s(cstr, strlen(cformat) + width, cformat, x);

	(*env)->ReleaseStringUTFChars(env, format, cformat);

	/* now call ps.print(str) */

	/* get the class */
	class_PrintWriter = (*env)->GetObjectClass(env, out);

	/* get the method ID */
	id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(C)V");

	/* call the method */
	for (i = 0; cstr[i] != 0 && !(*env)->ExceptionOccurred(env); i++)
	{
		(*env)->CallVoidMethod(env, out, id_print, cstr[i]);
	}

	free(cstr);
}

#ifdef __cplusplus
}
#endif
```

运行结果如下：

```shell
"D:\Program Files\Java\jdk-11.0.11\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.2.5\lib\idea_rt.jar=54822:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.2.5\bin" -Dfile.encoding=UTF-8 -classpath C:\WorkSpaces\IdeSpace\Printf4\target\classes com.qty.Printf4Test
Exception in thread "main" java.lang.IllegalArgumentException: Printf4.fprint: format is invalid
	at com.qty.Printf4.fprint(Native Method)
	at com.qty.Printf4Test.main(Printf4Test.java:13)

Process finished with exit code 1
```

