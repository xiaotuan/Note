[toc]

### 1. 实例方法

作为从本地代码调用 `Java` 方法的一个例子，它能够在任意 `PrintWriter` 对象上打印一个字符串。下面是用 `Java` 编写的该方法的定义：

```java
class Printf3 {
    public native static void fprint(PrintWriter out, String s, double x);
    ...
}
```

使用如下函数调用，你可以从 C 中调用任何 `Java` 方法：

```c
(*env)->CallXxxMethod(env, implicit parameter, methodID, explicit parameters)
```

根据方法的返回类型，用 `Void`、`Int` 、`Object` 等来替换 `Xxx`。就像你需要一个 `fieldID` 来访问某个对象的一个域一样，你还需要一个方法的 `ID` 来调用方法。你可以通过调用 `JNI` 函数 `GetMethodID` ，并且提供该类、方法的名字和方法签名来获得方法 `ID`。

在我们的例子中，我们想要获得 `PrintWriter` 类的 `print` 方法的 `ID`。`PrintWriter` 类有几个名为 `print`的重载方法。基于这个原因，你还必须提供一个字符串，描述你想要使用的特定函数的参数和返回值。例如，我们想要使用 `void print(java.lang.String)`，必须把签名 "混编" 为字符串`(Ljava/lang/String;)V`。

下面是进行方法调用的完整代码，有以下几个步骤：

1）获取隐式参数的类。

2）获取方法 ID。

3）进行调用。

```c
/* get the class */
class_PrintWriter = (*env)->GetObjectClass(env, out);

/* get the method ID */
id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(Ljava/lang/String;)V");

/* call the method */
(*env)->CallVoidMethod(env, out, id_print, str);
```

> 注意：数值型的方法 `ID` 和域 `ID` 在概念上和反射 `API`中的 `Method`和 `Field` 对象相似。你可以使用以下函数在两者间进行转换：
>
> ```c
> jobject ToReflectedMethod(JNIEnv* env, jclass class, jmethodID methodID);
> // return Method object
> methodID FromReflectedMethod(JNIEnv* env, jobject method);
> jobject ToReflectedField(JNIEnv* env, jclass class, jfieldID fieldID);
> // returns Field object
> fieldIDFromReflec(JNIEnv* env, jobject field);
> ```

**示例程序：**

**Printf3Test.java**

```java
package com.qty;

import java.io.PrintWriter;

public class Printf3Test {

    public static void main(String[] args) {
        double price = 44.95;
        double tax =7.75;
        double amountDue = price * (1 + tax / 100);
        PrintWriter out= new PrintWriter(System.out);
        Printf3.fprint(out, "Amount due = %8.2f\n", amountDue);
        out.flush();
    }

}
```

**Printf3.java**

```java
package com.qty;

import java.io.PrintWriter;

public class Printf3 {

    public static native void fprint(PrintWriter out, String format, double x);

    static {
        System.loadLibrary("libs/Printf3");
    }
}
```

**com_qty_Printf3.h**

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_qty_Printf3 */

#ifndef _Included_com_qty_Printf3
#define _Included_com_qty_Printf3
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_qty_Printf3
 * Method:    fprint
 * Signature: (Ljava/io/PrintWriter;Ljava/lang/String;D)V
 */
JNIEXPORT void JNICALL Java_com_qty_Printf3_fprint
  (JNIEnv *, jclass, jobject, jstring, jdouble);

#ifdef __cplusplus
}
#endif
#endif
```

**com_qty_Printf3.c**

```c
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include "com_qty_Printf3.h"

#ifdef __cplusplus
extern "C" {
#endif

	/**
 * @param format a string containing a printf format specifier
 *				(such as %8.2f"). Substrings "%%" are skipped.
 * @return a pointer to the format specifier (skipping the '%')
 *		or NULL if there wasn't a unique format specifier
 */
	char* find_format(const char format[])
	{
		char* p;
		char* q;

		p = strchr(format, '%');
		while (p != NULL && *(p + 1) == '%') /* skip %% */
		{
			p = strchr(p + 2, '%');
		}
		if (p == NULL) return NULL;
		/* now check that % is unique */
		p++;
		q = strchr(p, '%');
		while (q != NULL && *(q + 1) == '%') /* skip %% */
		{
			q = strchr(q + 2, '%');
		}
		if (q != NULL) return NULL;	/* % not unique */
		q = p + strspn(p, " -0+#");	/* skip past flags */
		q += strspn(q, "0123456789"); /* skip past field width */
		if (*q == '.') /* skip past precision */
		{
			q++;
			q += strspn(q, "0123456789");
		}
		/* not a floating-point format */
		if (strchr("eEfFgG", *q) == NULL) return NULL;
		return p;
	}

JNIEXPORT void JNICALL Java_com_qty_Printf3_fprint
  (JNIEnv *env, jclass cl, jobject out, jstring format, jdouble x)
{
	const char* cformat;
	char* fmt;
	jstring str;
	jclass class_PrintWriter;
	jmethodID id_print;

	cformat = (*env)->GetStringUTFChars(env, format, NULL);
	fmt = find_format(cformat);
	if (fmt == NULL)
	{
		str = format;
	}
	else {
		char* cstr;
		int width = atoi(fmt);
		if (width == 0) width = DBL_DIG + 10;
		cstr = (char*)malloc(strlen(cformat) + width);
		sprintf_s(cstr, strlen(cformat) + width, cformat, x);
		str = (*env)->NewStringUTF(env, cstr);
		free(cstr);
	}
	(*env)->ReleaseStringUTFChars(env, format, cformat);

	/* now call ps.print(str) */

	/* get the class */
	class_PrintWriter = (*env)->GetObjectClass(env, out);

	/* get the method ID */
	id_print = (*env)->GetMethodID(env, class_PrintWriter, "print", "(Ljava/lang/String;)V");

	/* call the method */
	(*env)->CallVoidMethod(env, out, id_print, str);
}

#fdef __cplusplus
}
#endif
```

### 2. 静态方法

从本地方法调用静态方法与调用非静态方法类似。两者的差别是：

+ 要用 `GetStaticMethodID` 和 `CallStaticXxxMethod` 函数。
+ 当调用方法时，要提供类对象，而不是隐式的参数对象。

作为一个例子，让我们从本地方法调用一下静态方法：

```java
System.getProperty("java.class.path");
```

首先，我们必须找到要用的类。因为我们没有 `System` 类的对象可供使用，所以我们使用 `FindClass` 而非 `GetObjectClass`：

```c
jclass class_System = (*env)->FindClass(env, "java/lang/System");
```

接着，我们需要静态 `getProperty` 方法的 `ID`。该方法的编码签名是：

```
(Ljava/lang/String;)Ljava/lang/String;
```

既然参数和返回值都是字符串。因此，我们这样获取方法 `ID`：

```c
jmethodID id_getProperty = (*env)->GetStaticMethodID(env, class_System, "getPropterty", "(Ljava/lang/String;)Ljava/lang/String;");
```

最后，我们进行调用。注意，类对象被传递给了 `CallStaticObjectMethod` 函数。

```c
jobject obj_ret = (*env)->CallStaticObjectMethod(env, class_System, id_getProperty, (*env)->NewStringUTF(env, "java.class.path"));
```

该方法的返回值是 `jobject` 类型的。如果我们想要把它当作字符串操作，必须把它转型为 `jstring`：

```c
jstring str_ret = (jstring) obj_ret;
```

### 3. 构造器

本地方法可以通过构造器来创建新的 `Java` 对象。可以调用 `NewObject` 函数来调用构造器：

```c
jobject obj_new = (*env)->NewObject(env, class, methodID, construction parameters);
```

可以通过指定方法名为 `<init>`，并指定构造器（返回值为 `void`）的编码签名，从 `GetMethodID` 函数中获取该调用必需的方法 `ID`。例如，下面是本地方法创建 `FileOutputStream` 对象的情形：

```c
const char[] fileName = "...";
jstring str_fileName = (*env)->NewStringUTF(env, fileName);
jclass class_FileOutputStream = (*env)->FindClass(env, "java/io/FileOutputStream");
jmethodID id_FileOutputStream = (*env)->GetMethodID(env, class_FileOutputStream, "<init>", "(Ljava/lang/String;)V");
jobject obj_stream = (*env)->NewObject(env, class_FileOutputStream, id_FileOutputStream, str_fileName);
```

### 4. 另一种方法调用

有若干种 `JNI` 函数的变体都可以从本地代码调用 `Java` 方法。

`CallNonvirtualXxxMethod` 函数接收一个隐式参数、一个方法 `ID`、一个类对象（必须对应于隐式参数的超类）和一个显式参数。这个函数将调用指定的类中指定版本的方法，而不使用常规的动态调用机制。

所有调用函数都有后缀 `A` 和 `V` 的版本，用于接收数组中或 `va_list` 中的显示参数（就像在 `C` 头文件 `stdarg.h` 中所定义的那样。

