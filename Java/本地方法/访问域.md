[toc]

下面，我们考虑在对象上进行操作的本地方法。作为一个练习，我们用本地方法实现 `Employee` 类的一个方法。

### 1. 访问实例域

为了了解怎样从本地方法访问实例域，我们用 `Java` 重新实现了 `raiseSalary` 方法。其代码很简单：

```java
public void raiseSalary(double byPercent) {
    salary *= 1 + byPercent / 100;
}
```

让我们重写代码，使其成为一个本地方法。与此前的本地方法不同，它并不是一个静态方法。运行 `javah` 给出以下原型：

```c
```

注意，第二个参数不再是 `jclass` 类型而是 `jobject` 类型。实际上，它和 `this` 引用等价。静态方法得到的是类的引用，而非静态方法得到的是对隐式的 `this` 参数对象的引用。

现在，我们访问隐式参数的 `salary` 域。在 `Java 1.0` 中 "原生的" `Java` 到 `C` 的绑定中，这很简单，程序员可以直接访问对象数据域。然而，直接访问要求虚拟机暴露它们的内部数据布局。基于这个原因，`JNI` 要求程序员通过调用特殊的 `JNI` 函数来获取和设置数据的值。

在我们例子里，要使用 `GetDoubleField` 和 `SetDoubleField`函数，因为 `salary`是 `double` 类型的。对于其他类型，可以使用的函数有：`GetIntField/SetIntField`、`GetObjectField/SetObjectField`等等。其通用语法是：

```c
x = (*env)->GetXxxField(env, this_obj, fieldID);
(*env)->SetXxxField(env, this_obj, fieldID, x);
```

这里，`fieldID` 是一个特殊类型 `jfieldID` 的值，`jfieldID` 标识结构中的一个域，而 `Xxx` 代表 `Java` 数据类型（`Object`、`Boolean`、`Byte` 或其他）。为了获得 `fieldID`，必须先获得一个表示类的值，有两种方法可以实现此目的。`GetObjectClass` 函数可以返回任意对象的类。例如：

```c
jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
```

`FindClass` 函数可以让你以字符串形式来制定类名（有点奇怪的是，要以 `/` 代替句号作为包名之间的分隔符）。

```c
jclass class_String = (*env)->FindClass(env, "java/lang/String");
```

之后，可以使用 `GetFieldID` 函数来获得 `fieldID`。必须提供域的名字、它的签名以及它的类型的编码。例如，下面是从 `salary` 域得到域 `ID` 的代码：

```c
jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");
```

字符串 `D` 表示类型是 `double`。

你可能会认为访问数据域相当令人费解。`JNI` 的设计者不想把数据域直接暴露在外，所以他们不得不提供获取和设置数据域值的函数。为了使这些函数的开销最小化，从域名计算域 `ID`（代价最大的一个步骤）被分解出来作为单独的一步操作。也就是说，如果你反复地获取和设置一个特定域，你计算域标识符的开销就只有一次。

让我们把各部分汇总起来，下面的代码以本地方法形式重新实现了 `raiseSalary` 方法：

```c
JNIEXPORT void JNICALL Java_Employee_raiseSalary(JNIEnv* env, jobject this_obj, jdouble byPercent)
{
    /* get the class */
    jclass class_Employee = (*env)->GetObjectClass(env, this_obj);
    
    /* get the field ID */
    jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");
    
    /* get the field value */
    jdouble salary = (*env)->GetDoubleField(env, this_obj, id_salary);
    
    salary *= 1 + byPercent / 100;
    
    /* set the field value */
    (*env)->SetDoubleField(env, this_obj, id_salary, salary);
}
```

> 警告：类引用只在本地方法返回之前有效。因此，不能在你的代码中缓存 `GetObjectClass` 的返回值。不要将类引用保存下来以供以后的方法调用重复使用。必须在每次执行本地方法时都调用 `GetObjectClass`。如果你无法忍受这一点，必须调用 `NewGlobalRef` 来锁定该引用：
>
> ```c
> static jclass class_X = 0;
> static jfieldID id_a;
> ...
> if (class_X == 0)
> {
>     jclass cx =(*env)->GetObjectClass(env, obj);
>     class_X = (*env)->NewGlobalRef(env, cx);
>     id_a = (*env)->GetFieldID(env, cls, "a", "...");
> }
> ```
>
> 现在，你可以在后面的调用中使用类引用和域 ID 了。当你结束对类的使用时，务必调用：
>
> ```c
> (*env)->DeleteGlobalRef(env, class_X);
> ```

**示例程序：**

**EmployeeTest.java**

```java
package com.qty;

public class EmployeeTest {

    public static void main(String[] args) {
        Employee[] staff = new Employee[3];

        staff[0] = new Employee("Harry Hacker", 35000);
        staff[1] = new Employee("Carl Cracker", 75000);
        staff[2] = new Employee("Tony Tester", 38000);

        for (Employee e : staff) {
            e.raiseSalary(5);
        }
        for (Employee e : staff) {
            e.print();
        }
    }

}
```

**Employee.java**

```java
package com.qty;

public class Employee {

    private String name;
    private double salary;

    public Employee(String n, double s) {
        name = n;
        salary = s;
    }

    public void print() {
        System.out.println(name + " " + salary);
    }

    public native void raiseSalary(double byPercent);

    static {
        System.loadLibrary("libs/Employee");
    }
}
```

**com_qty_Employee.h**

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_qty_Employee */

#ifndef _Included_com_qty_Employee
#define _Included_com_qty_Employee
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_qty_Employee
 * Method:    raiseSalary
 * Signature: (D)V
 */
JNIEXPORT void JNICALL Java_com_qty_Employee_raiseSalary
  (JNIEnv *, jobject, jdouble);

#ifdef __cplusplus
}
#endif
#endif
```

**com_qty_Employee.c**

```c
#include "com_qty_Employee.h"

#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT void JNICALL Java_com_qty_Employee_raiseSalary
(JNIEnv* env, jobject this_obj, jdouble byPercent)
{
    /* get the class */
    jclass class_Employee = (*env)->GetObjectClass(env, this_obj);

    /* get the field ID */
    jfieldID id_salary = (*env)->GetFieldID(env, class_Employee, "salary", "D");

    /* get the field value */
    jdouble salary = (*env)->GetDoubleField(env, this_obj, id_salary);

    salary *= 1 + byPercent / 100;

    /* set the field value */
    (*env)->SetDoubleField(env, this_obj, id_salary, salary);
}

#ifdef __cplusplus
}
#endif
```

运行结果如下：

```shell
"C:\Program Files\Java\jdk-11.0.14\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.3\lib\idea_rt.jar=63359:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2023.3.3\bin" -Dfile.encoding=UTF-8 -classpath C:\WorkSpace\JavaSpace\EmployeeTest\out\production\EmployeeTest com.qty.EmployeeTest
Harry Hacker 36750.0
Carl Cracker 78750.0
Tony Tester 39900.0

Process finished with exit code 0
```

### 2. 访问静态域

访问静态域和访问非静态域类似。你要使用 `GetStaticFieldID` 和 `GetStaticXxxField/SetStaticXxxField` 函数。它们几乎与非静态的情形一样，只有两个区别：

+ 由于没有对象，必须使用 `FindClass` 代替 `GetObjectClass` 来获得类引用。
+ 访问域时，要提供类而非实例对象。

例如，下面给出的是怎样得到 `System.out` 的引用的代码：

```java
/* get the class */
jclass class_System = (*env)->FindClass(env, "java/lang/System");

/* get the field ID */
jfieldID id_out = (*env)->GetStaticFieldID(env, class_System, "out", "Ljava/io/PrintStream;");

/* get the field value */
jobject obj_out = (*env)->GetStaticObjectField(env, class_System, id_out);
```

