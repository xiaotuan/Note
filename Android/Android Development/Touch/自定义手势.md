[toc]

### 1. 创建自定义手势

#### 1.1 将 GestureOverlayView 添加到布局文件中

```xml
<android.gesture.GestureOverlayView
        android:id="@+id/gestures_overlay"
        android:layout_width="match_parent"
        android:layout_height="0dip"
        android:layout_weight="1.0"
        android:gestureStrokeType="multiple" />
```

#### 1.2 实现 GestureOverlayView 监听器

##### 1.2.1 Kotlin

```kotlin
```

##### 1.2.2 Java

```java
private class GesturesProcessor implements GestureOverlayView.OnGestureListener {
    public void onGestureStarted(GestureOverlayView overlay, MotionEvent event) {
        mDoneButton.setEnabled(false);
        mGesture = null;
    }

    public void onGesture(GestureOverlayView overlay, MotionEvent event) {
    }

    public void onGestureEnded(GestureOverlayView overlay, MotionEvent event) {
        mGesture = overlay.getGesture();
        if (mGesture.getLength() < LENGTH_THRESHOLD) {
            overlay.clear(false);
        }
        mDoneButton.setEnabled(true);
    }

    public void onGestureCancelled(GestureOverlayView overlay, MotionEvent event) {
    }
}
```

#### 1.3 将监听器添加的 GestureOverlayView 中

##### 1.3.1 Kotlin

```kotlin
```

##### 1.3.2 Java

```java
GestureOverlayView overlay = (GestureOverlayView) findViewById(R.id.gestures_overlay);
overlay.addOnGestureListener(new GesturesProcessor());
```

#### 1.4 保存在 GestureOverlayView 中绘制的手势

在 `GestureOverlayView` 中绘制手势完成后，会回调监听器的 `onGestureEnded()` 方法。可以在该方法中，通过 `GestureOverlayView.getGesture()` 方法获取绘制的手势对象。可以通过如下方法将手势保存到手势文件中：

##### 1.4.1 Kotlin

```kotlin
```

##### 1.4.2 Java

```java
public void addGesture(View v) {
    if (mGesture != null) {
        final TextView input = (TextView) findViewById(R.id.gesture_name);
        final CharSequence name = input.getText();
        if (name.length() == 0) {
            input.setError(getString(R.string.error_missing_name));
            return;
        }

        final GestureLibrary store = GestureBuilderActivity.getStore();
        store.addGesture(name.toString(), mGesture);
        store.save();

        setResult(RESULT_OK);

        final String path = new File(Environment.getExternalStorageDirectory(),
                                     "gestures").getAbsolutePath();
        Toast.makeText(this, getString(R.string.save_success, path), Toast.LENGTH_LONG).show();
    } else {
        setResult(RESULT_CANCELED);
    }

    finish();
}
```

### 2. 读取自定义手势

因为需要读取文件，所以该操作应该放到线程中进行。可以通过如下代码读取自定义手势：

#### 2.1 Kotlin

```kolin

```

#### 2.2 Java

```java
private class GesturesLoadTask extends AsyncTask<Void, NamedGesture, Integer> {
    private int mThumbnailSize;
    private int mThumbnailInset;
    private int mPathColor;
    
    private static GestureLibrary sStore;

    @Override
    protected void onPreExecute() {
        super.onPreExecute();

        sStore = GestureLibraries.fromFile(mStoreFile);
        final Resources resources = getResources();
        mPathColor = resources.getColor(R.color.gesture_color);
        mThumbnailInset = (int) resources.getDimension(R.dimen.gesture_thumbnail_inset);
        mThumbnailSize = (int) resources.getDimension(R.dimen.gesture_thumbnail_size);

        findViewById(R.id.addButton).setEnabled(false);
        findViewById(R.id.reloadButton).setEnabled(false);

        mAdapter.setNotifyOnChange(false);
        mAdapter.clear();
    }

    @Override
    protected Integer doInBackground(Void... params) {
        if (isCancelled()) return STATUS_CANCELLED;
        if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
            return STATUS_NO_STORAGE;
        }

        final GestureLibrary store = sStore;

        if (store.load()) {
            for (String name : store.getGestureEntries()) {
                if (isCancelled()) break;

                for (Gesture gesture : store.getGestures(name)) {
                    final Bitmap bitmap = gesture.toBitmap(mThumbnailSize, mThumbnailSize,
                                                           mThumbnailInset, mPathColor);
                    final NamedGesture namedGesture = new NamedGesture();
                    namedGesture.gesture = gesture;
                    namedGesture.name = name;

                    mAdapter.addBitmap(namedGesture.gesture.getID(), bitmap);
                    publishProgress(namedGesture);
                }
            }

            return STATUS_SUCCESS;
        }

        return STATUS_NOT_LOADED;
    }

    @Override
    protected void onProgressUpdate(NamedGesture... values) {
        super.onProgressUpdate(values);

        final GesturesAdapter adapter = mAdapter;
        adapter.setNotifyOnChange(false);

        for (NamedGesture gesture : values) {
            adapter.add(gesture);
        }

        adapter.sort(mSorter);
        adapter.notifyDataSetChanged();
    }

    @Override
    protected void onPostExecute(Integer result) {
        super.onPostExecute(result);

        if (result == STATUS_NO_STORAGE) {
            mListView.setVisibility(View.GONE);
            mEmpty.setVisibility(View.VISIBLE);
            mEmpty.setText(getString(R.string.gestures_error_loading,
                                     mStoreFile.getAbsolutePath()));
        } else {
            findViewById(R.id.addButton).setEnabled(true);
            findViewById(R.id.reloadButton).setEnabled(true);
            checkForEmpty();
        }
    }
}

static class NamedGesture {
    String name;
    Gesture gesture;
}
```

### 3. 使用自定义手势

#### 3.1 在布局文件中添加 GestureOverlayView

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.gesture.GestureOverlayView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/gestureOverlay"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".UseGestureActivity" />
```

#### 3.2 加载手势文件

##### 3.2.1 Kotlin

```kotlin
```

##### 3.2.2 Java

```java
// mGestureLib = GestureLibraries.fromRawResource(this, R.raw.gestures);
mGestureLib = GestureLibraries.fromFile(mStoreFile);
```

#### 3.3 实现手势识别监听器

##### 3.3.1 Kotlin

```kotlin
```

##### 3.3.2 Java

```java
@Override
public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) {
    ArrayList<Prediction> predictions = mGestureLib.recognize(gesture);

    if (predictions.size() > 0) {
        Prediction prediction = (Prediction) predictions.get(0);
        if (prediction.score > 1.0) {
            Toast.makeText(this, prediction.name, Toast.LENGTH_SHORT).show();
            for (int i = 0; i < predictions.size(); i++) {
                Log.v(TAG, "prediction " + predictions.get(i).name + " - score = " + predictions.get(i).score);
            }
        }
    }
}
```

#### 3.4 为 GestureOverlayView 添加手势识别监听器

##### 3.4.1 Kotlin

```kotlin
```

##### 3.4.2 Java

```java
GestureOverlayView gestureView = findViewById(R.id.gestureOverlay);
gestureView.addOnGesturePerformedListener(this);
```

### 4. 一个完整示例

#### 4.1 gestures_list.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ListView
        android:id="@android:id/list"
        android:layout_width="match_parent"
        android:layout_height="0dip"
        android:layout_weight="1.0" />

    <TextView
        android:id="@android:id/empty"
        android:layout_width="match_parent"
        android:layout_height="0dip"
        android:layout_weight="1.0"
        android:gravity="center"
        android:text="Loading gestures..."
        android:textAppearance="?android:attr/textAppearanceMedium" />

    <LinearLayout
        style="@android:style/ButtonBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/addButton"
            android:onClick="addGesture"
            android:layout_width="0dip"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:enabled="false"
            android:layout_marginStart="16dp"
            android:layout_marginEnd="16dp"
            android:text="Add gesture" />

        <Button
            android:id="@+id/useButton"
            android:onClick="useGesture"
            android:layout_width="0dip"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:enabled="false"
            android:layout_marginStart="16dp"
            android:layout_marginEnd="16dp"
            android:text="UseGesture" />

        <Button
            android:id="@+id/reloadButton"
            android:onClick="reloadGestures"
            android:layout_width="0dip"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginStart="16dp"
            android:layout_marginEnd="16dp"
            android:enabled="false"
            android:text="Reload" />

    </LinearLayout>

</LinearLayout>
```

#### 4.2 gesture_item.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/text1"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center_vertical"
    android:minHeight="?android:attr/listPreferredItemHeight"
    android:drawablePadding="12dip"
    android:paddingLeft="6dip"
    android:paddingRight="6dip"
    android:ellipsize="marquee"
    android:singleLine="true"
    android:textAppearance="?android:attr/textAppearanceLarge" />
```

#### 4.3 dialog_rename.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="20dip"
    android:orientation="vertical">

    <TextView
        android:id="@+id/label"
        android:layout_height="wrap_content"
        android:layout_width="wrap_content"
        android:text="Gesture name"
        android:gravity="left"
        android:textAppearance="?android:attr/textAppearanceMedium" />

    <EditText
        android:id="@+id/name"
        android:layout_height="wrap_content"
        android:layout_width="match_parent"
        android:scrollHorizontally="true"
        android:autoText="false"
        android:capitalize="none"
        android:gravity="fill_horizontal"
        android:textAppearance="?android:attr/textAppearanceMedium" />

</LinearLayout>
```

#### 4.4 create_gesture.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"

    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
    
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginRight="6dip"
            android:text="Name"
            android:textAppearance="?android:attr/textAppearanceMedium" />
        
        <EditText
            android:id="@+id/gesture_name"
            android:layout_width="0dip"
            android:layout_weight="1.0"
            android:layout_height="wrap_content"
            android:maxLength="40"
            android:singleLine="true" />

    </LinearLayout>
    
    <android.gesture.GestureOverlayView
        android:id="@+id/gestures_overlay"
        android:layout_width="match_parent"
        android:layout_height="0dip"
        android:layout_weight="1.0"
        android:gestureStrokeType="multiple" />

    <LinearLayout
        style="@android:style/ButtonBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/done"
                
            android:layout_width="0dip"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:enabled="false"
            android:onClick="addGesture"
            android:text="Done" />
    
        <Button
            android:layout_width="0dip"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:onClick="cancelGesture"
            android:text="Discard" />
    
    </LinearLayout>
    
</LinearLayout>
```

#### 4.5 activity_use_gesture.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.gesture.GestureOverlayView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/gestureOverlay"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".UseGestureActivity" />
```

#### 4.6 GestureBuilderActivity 类

##### 4.6.1 Kotlin

```kotlin
package com.qty.kotlintest

import android.app.AlertDialog
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.gesture.Gesture
import android.gesture.GestureLibraries
import android.gesture.GestureLibrary
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.os.AsyncTask
import android.os.Bundle
import android.os.Environment
import android.view.*
import android.widget.*
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import java.io.File
import java.util.*
import kotlin.Comparator
import kotlin.collections.HashMap

class GestureBuilderActivity : AppCompatActivity() {

    private val mStoreFile = File(Environment.getExternalStorageDirectory(), "gestures")
    private val mSorter = Comparator<NamedGesture> { o1, o2 -> o1.name.compareTo(o2.name) }

    private lateinit var mAdapter: GestureAdapter
    private lateinit var mLauncher: ActivityResultLauncher<Intent>
    private lateinit var mListView: ListView
    private lateinit var mEmpty: TextView
    private lateinit var mInput: EditText

    private var mTask: GesturesLoadTask? = null
    private var mRenameDialog: Dialog? = null
    private var mCurrentRenameGesture: NamedGesture? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.gestures_list)

        mListView = findViewById(android.R.id.list)
        mEmpty = findViewById(android.R.id.empty)

        mListView.visibility = View.GONE
        mEmpty.visibility = View.VISIBLE

        mAdapter = GestureAdapter(this)
        mListView.adapter = mAdapter

        if (sStore == null) {
            sStore = GestureLibraries.fromFile(mStoreFile)
        }

        loadGestures()

        registerForContextMenu(mListView)

        mLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {
            if (it.resultCode == RESULT_OK) {
                loadGestures()
            }
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)

        mCurrentRenameGesture?.apply {
            outState.putLong(GESTURES_INFO_ID, gesture.id)
        }
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)

        val id = savedInstanceState.getLong(GESTURES_INFO_ID, -1L)
        if (id != -1L) {
            sStore?.let {
                out@ for (name in it.gestureEntries) {
                    for (gesture in it.getGestures(name)) {
                        if (gesture.id == id) {
                            mCurrentRenameGesture = NamedGesture(name, gesture)
                            break@out
                        }
                    }
                }
            }
        }
    }

    override fun onCreateContextMenu(
        menu: ContextMenu?,
        v: View?,
        menuInfo: ContextMenu.ContextMenuInfo?
    ) {
        super.onCreateContextMenu(menu, v, menuInfo)
        val info = menuInfo as AdapterView.AdapterContextMenuInfo
        menu?.setHeaderTitle((info.targetView as TextView).text)

        menu?.add(0, MENU_ID_RENAME, 0, "Rename")
        menu?.add(0, MENU_ID_REMOVE, 0, "Delete")
    }

    override fun onContextItemSelected(item: MenuItem): Boolean {
        val menuInfo = item.menuInfo as AdapterView.AdapterContextMenuInfo
        val gesture = menuInfo.targetView.tag as NamedGesture

        when (item.itemId) {
            MENU_ID_RENAME -> {
                renameGesture(gesture)
                return true
            }
            MENU_ID_REMOVE -> {
                deleteGesture(gesture)
                return true
            }
        }
        return super.onContextItemSelected(item)
    }

    override fun onCreateDialog(id: Int): Dialog {
        if (id == DIALOG_RENAME_GESTURE) {
            return createRenameDialog()
        }
        return super.onCreateDialog(id)
    }

    override fun onPrepareDialog(id: Int, dialog: Dialog?) {
        super.onPrepareDialog(id, dialog)
        if (id == DIALOG_RENAME_GESTURE) {
            mCurrentRenameGesture?.let {
                mInput.setText(it.name)
            }
        }
    }

    override fun onDestroy() {
        if (mTask?.status != AsyncTask.Status.FINISHED) {
            mTask?.cancel(true)
            mTask = null
        }

        cleanupRenameDialog()
        super.onDestroy()
    }

    public fun reloadGestures(v: View) {
        loadGestures()
    }

    public fun addGesture(v: View) {
        mLauncher.launch(Intent(this, CreateGestureActivity::class.java))
    }

    public fun useGesture(v: View) {
        val useActivity = Intent(this, UseGestureActivity::class.java)
        startActivity(useActivity)
    }

    private fun loadGestures() {
        if (mTask?.status != AsyncTask.Status.FINISHED) {
            mTask?.cancel(true)
        }
        mTask = GesturesLoadTask(this).execute() as GesturesLoadTask?
    }

    private fun renameGesture(gesture: NamedGesture) {
        mCurrentRenameGesture = gesture
        showDialog(DIALOG_RENAME_GESTURE)
    }

    private fun createRenameDialog(): Dialog {
        val layout = View.inflate(this, R.layout.dialog_rename, null)
        mInput = layout.findViewById(R.id.name)
        layout.findViewById<TextView>(R.id.label).text = "Gesture name"

        val builder = AlertDialog.Builder(this)
        builder.apply {
            setIcon(0)
            setTitle("Rename gesture")
            setCancelable(true)
            setOnCancelListener { _ -> cleanupRenameDialog() }
            setNegativeButton("Cancel") { _, _ -> cleanupRenameDialog() }
            setPositiveButton("OK") { _, _ -> changeGestureName() }
            setView(layout)
        }
        return builder.create()
    }

    private fun changeGestureName() {
        val name = mInput.text.toString()
        if (name.isNotEmpty()) {
            for ( i in 0 until mAdapter.count) {
                val gesture = mAdapter.getItem(i)
                if (gesture != null) {
                    if (gesture.gesture.id == mCurrentRenameGesture?.gesture?.id) {
                        sStore?.removeGesture(gesture.name, gesture.gesture)
                        gesture.name = name
                        sStore?.addGesture(gesture.name, gesture.gesture)
                        break
                    }
                }
            }
            mAdapter.notifyDataSetChanged()
        }
        mCurrentRenameGesture = null
    }

    private fun checkForEmpty() {
        if (mAdapter.count == 0) {
            mEmpty.text = "No gestures"
            mListView.visibility = View.GONE
            mEmpty.visibility = View.VISIBLE
        } else {
            mListView.visibility = View.VISIBLE
            mEmpty.visibility = View.GONE
        }
    }

    private fun cleanupRenameDialog() {
        mRenameDialog?.dismiss()
        mRenameDialog = null
        mCurrentRenameGesture = null
    }

    private fun deleteGesture(gesture: NamedGesture) {
        sStore?.removeGesture(gesture.name, gesture.gesture)
        sStore?.save()

        mAdapter.setNotifyOnChange(false)
        mAdapter.remove(gesture)
        mAdapter.sort(mSorter)
        checkForEmpty()
        mAdapter.notifyDataSetChanged()

        Toast.makeText(this, "Gesture deleted", Toast.LENGTH_SHORT).show()
    }

    class GesturesLoadTask(
        val activity: GestureBuilderActivity
    ): AsyncTask<Void, NamedGesture, Int>() {

        private var mThumbnailSize = 0
        private var mThumbnailInset = 0
        private var mPathColor = 0

        override fun onPreExecute() {
            super.onPreExecute()

            mPathColor = activity.resources.getColor(R.color.gesture_color)
            mThumbnailInset = activity.resources.getDimension(R.dimen.gesture_thumbhail_inset).toInt()
            mThumbnailSize = activity.resources.getDimension(R.dimen.gesture_thumbhail_size).toInt()

            activity.findViewById<Button>(R.id.addButton).isEnabled = false
            activity.findViewById<Button>(R.id.useButton).isEnabled = false
            activity.findViewById<Button>(R.id.reloadButton).isEnabled = false

            activity.mAdapter.setNotifyOnChange(false)
            activity.mAdapter.clear()
        }

        override fun doInBackground(vararg params: Void?): Int {
            if (isCancelled) return STATUS_CANCELLED
            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
                return STATUS_NO_STORAGE
            }

            if (sStore != null) {
                if (sStore!!.load()) {
                    for (name in sStore!!.gestureEntries) {
                        if (isCancelled) break;

                        for (gesture in sStore!!.getGestures(name)) {
                            val bitmap = gesture.toBitmap(mThumbnailSize, mThumbnailSize, mThumbnailInset, mPathColor)
                            val nameGesture = NamedGesture(name, gesture)

                            activity.mAdapter.addBitmap(nameGesture.gesture.id, bitmap)
                            publishProgress(nameGesture)
                        }
                    }
                    return STATUS_SUCCESS
                }
            }

            return STATUS_NOT_LOADED
        }

        override fun onProgressUpdate(vararg values: NamedGesture?) {
            super.onProgressUpdate(*values)

            activity.mAdapter.setNotifyOnChange(false)

            for (gesture in values) {
                activity.mAdapter.add(gesture)
            }

            activity.mAdapter.sort(activity.mSorter)
            activity.mAdapter.notifyDataSetChanged()
        }

        override fun onPostExecute(result: Int?) {
            super.onPostExecute(result)

            if (result == STATUS_NO_STORAGE) {
                activity.mListView.visibility = View.GONE
                activity.mEmpty.visibility = View.VISIBLE
                activity.mEmpty.text = "Could not load ${activity.mStoreFile.absolutePath}. Make sur..."
            } else {
                activity.findViewById<Button>(R.id.addButton).isEnabled = true
                activity.findViewById<Button>(R.id.useButton).isEnabled = true
                activity.findViewById<Button>(R.id.reloadButton).isEnabled = true
                activity.checkForEmpty()
            }
        }

    }

    class GestureAdapter(context: Context): ArrayAdapter<NamedGesture>(context, 0) {

        private val mInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        private val mThumbnails = Collections.synchronizedMap(HashMap<Long, Drawable>())

        fun addBitmap(id: Long, bitmap: Bitmap) {
            mThumbnails.put(id, BitmapDrawable(bitmap))
        }

        override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
            val view = convertView ?: mInflater.inflate(R.layout.gestures_item, parent, false)

            val gesture = getItem(position)
            val label = view as TextView

            gesture?.let {
                label.tag = it
                label.text = it.name
                label.setCompoundDrawablesWithIntrinsicBounds(mThumbnails.get(gesture.gesture.id), null, null, null)
            }
            return view
        }
    }

    data class NamedGesture(
        var name: String,
        var gesture: Gesture
    )

    companion object {
        const val TAG = "GestureBuilderActivity"
        const val GESTURES_INFO_ID = "gestures.info_id"

        var sStore: GestureLibrary? = null

        const val STATUS_SUCCESS = 0
        const val STATUS_CANCELLED = 1
        const val STATUS_NO_STORAGE = 2
        const val STATUS_NOT_LOADED = 3

        const val MENU_ID_RENAME = 1
        const val MENU_ID_REMOVE = 2

        const val DIALOG_RENAME_GESTURE = 1
    }
}
```

##### 4.6.2 Java

```java
package com.android.androidtest;

import android.app.Dialog;
import android.app.AlertDialog;
import android.app.ListActivity;
import android.os.Bundle;
import android.os.AsyncTask;
import android.os.Environment;
import android.view.View;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import android.gesture.GestureLibrary;
import android.gesture.Gesture;
import android.gesture.GestureLibraries;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.EditText;
import android.widget.AdapterView;
import android.widget.Toast;
import android.widget.ArrayAdapter;
import android.content.DialogInterface;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.text.TextUtils;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.BitmapDrawable;

import androidx.activity.result.ActivityResult;
import androidx.activity.result.ActivityResultCallback;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContract;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;

import java.util.Map;
import java.util.Collections;
import java.util.HashMap;
import java.util.Comparator;
import java.util.Set;
import java.io.File;

public class GestureBuilderActivity extends AppCompatActivity {

    private static final int STATUS_SUCCESS = 0;
    private static final int STATUS_CANCELLED = 1;
    private static final int STATUS_NO_STORAGE = 2;
    private static final int STATUS_NOT_LOADED = 3;

    private static final int MENU_ID_RENAME = 1;
    private static final int MENU_ID_REMOVE = 2;

    private static final int DIALOG_RENAME_GESTURE = 1;

    private static final String GESTURES_INFO_ID = "gestures.info_id";

    private final File mStoreFile = new File(Environment.getExternalStorageDirectory(), "gestures");

    private final Comparator<NamedGesture> mSorter = (object1, object2) -> object1.name.compareTo(object2.name);

    private static GestureLibrary sStore;

    private GesturesAdapter mAdapter;
    private GesturesLoadTask mTask;
    private TextView mEmpty;

    private Dialog mRenameDialog;
    private EditText mInput;
    private ListView mListView;
    private NamedGesture mCurrentRenameGesture;
    private ActivityResultLauncher mLauncher;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.gestures_list);

        mListView = findViewById(android.R.id.list);
        mEmpty = findViewById(android.R.id.empty);

        mListView.setVisibility(View.GONE);
        mEmpty.setVisibility(View.VISIBLE);

        mAdapter = new GesturesAdapter(this);
        mListView.setAdapter(mAdapter);

        if (sStore == null) {
            sStore = GestureLibraries.fromFile(mStoreFile);
        }

        loadGestures();

        registerForContextMenu(mListView);

        mLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {
            if (result.getResultCode() == RESULT_OK) {
                loadGestures();
            }
        });
    }

    static GestureLibrary getStore() {
        return sStore;
    }

    public void reloadGestures(View v) {
        loadGestures();
    }

    public void addGesture(View v) {
        mLauncher.launch(new Intent(this, CreateGestureActivity.class));
    }

    public void useGesture(View v) {
        Intent use = new Intent(this, UseGestureActivity.class);
        startActivity(use);
    }

    private void loadGestures() {
        if (mTask != null && mTask.getStatus() != GesturesLoadTask.Status.FINISHED) {
            mTask.cancel(true);
        }
        mTask = (GesturesLoadTask) new GesturesLoadTask().execute();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        if (mTask != null && mTask.getStatus() != GesturesLoadTask.Status.FINISHED) {
            mTask.cancel(true);
            mTask = null;
        }

        cleanupRenameDialog();
    }

    private void checkForEmpty() {
        if (mAdapter.getCount() == 0) {
            mEmpty.setText(R.string.gestures_empty);
            mListView.setVisibility(View.GONE);
            mEmpty.setVisibility(View.VISIBLE);
        } else {
            mListView.setVisibility(View.VISIBLE);
            mEmpty.setVisibility(View.GONE);
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if (mCurrentRenameGesture != null) {
            outState.putLong(GESTURES_INFO_ID, mCurrentRenameGesture.gesture.getID());
        }
    }

    @Override
    protected void onRestoreInstanceState(Bundle state) {
        super.onRestoreInstanceState(state);

        long id = state.getLong(GESTURES_INFO_ID, -1);
        if (id != -1) {
            final Set<String> entries = sStore.getGestureEntries();
            out:        for (String name : entries) {
                for (Gesture gesture : sStore.getGestures(name)) {
                    if (gesture.getID() == id) {
                        mCurrentRenameGesture = new NamedGesture();
                        mCurrentRenameGesture.name = name;
                        mCurrentRenameGesture.gesture = gesture;
                        break out;
                    }
                }
            }
        }
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
                                    ContextMenu.ContextMenuInfo menuInfo) {

        super.onCreateContextMenu(menu, v, menuInfo);

        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
        menu.setHeaderTitle(((TextView) info.targetView).getText());

        menu.add(0, MENU_ID_RENAME, 0, R.string.gestures_rename);
        menu.add(0, MENU_ID_REMOVE, 0, R.string.gestures_delete);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        final AdapterView.AdapterContextMenuInfo menuInfo = (AdapterView.AdapterContextMenuInfo)
                item.getMenuInfo();
        final NamedGesture gesture = (NamedGesture) menuInfo.targetView.getTag();

        switch (item.getItemId()) {
            case MENU_ID_RENAME:
                renameGesture(gesture);
                return true;
            case MENU_ID_REMOVE:
                deleteGesture(gesture);
                return true;
        }

        return super.onContextItemSelected(item);
    }

    private void renameGesture(NamedGesture gesture) {
        mCurrentRenameGesture = gesture;
        showDialog(DIALOG_RENAME_GESTURE);
    }

    @Override
    protected Dialog onCreateDialog(int id) {
        if (id == DIALOG_RENAME_GESTURE) {
            return createRenameDialog();
        }
        return super.onCreateDialog(id);
    }

    @Override
    protected void onPrepareDialog(int id, Dialog dialog) {
        super.onPrepareDialog(id, dialog);
        if (id == DIALOG_RENAME_GESTURE) {
            mInput.setText(mCurrentRenameGesture.name);
        }
    }

    private Dialog createRenameDialog() {
        final View layout = View.inflate(this, R.layout.dialog_rename, null);
        mInput = (EditText) layout.findViewById(R.id.name);
        ((TextView) layout.findViewById(R.id.label)).setText(R.string.gestures_rename_label);

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(0);
        builder.setTitle(getString(R.string.gestures_rename_title));
        builder.setCancelable(true);
        builder.setOnCancelListener(dialog -> cleanupRenameDialog());
        builder.setNegativeButton(getString(R.string.cancel_action),
                (dialog, which) -> cleanupRenameDialog()
        );
        builder.setPositiveButton(getString(R.string.rename_action),
                (dialog, which) -> changeGestureName()
        );
        builder.setView(layout);
        return builder.create();
    }

    private void changeGestureName() {
        final String name = mInput.getText().toString();
        if (!TextUtils.isEmpty(name)) {
            final NamedGesture renameGesture = mCurrentRenameGesture;
            final GesturesAdapter adapter = mAdapter;
            final int count = adapter.getCount();

            // Simple linear search, there should not be enough items to warrant
            // a more sophisticated search
            for (int i = 0; i < count; i++) {
                final NamedGesture gesture = adapter.getItem(i);
                if (gesture.gesture.getID() == renameGesture.gesture.getID()) {
                    sStore.removeGesture(gesture.name, gesture.gesture);
                    gesture.name = mInput.getText().toString();
                    sStore.addGesture(gesture.name, gesture.gesture);
                    break;
                }
            }

            adapter.notifyDataSetChanged();
        }
        mCurrentRenameGesture = null;
    }

    private void cleanupRenameDialog() {
        if (mRenameDialog != null) {
            mRenameDialog.dismiss();
            mRenameDialog = null;
        }
        mCurrentRenameGesture = null;
    }

    private void deleteGesture(NamedGesture gesture) {
        sStore.removeGesture(gesture.name, gesture.gesture);
        sStore.save();

        final GesturesAdapter adapter = mAdapter;
        adapter.setNotifyOnChange(false);
        adapter.remove(gesture);
        adapter.sort(mSorter);
        checkForEmpty();
        adapter.notifyDataSetChanged();

        Toast.makeText(this, R.string.gestures_delete_success, Toast.LENGTH_SHORT).show();
    }

    private class GesturesLoadTask extends AsyncTask<Void, NamedGesture, Integer> {
        private int mThumbnailSize;
        private int mThumbnailInset;
        private int mPathColor;

        @Override
        protected void onPreExecute() {
            super.onPreExecute();

            final Resources resources = getResources();
            mPathColor = resources.getColor(R.color.gesture_color);
            mThumbnailInset = (int) resources.getDimension(R.dimen.gesture_thumbnail_inset);
            mThumbnailSize = (int) resources.getDimension(R.dimen.gesture_thumbnail_size);

            findViewById(R.id.addButton).setEnabled(false);
            findViewById(R.id.useButton).setEnabled(false);
            findViewById(R.id.reloadButton).setEnabled(false);

            mAdapter.setNotifyOnChange(false);
            mAdapter.clear();
        }

        @Override
        protected Integer doInBackground(Void... params) {
            if (isCancelled()) return STATUS_CANCELLED;
            if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
                return STATUS_NO_STORAGE;
            }

            final GestureLibrary store = sStore;

            if (store.load()) {
                for (String name : store.getGestureEntries()) {
                    if (isCancelled()) break;

                    for (Gesture gesture : store.getGestures(name)) {
                        final Bitmap bitmap = gesture.toBitmap(mThumbnailSize, mThumbnailSize,
                                mThumbnailInset, mPathColor);
                        final NamedGesture namedGesture = new NamedGesture();
                        namedGesture.gesture = gesture;
                        namedGesture.name = name;

                        mAdapter.addBitmap(namedGesture.gesture.getID(), bitmap);
                        publishProgress(namedGesture);
                    }
                }

                return STATUS_SUCCESS;
            }

            return STATUS_NOT_LOADED;
        }

        @Override
        protected void onProgressUpdate(NamedGesture... values) {
            super.onProgressUpdate(values);

            final GesturesAdapter adapter = mAdapter;
            adapter.setNotifyOnChange(false);

            for (NamedGesture gesture : values) {
                adapter.add(gesture);
            }

            adapter.sort(mSorter);
            adapter.notifyDataSetChanged();
        }

        @Override
        protected void onPostExecute(Integer result) {
            super.onPostExecute(result);

            if (result == STATUS_NO_STORAGE) {
                mListView.setVisibility(View.GONE);
                mEmpty.setVisibility(View.VISIBLE);
                mEmpty.setText(getString(R.string.gestures_error_loading,
                        mStoreFile.getAbsolutePath()));
            } else {
                findViewById(R.id.addButton).setEnabled(true);
                findViewById(R.id.useButton).setEnabled(true);
                findViewById(R.id.reloadButton).setEnabled(true);
                checkForEmpty();
            }
        }
    }

    static class NamedGesture {
        String name;
        Gesture gesture;
    }

    private class GesturesAdapter extends ArrayAdapter<NamedGesture> {
        private final LayoutInflater mInflater;
        private final Map<Long, Drawable> mThumbnails = Collections.synchronizedMap(
                new HashMap<Long, Drawable>());

        public GesturesAdapter(Context context) {
            super(context, 0);
            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }

        void addBitmap(Long id, Bitmap bitmap) {
            mThumbnails.put(id, new BitmapDrawable(bitmap));
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            if (convertView == null) {
                convertView = mInflater.inflate(R.layout.gestures_item, parent, false);
            }

            final NamedGesture gesture = getItem(position);
            final TextView label = (TextView) convertView;

            label.setTag(gesture);
            label.setText(gesture.name);
            label.setCompoundDrawablesWithIntrinsicBounds(mThumbnails.get(gesture.gesture.getID()),
                    null, null, null);

            return convertView;
        }
    }
}
```

#### 4.7 CreateGestureActivity 类

##### 4.7.1 Kotlin

```kotlin
package com.qty.kotlintest

import android.gesture.Gesture
import android.gesture.GestureOverlayView
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.os.Environment
import android.view.MotionEvent
import android.view.View
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import java.io.File

class CreateGestureActivity : AppCompatActivity() {

    private lateinit var mDoneButton: Button

    private var mGesture: Gesture? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.create_gesture)

        mDoneButton = findViewById(R.id.done)

        val overlay = findViewById<GestureOverlayView>(R.id.gestures_overlay)
        overlay.addOnGestureListener(GesturesProcessor(this))
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)

        mGesture?.apply {
            outState.putParcelable("gesture", mGesture)
        }
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)

        mGesture = savedInstanceState.getParcelable("gesture")
        mGesture?.apply {
            val overlay = findViewById<GestureOverlayView>(R.id.gestures_overlay)
            overlay.post { overlay.gesture = this }
            mDoneButton.isEnabled = true
        }
    }

    public fun addGesture(v: View) {
        if (mGesture != null) {
            val input = findViewById<TextView>(R.id.gesture_name)
            val name = input.text
            if (name.isBlank()) {
                input.setError("You must enter a name")
                return
            }

            val store = GestureBuilderActivity.sStore
            store?.apply {
                addGesture(name.toString(), mGesture)
                save()
            }

            setResult(RESULT_OK)

            val path = File(Environment.getExternalStorageDirectory(), "gestures").absolutePath
            Toast.makeText(this@CreateGestureActivity, "Gesture saved in $path", Toast.LENGTH_SHORT).show()
        } else {
            setResult(RESULT_CANCELED)
        }
        finish()
    }

    public fun cancelGesture(v: View) {
        setResult(RESULT_CANCELED)
        finish()
    }

    private class GesturesProcessor(val activity: CreateGestureActivity): GestureOverlayView.OnGestureListener {

        override fun onGestureStarted(overlay: GestureOverlayView?, event: MotionEvent?) {
            activity.mDoneButton.isEnabled = false
            activity.mGesture = null
        }

        override fun onGesture(overlay: GestureOverlayView?, event: MotionEvent?) {
        }

        override fun onGestureEnded(overlay: GestureOverlayView?, event: MotionEvent?) {
            activity.mGesture = overlay?.gesture
            activity.mGesture?.apply {
                if (length < LENGTH_THRESHOLD) {
                    overlay?.clear(false)
                }
            }
            activity.mDoneButton.isEnabled = true
        }

        override fun onGestureCancelled(overlay: GestureOverlayView?, event: MotionEvent?) {
        }

    }

    companion object {
        const val TAG = "CreateGestureActivity"

        const val LENGTH_THRESHOLD = 120.0f
    }
}
```

##### 4.7.2 Java

```java
package com.android.androidtest;

import android.os.Bundle;
import android.os.Environment;
import android.view.View;
import android.view.MotionEvent;
import android.gesture.GestureOverlayView;
import android.gesture.Gesture;
import android.gesture.GestureLibrary;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import java.io.File;

public class CreateGestureActivity extends AppCompatActivity {
    private static final float LENGTH_THRESHOLD = 120.0f;

    private Gesture mGesture;
    private View mDoneButton;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        setContentView(R.layout.create_gesture);

        mDoneButton = findViewById(R.id.done);

        GestureOverlayView overlay = (GestureOverlayView) findViewById(R.id.gestures_overlay);
        overlay.addOnGestureListener(new GesturesProcessor());
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        
        if (mGesture != null) {
            outState.putParcelable("gesture", mGesture);
        }
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        
        mGesture = savedInstanceState.getParcelable("gesture");
        if (mGesture != null) {
            final GestureOverlayView overlay =
                    (GestureOverlayView) findViewById(R.id.gestures_overlay);
            overlay.post(() -> overlay.setGesture(mGesture));

            mDoneButton.setEnabled(true);
        }
    }

    public void addGesture(View v) {
        if (mGesture != null) {
            final TextView input = (TextView) findViewById(R.id.gesture_name);
            final CharSequence name = input.getText();
            if (name.length() == 0) {
                input.setError(getString(R.string.error_missing_name));
                return;
            }

            final GestureLibrary store = GestureBuilderActivity.getStore();
            store.addGesture(name.toString(), mGesture);
            store.save();

            setResult(RESULT_OK);

            final String path = new File(Environment.getExternalStorageDirectory(),
                    "gestures").getAbsolutePath();
            Toast.makeText(this, getString(R.string.save_success, path), Toast.LENGTH_LONG).show();
        } else {
            setResult(RESULT_CANCELED);
        }

        finish();
        
    }

    public void cancelGesture(View v) {
        setResult(RESULT_CANCELED);
        finish();
    }
    
    private class GesturesProcessor implements GestureOverlayView.OnGestureListener {
        public void onGestureStarted(GestureOverlayView overlay, MotionEvent event) {
            mDoneButton.setEnabled(false);
            mGesture = null;
        }

        public void onGesture(GestureOverlayView overlay, MotionEvent event) {
        }

        public void onGestureEnded(GestureOverlayView overlay, MotionEvent event) {
            mGesture = overlay.getGesture();
            if (mGesture.getLength() < LENGTH_THRESHOLD) {
                overlay.clear(false);
            }
            mDoneButton.setEnabled(true);
        }

        public void onGestureCancelled(GestureOverlayView overlay, MotionEvent event) {
        }
    }
}
```

#### 4.8 UseGestureActivity 类

##### 4.8.1 Kotlin

```kotlin
package com.qty.kotlintest

import android.gesture.GestureLibraries
import android.gesture.GestureLibrary
import android.gesture.GestureOverlayView
import android.gesture.Prediction
import android.os.Bundle
import android.os.Environment
import android.util.Log
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import java.io.File

class UseGestureActivity : AppCompatActivity() {

    private val mStoreFile = File(Environment.getExternalStorageDirectory(), "gestures")
    private var mGestureLib: GestureLibrary? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_use_gesture)

//        mGestureLib = GestureLibraries.fromRawResource(this, R.raw.gestures)
        mGestureLib = GestureLibraries.fromFile(mStoreFile)

        mGestureLib?.let {
            if (!it.load()) {
                Toast.makeText(this, "Could not load ${mStoreFile.absolutePath}", Toast.LENGTH_SHORT).show()
                finish()
            }

            // Let's take a look at the gesture library we have work with

            // Let's take a look at the gesture library we have work with
            Log.v(TAG, "Library features: ")
            Log.v(TAG, "    Orientation style: ${it.orientationStyle}")
            Log.v(TAG, "    Sequence type: ${it.sequenceType}")
            for (gestureName in it.gestureEntries) {
                Log.v(TAG, "For gesture $gestureName")
                var i = 1
                for (gesture in it.getGestures(gestureName)) {
                    Log.v(TAG, "    $i: ID: ${gesture.id}")
                    Log.v(TAG, "    $i: Strokes count: ${gesture.strokesCount}")
                    Log.v(TAG, "    $i: Stroke length: ${gesture.length}")
                    i += 1
                }
            }
        }

        val gestureView = findViewById<GestureOverlayView>(R.id.gestureOverlay)
        gestureView.addOnGesturePerformedListener { overlay, gesture ->
            val predictions = mGestureLib?.recognize(gesture)

            predictions?.let {
                if (it.size > 0) {
                    val prediction = predictions[0]
                    if (prediction.score > 1.0) {
                        Toast.makeText(this, prediction.name, Toast.LENGTH_SHORT).show()
                        for (predic in predictions) {
                            Log.v(TAG, "prediction ${predic.name} - score = ${predic.score}")
                        }
                    }
                }
            }
        }
    }

    companion object {
        const val TAG = "UseGestureActivity"
    }
}
```

##### 4.8.2 Java

```java
package com.android.androidtest;

import androidx.appcompat.app.AppCompatActivity;

import android.gesture.Gesture;
import android.gesture.GestureLibraries;
import android.gesture.GestureLibrary;
import android.gesture.GestureOverlayView;
import android.gesture.Prediction;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;

public class UseGestureActivity extends AppCompatActivity implements GestureOverlayView.OnGesturePerformedListener {

    private static final String TAG = "UseGestureActivity";

    private final File mStoreFile = new File(Environment.getExternalStorageDirectory(), "gestures");

    private GestureLibrary mGestureLib;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_use_gesture);

//        mGestureLib = GestureLibraries.fromRawResource(this, R.raw.gestures);
        mGestureLib = GestureLibraries.fromFile(mStoreFile);
        if (!mGestureLib.load()) {
            Toast.makeText(this, "Could not load " + mStoreFile.getAbsolutePath(), Toast
            .LENGTH_SHORT).show();
            finish();
        }

        // Let's take a look at the gesture library we have work with
        Log.v(TAG, "Library features: ");
        Log.v(TAG, "    Orientation style: " + mGestureLib.getOrientationStyle());
        Log.v(TAG, "    Sequence type: " + mGestureLib.getSequenceType());
        for (String gestureName : mGestureLib.getGestureEntries()) {
            Log.v(TAG, "For gesture " + gestureName);
            int i = 1;
            for (Gesture gesture : mGestureLib.getGestures(gestureName)) {
                Log.v(TAG, "    " + i + ": ID: " + gesture.getID());
                Log.v(TAG, "    " + i + ": Strokes count: " + gesture.getStrokesCount());
                Log.v(TAG, "    " + i + ": Stroke length: " + gesture.getLength());
                i++;
            }

            GestureOverlayView gestureView = findViewById(R.id.gestureOverlay);
            gestureView.addOnGesturePerformedListener(this);
        }
    }

    @Override
    public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) {
        ArrayList<Prediction> predictions = mGestureLib.recognize(gesture);

        if (predictions.size() > 0) {
            Prediction prediction = (Prediction) predictions.get(0);
            if (prediction.score > 1.0) {
                Toast.makeText(this, prediction.name, Toast.LENGTH_SHORT).show();
                for (int i = 0; i < predictions.size(); i++) {
                    Log.v(TAG, "prediction " + predictions.get(i).name + " - score = " + predictions.get(i).score);
                }
            }
        }
    }
}
```

