### 12.1.2　使用协程的好处

与多线程、多进程等并发模型不同，协程依靠用户空间（user-space）调度，而线程、进程则依靠操作系统内核（kernel）来进行调度。线程、进程间切换都需要从用户态进入内核态，而协程的切换完全是在用户态完成的，而且不像线程进行抢占式调度，协程是非抢占式的调度。

在多线程并发模型中，操作系统会根据某种调度算法不断地切换当前正在运行的线程。每个线程都有自己的栈，因此在切换线程的过程中需要上下文的切换，这样会导致大量的开销。如果系统中有大量的线程，那么系统的资源就会被上下文的切换大量消耗，导致性能的下降。

而协程就是用来解决这个问题的（不仅限于此）。协程运行在同一个线程上，没有上下文的切换。和线程不同，协程有多个入口点，可以在指定的位置挂起和恢复执行，而线程通常只有一个入口点，且只能返回一次。其次，协程不需要多线程的锁机制，因为协程只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不需要加锁，只需要判断状态即可，因此执行效率比多线程高很多。

另外，使用协程后，不再需要像异步编程时那样写很多回调函数，代码结构不再支离破碎，整个代码逻辑看上去和同步代码没有什么区别，代码结构更加优雅简洁。

协程作为一种轻量级的用户态线程，可以用来解决很多实际问题，如Node.js的嵌套回调，Erlang和Golang的并发模型的实现等。对于一些需要长时间运行的操作（如网络I/O、文件I/O、CPU或GPU密集型任务等），使用协程比使用线程更加廉价和可控。

协程通过将复杂性放入库来简化异步编程，程序的逻辑可以在协程中顺序表达，而底层库会为开发者解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行。

