[toc]

`Relay` 特别适用于内核空间有大量数据需要传输到用户空间的情形，目前已经广泛应用在内核调试工具如 SystemTap 中。

### 1. Relay 的 API

#### 1.1 面向用户空间的 API

+ `open()`：允许用户打开一个已经存在的通道缓冲区。
+ `mmap()`：使通道缓冲区被映射到位于用户空间的调用者的地址空间。要特别注意的是，我们不能仅对局部区域进行映射。也就是说，必须映射整个缓冲区文件，其大小是 CPU 的个数和单个 CPU 缓冲区大小的乘积。
+ `read()`：读取通道缓冲区的内容。这些数据一旦被读出，就意味着它们被用户空间的程序消费掉了，不能被之后的读操作看到。
+ `sendfile()`：将数据从通道缓冲区传输到一个输出文件描述符。其中可能的填充字符被自动去掉，不会被用户看到。
+ `poll()`：支持 `POLLIN/POLLRDNORM/POLLERR` 信号。每次子缓冲区的边界被越过时，等待着的用户空间程序会得到通知。
+ `close()`：将通道缓冲区的引用数减 1.当引用数减为 0 时，表明没有进程或者内核用户需要打开它，从而这个通道缓冲区被释放。

#### 1.2 面向内核空间的 API

+ `relay_open()`：创建一个 Relay 通道，包括创建每个 CPU 对应的 Relay 缓冲区。
+ `relay_close()`：关闭一个 Relay 通道，包括释放所有的 Relay 缓冲区，在此之前会调用 `relay_switch()` 来处理这些 Relay 缓冲区以保证已读取但是未满的数据不会丢失。
+ `relay_write()`：将数据写入到当前 CPU 对应的 Relay 缓冲区内。由于它使用了 `local_irqsave()` 保护，因此也可以在中断上下文中使用。
+ `relay_reserve()`：在 Relay 通道中保留一块连续的区域来留给未来的写入操作。通常用于那些希望直接写入到 Relay 缓冲区的用户。考虑到性能或者其他因素，这些用户不希望先把数据写到一个临时缓冲区中，然后再通过 `relay_write()` 进行写入。

