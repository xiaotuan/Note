[toc]

### 1. MTK8168 Android R

#### 1.1 修改系统代码

1.1.1 修改 `vendor/mediatek/proprietary/frameworks/base/services/core/java/com/mediatek/server/MtkAlarmManagerService.java` 文件

将 `resetPoweroffAlarm()` 方法代码：

```java
private void resetPoweroffAlarm(Alarm alarm) {
    String setPackageName = alarm.operation.getTargetPackage();
    long latestTime = alarm.when;

    // Only DeskClock is allowed to set this alarm
    if (mNativeData != 0 && mNativeData != -1) {
        if (setPackageName.equals("com.android.deskclock")) {
            /// M: Extra Logging @{
            if (DEBUG_ALARM_CLOCK) {
                Slog.i(TAG, "mBootPackage = " + setPackageName + " set Prop 2");
            }
            ///@}
            set(mNativeData, PRE_SCHEDULE_POWER_OFF_ALARM,
                latestTime / 1000, (latestTime % 1000) * 1000 * 1000);
            /// M: For Poweroff alarm support for Aging app
        } else if(setPackageName.equals("com.mediatek.sqa8.aging")) {
            Slog.i(TAG, "mBootPackage = " + setPackageName + " set Prop 2");
            set(mNativeData, 7, latestTime / 1000, (latestTime % 1000) * 1000 * 1000);
            ///@}
        } else {
            /// M: Extra Logging @{
            if (DEBUG_ALARM_CLOCK) {
                Slog.w(TAG, "unknown package (" + setPackageName + ") to set power off alarm");
            }
            ///@}
        }
        /// M: Extra Logging @{
        if (DEBUG_ALARM_CLOCK) {
            Slog.i(TAG, "reset power off alarm is " + setPackageName);
        }
        ///@}
    } else {
        /// M: Extra Logging @{
        if (DEBUG_ALARM_CLOCK) {
            Slog.i(TAG, " do not set alarm to RTC when fd close ");
        }
        ///@}
    }
}
```

修改成如下代码：

```java
private void resetPoweroffAlarm(Alarm alarm) {
    String setPackageName = alarm.operation.getTargetPackage();
    long latestTime = alarm.when;

    // Only DeskClock is allowed to set this alarm
    if (mNativeData != 0 && mNativeData != -1) {
        if (setPackageName.equals("com.android.deskclock") || setPackageName.equals("com.weibu.hmxcontroller")) {
            /// M: Extra Logging @{
            if (DEBUG_ALARM_CLOCK) {
                Slog.i(TAG, "mBootPackage = " + setPackageName + " set Prop 2");
            }
            ///@}
            set(mNativeData, PRE_SCHEDULE_POWER_OFF_ALARM,
                latestTime / 1000, (latestTime % 1000) * 1000 * 1000);
            /// M: For Poweroff alarm support for Aging app
        } else if(setPackageName.equals("com.mediatek.sqa8.aging")) {
            Slog.i(TAG, "mBootPackage = " + setPackageName + " set Prop 2");
            set(mNativeData, 7, latestTime / 1000, (latestTime % 1000) * 1000 * 1000);
            ///@}
        } else {
            /// M: Extra Logging @{
            if (DEBUG_ALARM_CLOCK) {
                Slog.w(TAG, "unknown package (" + setPackageName + ") to set power off alarm");
            }
            ///@}
        }
        /// M: Extra Logging @{
        if (DEBUG_ALARM_CLOCK) {
            Slog.i(TAG, "reset power off alarm is " + setPackageName);
        }
        ///@}
    } else {
        /// M: Extra Logging @{
        if (DEBUG_ALARM_CLOCK) {
            Slog.i(TAG, " do not set alarm to RTC when fd close ");
        }
        ///@}
    }
}
```

#### 1.2 添加定时开关机应用支持

1.2.1 创建文件 `HmxController` 文件用于存放开关机应用

1.2.2 创建 `Android.mk` 文件

```makefile
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := optional

LOCAL_SRC_FILES := $(call all-java-files-under, src)

LOCAL_PACKAGE_NAME := HmxController
LOCAL_CERTIFICATE := platform
LOCAL_PRIVILEGED_MODULE := true
LOCAL_DEX_PREOPT := false  
LOCAL_PRIVATE_PLATFORM_APIS = true
#LOCAL_SDK_VERSION := current
include $(BUILD_PACKAGE)
```

1.2.3 创建 `AndroidManifest.xml` 文件

```java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.weibu.hmxcontroller"
    android:sharedUserId="android.uid.system">

    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true">

        <provider android:name="AlarmProvider"
            android:authorities="com.mediatek.schpwronoff" />

        <receiver android:name="SchPwrOnReceiver">
            <intent-filter>
                <action android:name="com.android.settings.schpwronoff.PWR_ON_ALERT" />
            </intent-filter>
        </receiver>

        <receiver android:name="SchPwrOffReceiver">
            <intent-filter>
                <action android:name="com.android.settings.schpwronoff.PWR_OFF_ALERT" />
                <action android:name="android.intent.action.ACTION_SHUTDOWN_IPO" />
                <action android:name="android.intent.action.ACTION_SHUTDOWN" />
            </intent-filter>
        </receiver>

        <service android:name="AlarmReceiverService"/>

        <receiver android:name="AlarmInitReceiver">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.TIME_SET" />
                <action android:name="android.intent.action.TIMEZONE_CHANGED" />
                <action android:name="android.intent.action.LAUNCH_POWEROFF_ALARM" />
            </intent-filter>
        </receiver>

    </application>

</manifest>
```

1.2.4 创建 `Alarm.java` 

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.content.Context;
import android.database.Cursor;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Parcel;
import android.os.Parcelable;
import android.provider.BaseColumns;
import android.util.Log;


import java.text.DateFormatSymbols;
import java.util.Calendar;

public final class Alarm implements Parcelable {
    private static final String TAG = "Settings/Alarm";
    // ////////////////////////////
    // Parcelable apis
    // ////////////////////////////
    public static final Parcelable.Creator<Alarm> CREATOR = new Parcelable.Creator<Alarm>() {
        @Override
        public Alarm createFromParcel(Parcel p) {
            return new Alarm(p);
        }

        @Override
        public Alarm[] newArray(int size) {
            return new Alarm[size];
        }
    };

    /** {@inheritDoc} */
    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel p, int flags) {
        p.writeInt(mId);
        p.writeInt(mEnabled ? 1 : 0);
        p.writeInt(mHour);
        p.writeInt(mMinutes);
        p.writeInt(mDaysOfWeek.getCoded());
        p.writeLong(mTime);
        p.writeInt(mVibrate ? 1 : 0);
        p.writeString(mLabel);
        p.writeParcelable(mAlert, flags);
        p.writeInt(mSilent ? 1 : 0);
    }

    // ////////////////////////////
    // end Parcelable apis
    // ////////////////////////////

    // ////////////////////////////
    // Column definitions
    // ////////////////////////////
    public static class Columns implements BaseColumns {
        /**
         * The content:// style URL for this table
         */
        public static final Uri CONTENT_URI = Uri.parse("content://com.mediatek.schpwronoff/schpwr");

        /**
         * Hour in 24-hour localtime 0 - 23.
         * <P>
         * Type: INTEGER
         * </P>
         */
        public static final String HOUR = "hour";

        /**
         * Minutes in localtime 0 - 59
         * <P>
         * Type: INTEGER
         * </P>
         */
        public static final String MINUTES = "minutes";

        /**
         * Days of week coded as integer
         * <P>
         * Type: INTEGER
         * </P>
         */
        public static final String DAYS_OF_WEEK = "daysofweek";

        /**
         * Alarm time in UTC milliseconds from the epoch.
         * <P>
         * Type: INTEGER
         * </P>
         */
        public static final String ALARM_TIME = "alarmtime";

        /**
         * True if alarm is active
         * <P>
         * Type: BOOLEAN
         * </P>
         */
        public static final String ENABLED = "enabled";

        /**
         * True if alarm should vibrate
         * <P>
         * Type: BOOLEAN
         * </P>
         */
        public static final String VIBRATE = "vibrate";

        /**
         * Message to show when alarm triggers Note: not currently used
         * <P>
         * Type: STRING
         * </P>
         */
        public static final String MESSAGE = "message";

        /**
         * Audio alert to play when alarm triggers
         * <P>
         * Type: STRING
         * </P>
         */
        public static final String ALERT = "alert";

        /**
         * The default sort order for this table
         */
        public static final String DEFAULT_SORT_ORDER = _ID + " ASC";

        // Used when filtering enabled alarms.
        public static final String WHERE_ENABLED = ENABLED + "=1";

        static final String[] ALARM_QUERY_COLUMNS = { _ID, HOUR, MINUTES, DAYS_OF_WEEK, ALARM_TIME, ENABLED, VIBRATE,
                MESSAGE, ALERT };

        /**
         * These save calls to cursor.getColumnIndexOrThrow() THEY MUST BE KEPT IN SYNC WITH ABOVE QUERY COLUMNS
         */
        public static final int ALARM_ID_INDEX = 0;
        public static final int ALARM_HOUR_INDEX = 1;
        public static final int ALARM_MINUTES_INDEX = 2;
        public static final int ALARM_DAYS_OF_WEEK_INDEX = 3;
        public static final int ALARM_TIME_INDEX = 4;
        public static final int ALARM_ENABLED_INDEX = 5;
        public static final int ALARM_VIBRATE_INDEX = 6;
        public static final int ALARM_MESSAGE_INDEX = 7;
        public static final int ALARM_ALERT_INDEX = 8;
    }

    // ////////////////////////////
    // End column definitions
    // ////////////////////////////

    // Public fields
    public int mId;
    public boolean mEnabled;
    public int mHour;
    public int mMinutes;
    public DaysOfWeek mDaysOfWeek;
    public long mTime;
    public boolean mVibrate;
    public String mLabel;
    public Uri mAlert;
    public boolean mSilent;

    /**
     * Alarm object constructor
     * @param c Cursor
     */
    public Alarm(Cursor c) {
        mId = c.getInt(Columns.ALARM_ID_INDEX);
        mEnabled = c.getInt(Columns.ALARM_ENABLED_INDEX) == 1;
        mHour = c.getInt(Columns.ALARM_HOUR_INDEX);
        mMinutes = c.getInt(Columns.ALARM_MINUTES_INDEX);
        mDaysOfWeek = new DaysOfWeek(c.getInt(Columns.ALARM_DAYS_OF_WEEK_INDEX));
        mTime = c.getLong(Columns.ALARM_TIME_INDEX);
        mVibrate = c.getInt(Columns.ALARM_VIBRATE_INDEX) == 1;
        mLabel = c.getString(Columns.ALARM_MESSAGE_INDEX);
        String alertString = c.getString(Columns.ALARM_ALERT_INDEX);
        if (Alarms.ALARM_ALERT_SILENT.equals(alertString)) {
            Log.d("@M_" + TAG, "Alarm is marked as silent");
            mSilent = true;
        } else {
            if (alertString != null && alertString.length() != 0) {
                mAlert = Uri.parse(alertString);
            }

            // If the database alert is null or it failed to parse, use the
            // default alert.
            if (mAlert == null) {
                mAlert = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
            }
        }
    }

    /**
     * contruct alarm object from parcel
     * @param p Parcel
     */
    public Alarm(Parcel p) {
        mId = p.readInt();
        mEnabled = p.readInt() == 1;
        mHour = p.readInt();
        mMinutes = p.readInt();
        mDaysOfWeek = new DaysOfWeek(p.readInt());
        mTime = p.readLong();
        mVibrate = p.readInt() == 1;
        mLabel = p.readString();
        mAlert = (Uri) p.readParcelable(null);
        mSilent = p.readInt() == 1;
    }

    /*
     * Days of week code as a single int. 0x00: no day 0x01: Monday 0x02: Tuesday 0x04: Wednesday 0x08: Thursday 0x10: Friday
     * 0x20: Saturday 0x40: Sunday
     */
    static final class DaysOfWeek {

        private static final int NO_DAY_BIT = 0x00;
        private static final int EVERY_DAY_BIT = 0x7f;
        private static final int WEEK_DAYS = 7;
        private static final int[] DAY_MAP = new int[] { Calendar.MONDAY, Calendar.TUESDAY, Calendar.WEDNESDAY,
                Calendar.THURSDAY, Calendar.FRIDAY, Calendar.SATURDAY, Calendar.SUNDAY, };

        // Bitmask of all repeating days
        private int mDays;

        DaysOfWeek(int days) {
            mDays = days;
        }

        public String toString(Context context, boolean showNever) {
            StringBuilder ret = new StringBuilder();

            // no days
            if (mDays == NO_DAY_BIT) {
                return showNever ? context.getText(R.string.never).toString() : "";
            }

            // every day
            if (mDays == EVERY_DAY_BIT) {
                return context.getText(R.string.every_day).toString();
            }

            // count selected days
            int dayCount = 0;
            int days = mDays;
            while (days > 0) {
                if ((days & 1) == 1) {
                    dayCount++;
                }
                days >>= 1;
            }

            // short or long form?
            DateFormatSymbols dfs = new DateFormatSymbols();
            String[] dayList = (dayCount > 1) ? dfs.getShortWeekdays() : dfs.getWeekdays();

            // selected days
            for (int i = 0; i < WEEK_DAYS; i++) {
                if ((mDays & (1 << i)) != 0) {
                    ret.append(dayList[DAY_MAP[i]]);
                    dayCount -= 1;
                    if (dayCount > 0) {
                        ret.append(context.getText(R.string.day_concat));
                    }
                }
            }
            return ret.toString();
        }

        private boolean isSet(int day) {
            return ((mDays & (1 << day)) > 0);
        }

        public void set(int day, boolean set) {
            if (set) {
                mDays |= (1 << day);
            } else {
                mDays &= ~(1 << day);
            }
        }

        public void set(DaysOfWeek dow) {
            mDays = dow.mDays;
        }

        public void set(int days) {
            mDays = days;
        }
        public int getCoded() {
            return mDays;
        }

        // Returns days of week encoded in an array of booleans.
        public boolean[] getBooleanArray() {
            boolean[] ret = new boolean[WEEK_DAYS];
            for (int i = 0; i < WEEK_DAYS; i++) {
                ret[i] = isSet(i);
            }
            return ret;
        }

        public boolean isRepeatSet() {
            return mDays != 0;
        }

        /**
         * returns number of days from today until next alarm
         *
         * @param c
         *            must be set to today
         */
        public int getNextAlarm(Calendar c) {
            final int days = 5;
            if (mDays == 0) {
                return -1;
            }

            int today = (c.get(Calendar.DAY_OF_WEEK) + days) % WEEK_DAYS;

            int day = 0;
            int dayCount = 0;
            for (; dayCount < WEEK_DAYS; dayCount++) {
                day = (today + dayCount) % WEEK_DAYS;
                if (isSet(day)) {
                    break;
                }
            }
            return dayCount;
        }
    }
}
```

1.2.5 创建 `AlarmProvider.java`

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDiskIOException;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;


public class AlarmProvider extends ContentProvider {
    private static final String TAG = "AlarmProvider";
    private SQLiteOpenHelper mOpenHelper;

    private static final int SCHPWRS = 1;
    private static final int SCHPWRS_ID = 2;
    private static final UriMatcher URLMATCHER = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        URLMATCHER.addURI("com.mediatek.schpwronoff", "schpwr", SCHPWRS);
        URLMATCHER.addURI("com.mediatek.schpwronoff", "schpwr/#", SCHPWRS_ID);
    }

    private static class DatabaseHelper extends SQLiteOpenHelper {
        private static final String DATABASE_NAME = "schpwrs.db";
        private static final int DATABASE_VERSION = 5;

        public DatabaseHelper(Context context) {
            super(context, DATABASE_NAME, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL("CREATE TABLE schpwrs (" + "_id INTEGER PRIMARY KEY," + "hour INTEGER, " + "minutes INTEGER, "
                    + "daysofweek INTEGER, " + "alarmtime INTEGER, " + "enabled INTEGER, " + "vibrate INTEGER, "
                    + "message TEXT, " + "alert TEXT);");

            // insert default alarms
            String insertMe = "INSERT INTO schpwrs "
                    + "(hour, minutes, daysofweek, alarmtime, enabled, vibrate, message, alert) " + "VALUES ";
            db.execSQL(insertMe + "(7, 0, 127, 0, 0, 1, '', '');");
            db.execSQL(insertMe + "(8, 30, 31, 0, 0, 1, '', '');");
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
            Log.d("@M_" + TAG, "Upgrading schpwrs database from version " + oldVersion + " to " + currentVersion
                    + ", which will destroy all old data");
            db.execSQL("DROP TABLE IF EXISTS schpwrs");
            onCreate(db);
        }
    }

    /**
     * dummy constructor
     */
    public AlarmProvider() {
        super();
    }

    @Override
    public boolean onCreate() {
        mOpenHelper = new DatabaseHelper(getContext());
        return true;
    }

    @Override
    public Cursor query(Uri url, String[] projectionIn, String selection, String[] selectionArgs, String sort) {
        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();

        // Generate the body of the query
        int match = URLMATCHER.match(url);
        switch (match) {
            case SCHPWRS:
                qb.setTables("schpwrs");
                break;
            case SCHPWRS_ID:
                qb.setTables("schpwrs");
                qb.appendWhere("_id=");
                qb.appendWhere(url.getPathSegments().get(1));
                break;
            default:
                throw new IllegalArgumentException("Unknown URL " + url);
        }

        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);

        if (ret == null) {
            Log.e("@M_" + TAG, "Alarms.query: failed");
        } else {
            ret.setNotificationUri(getContext().getContentResolver(), url);
        }

        return ret;
    }

    @Override
    public String getType(Uri url) {
        int match = URLMATCHER.match(url);
        switch (match) {
            case SCHPWRS:
                return "vnd.android.cursor.dir/schpwrs";
            case SCHPWRS_ID:
                return "vnd.android.cursor.item/schpwrs";
            default:
                throw new IllegalArgumentException("Unknown URL");
        }
    }

    @Override
    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {
        int count;
        long rowId = 0;
        int match = URLMATCHER.match(url);
        try {
            SQLiteDatabase db = mOpenHelper.getWritableDatabase();
            switch (match) {
                case SCHPWRS_ID:
                    String segment = url.getPathSegments().get(1);
                    rowId = Long.parseLong(segment);
                    count = db.update("schpwrs", values, "_id=" + rowId, null);
                    break;
                default:
                    throw new UnsupportedOperationException("Cannot update URL: " + url);
            }

            Log.d("@M_" + TAG, "*** notifyChange() rowId: " + rowId + " url " + url);
            getContext().getContentResolver().notifyChange(url, null);
            return count;
        } catch (SQLiteDiskIOException e) {
            Log.e("@M_" + TAG, e.toString());
            return 0;
        }
    }

    @Override
    public Uri insert(Uri url, ContentValues initialValues) {
        Log.d("@M_" + TAG, "---------->>> alarm provider");
        if (URLMATCHER.match(url) != SCHPWRS) {
            throw new IllegalArgumentException("Cannot insert into URL: " + url);
        }

        ContentValues values;
        if (initialValues == null) {
            values = new ContentValues();
        } else {
            values = new ContentValues(initialValues);
        }

        if (!values.containsKey(Alarm.Columns.HOUR)) {
            values.put(Alarm.Columns.HOUR, 0);
        }

        if (!values.containsKey(Alarm.Columns.MINUTES)) {
            values.put(Alarm.Columns.MINUTES, 0);
        }

        if (!values.containsKey(Alarm.Columns.DAYS_OF_WEEK)) {
            values.put(Alarm.Columns.DAYS_OF_WEEK, 0);
        }

        if (!values.containsKey(Alarm.Columns.ALARM_TIME)) {
            values.put(Alarm.Columns.ALARM_TIME, 0);
        }

        if (!values.containsKey(Alarm.Columns.ENABLED)) {
            values.put(Alarm.Columns.ENABLED, 0);
        }

        if (!values.containsKey(Alarm.Columns.VIBRATE)) {
            values.put(Alarm.Columns.VIBRATE, 1);
        }

        if (!values.containsKey(Alarm.Columns.MESSAGE)) {
            values.put(Alarm.Columns.MESSAGE, "");
        }

        if (!values.containsKey(Alarm.Columns.ALERT)) {
            values.put(Alarm.Columns.ALERT, "");
        }

        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        long rowId = db.insert("schpwrs", Alarm.Columns.MESSAGE, values);
        if (rowId < 0) {
            throw new SQLException("Failed to insert row into " + url);
        }
        Log.d("@M_" + TAG, "Added alarm rowId = " + rowId);

        Uri newUrl = ContentUris.withAppendedId(Alarm.Columns.CONTENT_URI, rowId);
        getContext().getContentResolver().notifyChange(newUrl, null);
        return newUrl;
    }

    @Override
    public int delete(Uri url, String where, String[] whereArgs) {
        Log.d("@M_" + TAG, "---->> delete alarm provider");
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        int count;
        String whr;
        switch (URLMATCHER.match(url)) {
            case SCHPWRS:
                count = db.delete("schpwrs", where, whereArgs);
                break;
            case SCHPWRS_ID:
                String segment = url.getPathSegments().get(1);
                if (TextUtils.isEmpty(where)) {
                    whr = "_id=" + segment;
                } else {
                    whr = "_id=" + segment + " AND (" + where + ")";
                }
                count = db.delete("schpwrs", whr, whereArgs);
                break;
            default:
                throw new IllegalArgumentException("Cannot delete from URL: " + url);
        }

        getContext().getContentResolver().notifyChange(url, null);
        return count;
    }
}
```

1.2.6 创建 `AlarmInitReceiver.java`

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.UserHandle;
import android.util.Log;


public class AlarmInitReceiver extends BroadcastReceiver {
    private static final String TAG = "AlarmInitReceiver";

    /**
     * Sets alarm on ACTION_BOOT_COMPLETED. Resets alarm on TIME_SET, TIMEZONE_CHANGED
     * @param context Context
     * @param intent Intent
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        Log.d("@M_" + TAG, "AlarmInitReceiver" + action);
        int userId = UserHandle.myUserId();
        Log.d("@M_" + TAG, "userId = " + userId);
        if (userId != UserHandle.USER_OWNER) {
            Log.d("@M_" + TAG, "not owner , return ,don't start AlarmReceiverService");
            return;
        }
        if (context.getContentResolver() == null) {
            Log.e("@M_" + TAG, "AlarmInitReceiver: FAILURE unable to get content resolver.  Alarms inactive.");
            return;
        }
        AlarmReceiverService.processBroadcastIntent(context, intent);
    }
}
```

1.2.7 创建 `AlarmReceiverService.java`

```java
package com.weibu.hmxcontroller;

import android.app.IntentService;
import android.content.Context;
import android.content.Intent;
import android.os.SystemProperties;
import android.os.UserHandle;
import android.util.Log;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class AlarmReceiverService extends IntentService {
    private static final String TAG = "AlarmReceiverService";
    private static final String ACTION_BROADCAST = "broadcast_receiver";
    private static final String SCHPWRS_DB_PATH = "data/data/com.mediatek.schpwronoff/databases/schpwrs.db";
    private static final String TEMP_DB_PATH = "/data/schpwrs.db";

    public AlarmReceiverService() {
        super("AlarmReceiverService");
    }

    public static void processBroadcastIntent(Context context, Intent broadcastIntent) {
        // Launch the Service
        Intent i = new Intent(context, AlarmReceiverService.class);
        i.setAction(ACTION_BROADCAST);
        i.putExtra(Intent.EXTRA_INTENT, broadcastIntent);
        Log.d("@M_" + TAG, "startService");
        context.startService(i);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        int userId = UserHandle.myUserId();
        Log.d("@M_" + TAG, "onHandleIntent, User Id = " + userId);

        final String action = intent.getAction();
        if (!ACTION_BROADCAST.equals(action)) {
            return;
        }

        final Intent broadcastIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
        final String broadcastAction = broadcastIntent.getAction();
        Log.i("@M_" + TAG, "action= " + broadcastAction);
        if (Intent.ACTION_BOOT_COMPLETED.equals(broadcastAction)) {
            // ALPS00448092.
            boolean b = copyDbFileFromDataPath();
            Log.w("@M_" + TAG, "copy db file result " + b);
            Alarms.saveSnoozeAlert(this, -1, -1);
            Alarms.disableExpiredAlarms(this);
            Alarms.setNextAlert(this);
        } else if ("android.intent.action.LAUNCH_POWEROFF_ALARM".equals(broadcastAction)) {
            // @ CL: 2051498
            if (bootFromPoweroffAlarm()) {
                Alarms.setNextAlert(this);
            }
        } else {
            Alarms.setNextAlert(this);
        }
    }

    // get the boot reason
    private boolean bootFromPoweroffAlarm() {
        String bootReason = SystemProperties.get("sys.boot.reason");
        boolean ret = (bootReason != null && bootReason.equals("1")) ? true : false;
        return ret;
    }

    private boolean copyDbFileFromDataPath() {
        Log.w("@M_" + TAG, "copyDbFileFromDataPath");
        File tempDbDirFile = new File(TEMP_DB_PATH);
        if (!tempDbDirFile.exists()) {
            Log.w("@M_" + TAG, "/data/schpwrs.db does not exist");
            return false;
        }
        File dbPathFile = new File("/data/data/com.mediatek.schpwronoff/databases/");
        if (!dbPathFile.exists() || !dbPathFile.isDirectory()) {
            dbPathFile.mkdirs();
        }
        File schPwrsDbFile = new File(SCHPWRS_DB_PATH);
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(tempDbDirFile);
            fos = new FileOutputStream(schPwrsDbFile);
        } catch (FileNotFoundException e) {
            Log.w("@M_" + TAG, "FileNotFoundException " + e.getMessage());
            return false;
        }
        byte[] buffer = new byte[1024];
        int length = 0;
        try {
            while ((length = fis.read(buffer)) > 0) {
                fos.write(buffer, 0, length);
            }
            fos.flush();
            fos.close();
            fis.close();
        } catch (IOException e) {
            Log.w("@M_" + TAG, "IOException " + e.getMessage());
            return false;
        }
        if (!tempDbDirFile.delete()) {
            Log.w("@M_" + TAG, "delete temp db file failed.");
        }
        return true;
    }
}
```

1.2.8 创建 `Alarms.java`

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Parcel;
import android.os.UserHandle;
import android.provider.Settings;
import android.text.format.DateFormat;
import android.util.Log;


import java.util.Calendar;

/**
 * The Alarms provider supplies info about Alarm Clock settings
 */
public class Alarms {
    private static final String TAG = "Settings/Alarms";

    // This string is used to indicate a silent alarm in the db.
    public static final String ALARM_ALERT_SILENT = "silent";
    // This extra is the raw Alarm object data. It is used in the
    // AlarmManagerService to avoid a ClassNotFoundException when filling in
    // the Intent extras.
    public static final String ALARM_RAW_DATA = "intent.extra.alarm_raw";
    // This string is used to identify the alarm id passed to SetAlarm from the
    // list of alarms.
    public static final String ALARM_ID = "alarm_id";

    static final String PREF_SNOOZE_ID = "snooze_id";
    static final String PREF_SNOOZE_TIME = "snooze_time";

    private static final String M12 = "h:mm aa";
    static final String M24 = "kk:mm";

    /**
     * Queries all alarms
     * @param contentResolver ContentResolver
     * @return cursor over all alarms
     */
    public static Cursor getAlarmsCursor(ContentResolver contentResolver) {
        return contentResolver.query(Alarm.Columns.CONTENT_URI, Alarm.Columns.ALARM_QUERY_COLUMNS,
                null, null, Alarm.Columns.DEFAULT_SORT_ORDER);
    }

    // Private method to get a more limited set of alarms from the database.
    private static Cursor getFilteredAlarmsCursor(ContentResolver contentResolver) {
        return contentResolver.query(Alarm.Columns.CONTENT_URI, Alarm.Columns.ALARM_QUERY_COLUMNS,
                Alarm.Columns.WHERE_ENABLED, null, null);
    }

    private static Cursor getFilteredAlarmsCursor(ContentResolver contentResolver, int alarmId) {
        Log.d("@M_" + TAG, "User Id = " + UserHandle.myUserId());
        return contentResolver.query(
                ContentUris.withAppendedId(Alarm.Columns.CONTENT_URI, alarmId),
                Alarm.Columns.ALARM_QUERY_COLUMNS, Alarm.Columns.WHERE_ENABLED, null, null);
    }

    /**
     * Return an Alarm object representing the alarm id in the database.
     * Returns null if no alarm exists.
     * @param contentResolver ContentResolver
     * @param alarmId id
     * @return Alarm object
     */
    public static Alarm getAlarm(ContentResolver contentResolver, int alarmId) {
        Cursor cursor = null;
        Alarm alarm = null;
        try {
            cursor = contentResolver.query(ContentUris.withAppendedId(Alarm.Columns.CONTENT_URI,
                    alarmId), Alarm.Columns.ALARM_QUERY_COLUMNS, null, null, null);
            if (cursor != null) {
                if (cursor.moveToFirst()) {
                    alarm = new Alarm(cursor);
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return alarm;
    }

    /**
     * A convenience method to set an alarm in the Alarms content provider.
     * @param context Context
     * @param id corresponds to the _id column
     * @param enabled corresponds to the ENABLED column
     * @param hour corresponds to the HOUR column
     * @param minutes corresponds to the MINUTES column
     * @param daysOfWeek corresponds to the DAYS_OF_WEEK column
     * @param vibrate corresponds to the VIBRATE column
     * @param message corresponds to the MESSAGE column
     * @param alert corresponds to the ALERT column
     */
    public static void setAlarm(Context context, int id, boolean enabled, int hour, int minutes,
                                Alarm.DaysOfWeek daysOfWeek, boolean vibrate, String message, String alert) {
        final int initSize = 8;
        ContentValues values = new ContentValues(initSize);
        ContentResolver resolver = context.getContentResolver();
        // Set the alarm_time value if this alarm does not repeat. This will be
        // used later to disable expired alarms.
        long time = 0;
        if (!daysOfWeek.isRepeatSet()) {
            time = calculateAlarm(hour, minutes, daysOfWeek).getTimeInMillis();
        }

        Log.d("@M_" + TAG, "**  setAlarm * idx " + id + " hour " + hour + " minutes " + minutes
                + " enabled " + enabled + " time " + time);

        values.put(Alarm.Columns.ENABLED, enabled ? 1 : 0);
        values.put(Alarm.Columns.HOUR, hour);
        values.put(Alarm.Columns.MINUTES, minutes);
        values.put(Alarm.Columns.ALARM_TIME, time);
        values.put(Alarm.Columns.DAYS_OF_WEEK, daysOfWeek.getCoded());
        values.put(Alarm.Columns.VIBRATE, vibrate);
        values.put(Alarm.Columns.MESSAGE, message);
        values.put(Alarm.Columns.ALERT, alert);
        resolver.update(ContentUris.withAppendedId(Alarm.Columns.CONTENT_URI, id), values, null,
                null);

        if (id == 1) {
            // power on
            setNextAlertPowerOn(context);
        } else if (id == 2) {
            // power off
            setNextAlertPowerOff(context);
        }
    }

    /**
     * A convenience method to enable or disable an alarm.
     * @param context Context
     * @param id corresponds to the _id column
     * @param enabled corresponds to the ENABLED column
     */
    public static void enableAlarm(final Context context, final int id, boolean enabled) {
        enableAlarmInternal(context, id, enabled);
        if (id == 1) {
            setNextAlertPowerOn(context);
        } else if (id == 2) {
            setNextAlertPowerOff(context);
        }
    }

    private static void enableAlarmInternal(final Context context, final int id, boolean enabled) {
        Alarm al = getAlarm(context.getContentResolver(), id);
        if (al != null) {
            enableAlarmInternal(context, al, enabled);
        }
    }

    private static void enableAlarmInternal(final Context context, final Alarm alarm,
                                            boolean enabled) {
        ContentResolver resolver = context.getContentResolver();

        ContentValues values = new ContentValues(2);
        values.put(Alarm.Columns.ENABLED, enabled ? 1 : 0);

        // If we are enabling the alarm, calculate alarm time since the time
        // value in Alarm may be old.
        if (enabled) {
            long time = 0;
            if (!alarm.mDaysOfWeek.isRepeatSet()) {
                time = calculateAlarm(alarm.mHour, alarm.mMinutes, alarm.mDaysOfWeek)
                        .getTimeInMillis();
            }
            alarm.mTime = time;
            values.put(Alarm.Columns.ALARM_TIME, time);
        }

        resolver.update(ContentUris.withAppendedId(Alarm.Columns.CONTENT_URI, alarm.mId), values,
                null, null);
    }

    /**
     * calculate Next Alert alarm
     * @param context final Context
     * @param alarmId final int
     * @return Alarm
     */
    public static Alarm calculateNextAlert(final Context context, final int alarmId) {
        Alarm alarm = null;
        Cursor cursor = null;
        long minTime = Long.MAX_VALUE;
        long now = System.currentTimeMillis();
        Log.d("@M_" + TAG, "Alarms.calculateNextAlert()_now = " + now + ", alarmId = " + alarmId);
        try {
            cursor = getFilteredAlarmsCursor(context.getContentResolver(), alarmId);
            if (cursor != null) {
                if (cursor.moveToFirst()) {
                    do {
                        Alarm a = new Alarm(cursor);
                        Log.d("@M_" + TAG, "Alarms.calculateNextAlert()_atime = " + a.mTime);
                        Log.d("@M_" + TAG, "Alarms.calculateNextAlert()_min_time = " + minTime);
                        // A time of 0 indicates this is a repeating alarm, so
                        // calculate the time to get the next alert.
                        if (a.mTime == 0) {
                            a.mTime = calculateAlarm(a.mHour, a.mMinutes, a.mDaysOfWeek)
                                    .getTimeInMillis();
                            Log.d("@M_" + TAG, "Alarms.calculateNextAlert()_calculateAlarm = " + a.mTime);
                        } else if (a.mTime < now) {
                            Log.d("@M_" + TAG, "Alarms.calculateNextAlert()_atime < now");
                            // Expired alarm, disable it and move along.
                            enableAlarmInternal(context, a, false);
                            continue;
                        } else if (a.mEnabled) {
                            enableAlarmInternal(context, a, true);
                        }
                        if (a.mTime < minTime) {
                            minTime = a.mTime;
                            alarm = a;
                        }
                    } while (cursor.moveToNext());
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return alarm;
    }

    /**
     * Disables non-repeating alarms that have passed. Called at boot.
     * @param context Context
     */
    public static void disableExpiredAlarms(final Context context) {
        Cursor cur = null;
        try {
            cur = getFilteredAlarmsCursor(context.getContentResolver());
            long now = System.currentTimeMillis();
            if (cur != null) {
                if (cur.moveToFirst()) {
                    do {
                        Alarm alarm = new Alarm(cur);
                        // A time of 0 means this alarm repeats. If the time is
                        // non-zero, check if the time is before now.
                        if (alarm.mTime != 0 && alarm.mTime < now) {
                            Log.d("@M_" + TAG, "** DISABLE " + alarm.mId + " now " + now + " set "
                                    + alarm.mTime);
                            enableAlarmInternal(context, alarm, false);
                        }
                    } while (cur.moveToNext());
                }
            }
        } finally {
            if (cur != null) {
                cur.close();
            }
        }
    }

    /**
     * Called at system startup, on time/timezone change, and whenever the user changes alarm settings. Activates snooze if
     * set, otherwise loads all alarms, activates next alert.
     * @param context Context
     */
    public static void setNextAlert(final Context context) {
        Alarm alarm;
        alarm = calculateNextAlert(context, 1);
        disableAlertPowerOn(context);
        if (alarm != null) {
            enableAlertPowerOn(context, alarm, alarm.mTime);
        }

        alarm = calculateNextAlert(context, 2);
        disableAlert(context);
        if (alarm != null) {
            enableAlert(context, alarm, alarm.mTime);
        }
    }

    /**
     * set Next Alert Power Off
     * @param context Context
     */
    public static void setNextAlertPowerOff(final Context context) {
        Alarm alarm = calculateNextAlert(context, 2);
        if (alarm == null) {
            disableAlert(context);
        } else {
            enableAlert(context, alarm, alarm.mTime);
        }
    }

    /**
     * Sets alert in AlarmManger and StatusBar. This is what will actually launch the alert when the alarm triggers.
     *
     * @param alarm
     *            Alarm.
     * @param atTimeInMillis
     *            milliseconds since epoch
     */
    private static void enableAlert(Context context, final Alarm alarm, final long atTimeInMillis) {
        if (alarm == null) {
            return;
        }
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        Log.d("@M_" + TAG, "** setAlert id " + alarm.mId + " atTime " + atTimeInMillis);
        Intent intent = new Intent(context, SchPwrOffReceiver.class);
        Parcel out = Parcel.obtain();
        alarm.writeToParcel(out, 0);
        out.setDataPosition(0);
        intent.putExtra(ALARM_RAW_DATA, out.marshall());
        PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        am.setExact(AlarmManager.RTC_WAKEUP, atTimeInMillis, sender);
        Calendar c = Calendar.getInstance();
        c.setTime(new java.util.Date(atTimeInMillis));
        Log.d("@M_" + TAG, "Alarms.enableAlertPowerOff(): setAlert id " + alarm.mId + " atTime "
                + c.getTime());
    }

    private static void disableAlert(Context context) {
        Intent intent = new Intent(context, SchPwrOffReceiver.class);
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        am.cancel(sender);
        Log.d("@M_" + TAG, "Alarms.disableAlertPowerOff(): disableForPowerOff");
    }

    /**
     * Called at system startup, on time/timezone change, and whenever the user changes alarm settings. Activates snooze if
     * set, otherwise loads all alarms, activates next alert.
     * @param context Context
     */
    public static void setNextAlertPowerOn(final Context context) {
        Alarm alarm = calculateNextAlert(context, 1);
        if (alarm == null) {
            disableAlertPowerOn(context);
        } else {
            enableAlertPowerOn(context, alarm, alarm.mTime);
        }
    }

    /**
     * Sets alert in AlarmManger and StatusBar. This is what will actually launch the alert when the alarm triggers.
     *
     * @param alarm
     *            Alarm.
     * @param atTimeInMillis
     *            milliseconds since epoch
     */
    private static void enableAlertPowerOn(Context context, final Alarm alarm,
                                           final long atTimeInMillis) {
        Log.d("@M_" + TAG, "** setAlert id " + alarm.mId + " atTime " + atTimeInMillis);
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        Intent intent = new Intent(context, SchPwrOnReceiver.class);
        Parcel out = Parcel.obtain();
        alarm.writeToParcel(out, 0);
        out.setDataPosition(0);
        intent.putExtra(ALARM_RAW_DATA, out.marshall());
        PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        am.setExact(AlarmManager.PRE_SCHEDULE_POWER_OFF_ALARM, atTimeInMillis, sender);
        Calendar c = Calendar.getInstance();
        c.setTime(new java.util.Date(atTimeInMillis));
        Log.d("@M_" + TAG, "Alarms.enableAlertPowerOn(): setAlert id " + alarm.mId + " atTime "
                + c.getTime());
    }

    private static void disableAlertPowerOn(Context context) {
        Intent intent = new Intent(context, SchPwrOnReceiver.class);
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        PendingIntent sender = PendingIntent.getBroadcast(context, 0, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
        am.setExact(7, 0, sender);
        am.cancelPoweroffAlarm(context.getPackageName());
        Log.d("@M_" + TAG, "Alarms.disableAlertPowerOn(): disableForPowerOn");
    }

    static void saveSnoozeAlert(final Context context, final int id, final long time) {
        Log.d("@M_" + TAG, "Alarms.saveSnoozeAlert(): id " + id);
        SharedPreferences prefs = context.getSharedPreferences(HmxControllerService.PREFERENCES, 0);
        SharedPreferences.Editor ed = prefs.edit();
        if (id == -1) {
            clearSnoozePreference(ed);
        } else {
            ed.putInt(PREF_SNOOZE_ID, id);
            ed.putLong(PREF_SNOOZE_TIME, time);
            ed.commit();
        }
        // Set the next alert after updating the snooze.
        setNextAlert(context);
    }

    // Helper to remove the snooze preference. Do not use clear because that
    // will erase the clock preferences.
    private static void clearSnoozePreference(final SharedPreferences.Editor ed) {
        ed.remove(PREF_SNOOZE_ID);
        ed.remove(PREF_SNOOZE_TIME);
        ed.commit();
    };

    /**
     * Given an alarm in hours and minutes, return a time suitable for setting in AlarmManager.
     *
     * @param hour
     *            Always in 24 hour 0-23
     * @param minute
     *            0-59
     * @param daysOfWeek
     *            0-59
     */
    static Calendar calculateAlarm(int hour, int minute, Alarm.DaysOfWeek daysOfWeek) {

        // start with now
        Calendar c = Calendar.getInstance();
        c.setTimeInMillis(System.currentTimeMillis());

        int nowHour = c.get(Calendar.HOUR_OF_DAY);
        int nowMinute = c.get(Calendar.MINUTE);

        // if alarm is behind current time, advance one day
        if (hour < nowHour || hour == nowHour && minute <= nowMinute) {
            c.add(Calendar.DAY_OF_YEAR, 1);
        }
        c.set(Calendar.HOUR_OF_DAY, hour);
        c.set(Calendar.MINUTE, minute);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);

        int addDays = daysOfWeek.getNextAlarm(c);
        /*
         * Log.v("** TIMES * " + c.getTimeInMillis() + " hour " + hour + " minute " + minute + " dow " +
         * c.get(Calendar.DAY_OF_WEEK) + " from now " + addDays);
         */
        if (addDays > 0) {
            c.add(Calendar.DAY_OF_WEEK, addDays);
        }
        return c;
    }

    static String formatTime(final Context context, int hour, int minute,
                             Alarm.DaysOfWeek daysOfWeek) {
        Calendar c = calculateAlarm(hour, minute, daysOfWeek);
        return formatTime(context, c);
    }

    /* used by AlarmAlert */
    static String formatTime(final Context context, Calendar c) {
        String format = get24HourMode(context) ? M24 : M12;
        return (c == null) ? "" : (String) DateFormat.format(format, c);
    }

    /**
     * @return true if clock is set to 24-hour mode
     */
    static boolean get24HourMode(final Context context) {
        return android.text.format.DateFormat.is24HourFormat(context);
    }
}
```

1.2.9 创建 `SchPwrOffReceiver.java`

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Parcel;
import android.os.SystemProperties;
import android.telephony.TelephonyManager;
import android.util.Log;


import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/**
 * Glue class: connects AlarmAlert IntentReceiver to AlarmAlert activity. Passes
 * through Alarm ID.
 */
public class SchPwrOffReceiver extends BroadcastReceiver {
    private static final String TAG = "SchPwrOffReceiver";
    /**
     * If the alarm is older than STALE_WINDOW seconds, ignore. It is probably
     * the result of a time or timezone change
     */
    private static final int STALE_WINDOW = 60 * 30;
    private static final String SHUTDOWN_IPO = "android.intent.action.ACTION_SHUTDOWN_IPO";
    private static final String ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";
    Context mContext;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.d("@M_" + TAG, "intent action " + String.valueOf(intent.getAction()));
        if (SHUTDOWN_IPO.equals(intent.getAction()) || ACTION_SHUTDOWN.equals(intent.getAction())) {
            return;
        }

        mContext = context;
        Alarm alarm = null;
        // Grab the alarm from the intent. Since the remote AlarmManagerService
        // fills in the Intent to add some extra data, it must unparcel the
        // Alarm object. It throws a ClassNotFoundException when unparcelling.
        // To avoid this, do the marshalling ourselves.
        final byte[] data = intent.getByteArrayExtra(Alarms.ALARM_RAW_DATA);
        if (data != null) {
            Parcel in = Parcel.obtain();
            in.unmarshall(data, 0, data.length);
            in.setDataPosition(0);
            alarm = Alarm.CREATOR.createFromParcel(in);
        }

        if (alarm == null) {
            Log.d("@M_" + TAG, "SchPwrOffReceiver failed to parse the alarm from the intent");
            return;
        }

        final int millisInSeconds = 1000;
        // Intentionally verbose: always log the alarm time to provide useful
        // information in bug reports.
        long now = System.currentTimeMillis();
        SimpleDateFormat format = new SimpleDateFormat("HH:mm:ss.SSS aaa", Locale.US);
        Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive() id " + alarm.mId + " setFor " + format.format(new Date(alarm.mTime)));

        if (now > alarm.mTime + STALE_WINDOW * millisInSeconds) {
            Log.d("@M_" + TAG, "SchPwrOffReceiver ignoring stale alarm");
            Log.d("@M_" + TAG, "now = " + now);
            Log.d("@M_" + TAG, "stale time = " + (alarm.mTime + STALE_WINDOW * millisInSeconds));
            return;
        }

        // Maintain a cpu wake lock until the AlarmAlert and AlarmKlaxon can
        // pick it up.
        // AlarmAlertWakeLock.acquireCpuWakeLock(context);

        /* Close dialogs and window shade */
        Intent closeDialogs = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
        context.sendBroadcast(closeDialogs);
        final int schduleTimeOff = 900;
        // Decide which activity to start based on the state of the keyguard.

        if (alarm.mId == 1) {
            Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive() id " + alarm.mId + " get power on time out ");
        } else if (alarm.mId == 2) {
            boolean isInCall = false;
            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            isInCall = telephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE;
            Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive() id " + alarm.mId + " in call " + isInCall);

            // Disable this alarm if it does not repeat.
            if (alarm.mDaysOfWeek.isRepeatSet()) {
                // Enable the next alert if there is one. The above call to
                // enableAlarm will call setNextAlert so avoid calling it twice.
                Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive(): not isRepeatSet()");
                Alarms.setNextAlertPowerOff(context);
            } else {
                Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive(): isRepeatSet() ");
                Alarms.enableAlarm(context, alarm.mId, false);
            }

            if (isInCall || isAlarmBoot()) {
                Log.d("@M_" + TAG, "SchPwrOffReceiver.onReceive() id " + alarm.mId + " isAlarmboot= " + isAlarmBoot());
            } else {
                fireShutDown(context);
            }
        }
    }

    /**
     * check if is alarm boot; if it alarm boot, we don't fire the
     * shutdownactivity pop dialog.
     *
     * @return boolean true or false
     */
    private static boolean isAlarmBoot() {
        String bootReason = SystemProperties.get("sys.boot.reason");
        boolean ret = (bootReason != null && bootReason.equals("1")) ? true : false;
        return ret;
    }

    private void fireShutDown(Context context) {
        Intent intent = new Intent(Intent.ACTION_REQUEST_SHUTDOWN);
        intent.putExtra(Intent.EXTRA_KEY_CONFIRM, false);
        intent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(intent);
    }
}
```

1.2.10 创建 `SchPwrOnReceiver.java`

```java
/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */

package com.weibu.hmxcontroller;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Parcel;
import android.util.Log;


import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
/**
 * Glue class: connects AlarmAlert IntentReceiver to AlarmAlert activity.
 * Passes through Alarm ID.
 */
public class SchPwrOnReceiver extends BroadcastReceiver {
    private static final String TAG = "SchPwrOnReceiver";
    /**
     * If the alarm is older than STALE_WINDOW seconds, ignore.
     * It is probably the result of a time or timezone change
     */
    private static final int STALE_WINDOW = 60 * 30;

    @Override
    public void onReceive(Context context, Intent intent) {
        Alarm alarm = null;
        // Grab the alarm from the intent. Since the remote AlarmManagerService
        // fills in the Intent to add some extra data, it must unparcel the
        // Alarm object. It throws a ClassNotFoundException when unparcelling.
        // To avoid this, do the marshalling ourselves.
        final byte[] data = intent.getByteArrayExtra(Alarms.ALARM_RAW_DATA);
        if (data != null) {
            Parcel in = Parcel.obtain();
            in.unmarshall(data, 0, data.length);
            in.setDataPosition(0);
            alarm = Alarm.CREATOR.createFromParcel(in);
        }

        if (alarm == null) {
            Log.d("@M_" + TAG, "SchPwrOnReceiver failed to parse the alarm from the intent");
            return;
        }
        final int stateWindowTimeoff = 1000;
        // Intentionally verbose: always log the alarm time to provide useful
        // information in bug reports.
        long now = System.currentTimeMillis();
        SimpleDateFormat format = new SimpleDateFormat("HH:mm:ss.SSS aaa", Locale.US);
        Log.d("@M_" + TAG, "SchPwrOnReceiver.onReceive() id " + alarm.mId + " setFor "
                + format.format(new Date(alarm.mTime)));

        if (now > alarm.mTime + STALE_WINDOW * stateWindowTimeoff) {
            Log.d("@M_" + TAG, "SchPwrOnReceiver ignoring stale alarm");
            return;
        }

        // Maintain a cpu wake lock until the AlarmAlert and AlarmKlaxon can
        // pick it up.
        // AlarmAlertWakeLock.acquireCpuWakeLock(context);

        /* Close dialogs and window shade */
        // Intent closeDialogs = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
        // context.sendBroadcast(closeDialogs);

        Log.d("@M_" + TAG, "SchPwrOnReceiver.onReceive() id " + alarm.mId + " time out ");
        // Decide which activity to start based on the state of the keyguard.
        if (alarm.mId == 1) {
            if (alarm.mDaysOfWeek.isRepeatSet()) {
                // Enable the next alert if there is one. The above call to
                // enableAlarm will call setNextAlert so avoid calling it twice.
                Log.d("@M_" + TAG, "SchPwrOnReceiver.onReceive(): isRepeatSet()");
                Alarms.setNextAlertPowerOn(context);
            } else {
                Log.d("@M_" + TAG, "SchPwrOnReceiver.onReceive(): not isRepeatSet()");
                Alarms.enableAlarm(context, alarm.mId, false);
            }
        } else if (alarm.mId == 2) {
            Log.d("@M_" + TAG, "SchPwrOnReceiver.onReceive() id " + alarm.mId + " get power off time out ");
        }
    }
}
```

#### 1.4 定时开关机的使用

1.4.1 设置定时开机

```java
Alarms.setAlarm(this, 1, enable, hours, minutes, getDayOfWeek(repeat), false, "", "");
```

1.4.2 设置定时关机

```java
Alarms.setAlarm(this, 2, enable, hours, minutes, getDayOfWeek(repeat), false, "", "");
```

1.4.3 `getDayOfWeek()` 方法代码如下：

```java
private Alarm.DaysOfWeek getDayOfWeek(String repeat) {
    Alarm.DaysOfWeek daysOfWeek = new Alarm.DaysOfWeek(0);
    String[] repeats = repeat.split(",");
    for (int i = 0; i < repeats.length; i++) {
        switch (repeats[i]) {
            case "一":
                daysOfWeek.set(0, true);
                break;

            case "二":
                daysOfWeek.set(1, true);
                break;

            case "三":
                daysOfWeek.set(2, true);
                break;

            case "四":
                daysOfWeek.set(3, true);
                break;

            case "五":
                daysOfWeek.set(4, true);
                break;

            case "六":
                daysOfWeek.set(5, true);
                break;

            case "日":
                daysOfWeek.set(6, true);
                break;

            default:
                Log.e(TAG, "getDayOfWeek=>Unknow repeat: " + repeats[i]);
                break;
        }
    }
    Log.d(TAG, "getDayOfWeek=>dayOfWeek: " + daysOfWeek.getCoded());
    return daysOfWeek;
}
```

