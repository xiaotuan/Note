<center>
  <font size="5">
  	<b>显示转换</b>
  </font>
</center>

由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：

```kotlin
// 假想的代码，实际上并不能编译：
val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)
val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)
print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long
```

因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。

```kotlin
fun main() {
	//sampleStart
	val b: Byte = 1 // OK, 字面值是静态检测的
	val i: Int = b // 错误
	//sampleEnd
}
```

我们可以显式转换来拓宽数字

```kotlin
fun main() {
	val b: Byte = 1
	//sampleStart
	val i: Int = b.toInt() // OK：显式拓宽
	print(i)
	//sampleEnd
}
```

每个数字类型支持如下的转换:

+ toByte(): Byte
+ toShort(): Short
+ toInt(): Int
+ toLong(): Long
+ toFloat(): Float
+ toDouble(): Double
+ toChar(): Char

缺乏隐式类型转换很少会引起注意，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：

```kotlin
val l = 1L + 3 // Long + Int => Long
```

