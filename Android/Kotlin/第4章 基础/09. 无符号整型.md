<center>
  <font size="5">
  	<b>无符号整型</b>
  </font>
</center>

[toc]

> 无符号类型自 Kotlin 1.3 起才可用，并且目前是实验性的。详见下文 {:.note}

Kotlin 为无符号整数引入了以下类型：

+ kotlin.UByte : 无符号 8 比特整数，范围是 0 到 255
+ kotlin.UShort : 无符号 16 比特整数，范围是 0 到 65535
+ kotlin.UInt : 无符号 32 比特整数，范围是 0 到 2<sup>32</sup> - 1
+ kotlin.ULong : 无符号 64 比特整数，范围是 0 到 2<sup>64</sup> - 1

无符号类型支持其对应有符号类型的大多数操作。

> 请注意，将类型从无符号类型更改为对应的有符号类型（ 反之亦然） 是二进制不兼容变更 {:.note}

无符号类型是使用另一个实验性特性（ 即内联类） 实现的。

####1. 特化的类

与原生类型相同，每个无符号类型都有相应的为该类型特化的表示数组的类型：

+ kotlin.UByteArray : 无符号字节数组
+ kotlin.UShortArray : 无符号短整型数组
+ kotlin.UIntArray : 无符号整型数组
+ kotlin.ULongArray : 无符号长整型数组

与有符号整型数组一样，它们提供了类似于 Array 类的 API 而没有装箱开销。

此外，区间与数列也支持 UInt 与 ULong （ 通过这些类 kotlin.ranges.UIntRange 、kotlin.ranges.UIntProgression 、 kotlin.ranges.ULongRange 、 kotlin.ranges.ULongProgression ）

#### 2. 字面值

为使无符号整型更易于使用，Kotlin 提供了用后缀标记整型字面值来表示指定无符号类型（ 类似于 Float/Long） ：

+ 后缀 u 与 U 将字面值标记为无符号。确切类型会根据预期类型确定。如果没有提供预期的类型，会根据字面值大小选择 UInt 或者 ULong

```kotlin
val b: UByte = 1u // UByte，已提供预期类型
val s: UShort = 1u // UShort，已提供预期类型
val l: ULong = 1u // ULong，已提供预期类型
val a1 = 42u // UInt：未提供预期类型，常量适于 UInt
val a2 = 0xFFFF_FFFF_FFFFu // ULong：未提供预期类型，常量不适于 UInt
```

+ 后缀 uL 与 UL 显式将字面值标记为无符号长整型。

```kotlin
val a = 1UL // ULong，即使未提供预期类型并且常量适于 UInt
```

#### 3. 无符号整型的实验性状态

无符号类型的设计是实验性的，这意味着这个特性改进很快并且没有给出兼容性保证。当在 Kotlin 1.3+ 中使用无符号算术时，会报出警告表明这个特性是实验性的。如需移除警告，必须选择加入（ opt-in） 无符号类型的实验性使用。

选择加入无符号整型有两种可行的方式：将 API 标记为实验性的，或者无需标记。

+ 如需传播实验性，请以 @ExperimentalUnsignedTypes 标注使用了无符号整型的声明。
+ 如需选择加入而不传播实验性，要么使用 @OptIn(ExperimentalUnsignedTypes::class) 注解标注声明，要么将 -Xopt-in=kotlin.ExperimentalUnsignedTypes 传给编译器。