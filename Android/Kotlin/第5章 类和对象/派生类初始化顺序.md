在构造派⽣类的新实例的过程中，第⼀步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发⽣在派⽣类的初始化逻辑运⾏之前。

```kotlin
open class Base(val name: String) {
    init { println("Initializing Base") }

    open val size: Int = name.length.also { println("Initializing size in Base: $it") }
} 

class Derived(
name: String,
val lastName: String
) : Base(name.capitalize().also { println("Argument for Base: $it") }) {
    init { println("Initializing Derived") }

    override val size: Int = (super.size + lastName.length).also {                println("Initializing size in Derived: $it")
    }
}

/*
Initializing Base
Initializing size in Base: 7
Initializing Derived
Initializing size in Derived: 15
*/
```

> 设计⼀个基类时，应该避免在构造函数、属性初始化器以及 init 块中使⽤ open成员。
