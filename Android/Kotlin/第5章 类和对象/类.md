定义类的语法：

```kotlin
class Invoice { /*...*/ }
```

如果一个类没有类体，可以省略花括号。

```kotlin
class Empty
```

主构造函数的语法如下：

```kotlin
class Person constructor(firstName: String) { /*...*/ }
```

如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 `constructor` 关键字：

```kotlin
class Person(firstName: String) { /*...*/ }
```

主构造函数不能包含任何代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块中。在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：

```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    var secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
```

主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：

```kotlin
class Customer(name: String) {
    val customerKey = name.toUppercase()
}
```

事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：

```kotlin
class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }
```

与普通属性⼀样，主构造函数中声明的属性可以是可变的（var）或只读的（val）

如果构造函数有注解或可⻅性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前
⾯：

```kotlin
class Customer public @Inject constructor(name: String) { /*……*/ }
```

类也可以声明前缀有 constructor的次构造函数：

```kotlin
class Person {
    var children: MutableList<Person> = mutableListOf<Person>();
    
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
```

如果类有⼀个主构造函数，每个次构造函数需要委托给主构造函数，可以直接委托或者通过别的次构造函数间接委托。委托到同⼀个类的另⼀个构造函数⽤ this 关键字即可：

```kotlin
class Person(val name: String) {
    var children: MutableList<Person> = mutableListOf<Person>();
    
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
```

请注意，初始化块中的代码实际上会成为主构造函数的⼀部分。委托给主构造函数会作为次构造函数的第⼀条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执⾏。即使该类没有主构造函数，这种委托仍会隐式发⽣，并且仍会执⾏初始化块：

```kotlin
class Constructors {
    init {
        println("Init block")
    }
    
    constructor(i: Int) {
        println("Constructor")
    }
}
```

如果⼀个⾮抽象类没有声明任何（主或次）构造函数，它会有⼀个⽣成的不带参数的主构造函数。构造函数的可⻅性是 public。如果你不希望你的类有⼀个公有构造函数，你需要声明⼀个带有⾮默认可⻅性的空的主构造函数：

```kotlin
class DontCreateMe private constructor () { /*……*/ }
```

> 注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会⽣成 ⼀个额外的⽆参构造函数，它将使⽤默认值。
> ```kotlin
> class Customer(val customerName: String = "")
> ```