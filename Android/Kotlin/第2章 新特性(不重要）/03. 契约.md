<center><font size="5"><b>契约</b></font></center>

Kotlin 编译器会做大量的静态分析工作，以提供警告并减少模版代码。其中最显著的特性之一就是智能转换——能够根据类型检测自动转换类型。

```kotlin
fun foo(s: String?) {
	if (s != null) s.length // 编译器自动将“s”转换为“String”
}
```

然而，一旦将这些检测提取到单独的函数中，所有智能转换都立即消失了：

```kotlin
fun String?.isNotNull(): Boolean = this != null

fun foo(s: String?) {
	if (s.isNotNull()) s.length // 没有智能转换 :(
}
```

为了改善在此类场景中的行为，Kotlin 1.3 引入了称为 契约 的实验性机制。

契约 让一个函数能够以编译器理解的方式显式描述其行为。目前支持两大类场景：

+ 通过声明函数调用的结果与所传参数值之间的关系来改进智能转换分析：

```kotlin
fun require(condition: Boolean) {
    // 这是一种语法格式，告诉编译器：
    // “如果这个函数成功返回，那么传入的‘condition’为 true”
    contract { returns() implies condition }
    if (!condition) throw IllegalArgumentException(...)
} 

fun foo(s: String?) {
    require(s is String)
    // s 在这里智能转换为“String”，因为否则
    // “require”会抛出异常
}
```
+ 在存在高阶函数的情况下改进变量初始化的分析：

```kotlin
fun synchronize(lock: Any?, block: () -> Unit) {
    // 告诉编译器：
    // “这个函数会在此时此处调用‘block’，并且刚好只调用一次”
    contract { callsInPlace(block, EXACTLY_ONCE) }
} 

fun foo() {
    val x: Int
    synchronize(lock) {
        x = 42 // 编译器知道传给“synchronize”的 lambda 表达式刚好
        // 只调了一次，因此不会报重复赋值错
    } 
    println(x) // 编译器知道一定会调用该 lambda 表达式而执行
    // 初始化操作，因此可以认为“x”在这里已初始化
}
```

**标准库中的契约**

stdlib （ kotlin 标准库） 已经利用契约带来了如上所述的对代码分析的改进。这部分契约是稳定版的，这意味着你现在就可以从改进的代码分析中受益，而无需任何额外的 opt-ins：

```kotlin
//sampleStart
fun bar(x: String?) {
    if (!x.isNullOrEmpty()) {
    		println("length of '$x' is ${x.length}") // 哇，已经智能转换为非空！
    }
} 

//sampleEnd
fun main() {
    bar(null)
    bar("42")
}
```

**自定义契约**

可以为自己的函数声明契约，不过这个特性是实验性的，因为目前的语法尚处于早期原型状态，并且很可能还会更改。另外还要注意，目前 Kotlin 编译器并不会验证契约，因此程序员有责任编写正确合理的契约。

通过调用标准库（ stdlib） 函数 contract 来引入自定义契约，该函数提供了 DSL 作用域：

```kotlin
fun String?.isNullOrEmpty(): Boolean {
    contract {
    		returns(false) implies (this@isNullOrEmpty != null)
    } 
  	return this == null || isEmpty()
}
```

