<center><font size="5"><b>智能类型转换改进</b></font></center>

当一个变量有安全调用表达式与空检测赋值时，其智能转换现在也可以应用于安全调用接收者：

```kotlin
fun countFirst(s: Any): Int {
	//sampleStart
	val firstChar = (s as? CharSequence)?.firstOrNull()
	if (firstChar != null)
		return s.count { it == firstChar } // s: Any 会智能转换为 CharSequence
	val firstItem = (s as? Iterable<*>)?.firstOrNull()
	if (firstItem != null)
		return s.count { it == firstItem } // s: Any 会智能转换为 Iterable<*>
	//sampleEnd
	return -1
}

fun main(args: Array<String>) {
	val string = "abacaba"
	val countInString = countFirst(string)
	println("called on \"$string\": $countInString")
	val list = listOf(1, 2, 3, 1, 2)
	val countInList = countFirst(list)
	println("called on $list: $countInList")
}
```

运行结果：

```
called on "abacaba": 4
called on [1, 2, 3, 1, 2]: 2
```

智能转换现在也允许用于在 lambda 表达式中局部变量，只要这些局部变量仅在 lambda 表达式之前修改即可：

```kotlin
fun main(args: Array<String>) {
	//sampleStart
	val flag = args.size == 0
	var x: String? = null
	if (flag) x = "Yahoo!"
	run {
		if (x != null) {
			println(x.length) // x 会智能转换为 String
		}
	}
	//sampleEnd
}
```

运行结果：

```
6
```

