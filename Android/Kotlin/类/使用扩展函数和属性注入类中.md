[toc]

Kotlin  允许你将方法和属性注入任何类中，包括用其他 JVM 语言编写的类。与其他提供元编程的语言不同，Kotlin 在执行注入时不需要修补运行时或类加载。在 Kotlin 中，类对扩展是开放的，尽管它们可能无法用于继承。扩展函数和和扩展属性是添加方法和属性的技术，但不改变目标类的字节码。如果某个方法已经存在于类中，则不要为该方法创建扩展函数。如果存在冲突，类的成员总是会胜过扩展函数。当 `Kotlin` 编译器看到一个方法调用时，它检查实例方法是否可用，如果找到了就使用它。如果没有找到实例方法，Kotlin 将会为目标类寻找扩展函数。

你可以将方法和属性注入现有的类中，包括 final 类，甚至那些你没有编写的类。

### 1. 使用扩展函数注入方法

假设有 `Point` 和 `Circle` 两个类，定义如下：

```kotlin
data class Point(val x: Int, val y: Int)
data class Circle(val cx: Int, val cy: Int, val radius: Int)
```

假设我们想知道一个点是否位于圆内。我们可以从外部将方法添加到这些类中。让我们将一个名为 `contains()` 的扩展函数注入 `Circle` 类中，如下所示：

```kotlin
fun Circle.contains(point: Point) = (point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) < radius * radius
```

只要这个方法是可见的 —— 也就是说，它要么是在同一个文件中，要么是从它所在的包中导入的——我们就可以使用它，如下所示：

```kotlin
data class Point(val x: Int, val y: Int)

data class Circle(val cx: Int, val cy: Int, val radius: Int)

fun Circle.contains(point: Point) =
	(point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) < radius * radius

fun main() {
	val circle = Circle(100, 100, 25)
	val point1 = Point(110, 110)
	val point2 = Point(10, 100)
	
	println(circle.contains(point1))	// true
	println(circle.contains(point2))	// false
}
```

当 Kotlin 看到扩展函数时，它在扩展函数所在的包中创建一个静态方法，并将 `context` 对象（本例中的 Circle）作为第一个参数传递给函数，而实际的参数作为其余的参数传递。简而言之，当涉及扩展函数时，方法调用实际上是对静态方法的调用。

扩展函数有一些限制。当扩展函数和同名的实例方法之间发生冲突时，实例方法总是获胜。实例方法可以到达实例的封装边界，与其不同的是，扩展函数只能从定义它们的包内访问可见对象的一部分。

### 2. 使用扩展函数注入运算符

扩展函数也可以是一个运算符。`in` 是一个运算，它映射到 `contains()` 方法。可以这样做：

```kotlin
data class Point(val x: Int, val y: Int)

data class Circle(val cx: Int, val cy: Int, val radius: Int)

operator fun Circle.contains(point: Point) =
	(point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) < radius * radius

fun main() {
	val circle = Circle(100, 100, 25)
	val point1 = Point(110, 110)
	val point2 = Point(10, 100)
	
	println(point1 in circle)	// true
	println(point2 in circle)	// false
}
```

### 3. 使用扩展属性注入属性

因为扩展属性不是类内部的一部分，所以扩展属性不能使用幕后字段——也就是说，它们不能像实际属性那样访问字段。它们可以使用类上的其他属性或方法来完成工作。让我们给 `Circle` 类添加一个 `area` 属性：

```kotlin
val Circle.area: Double
	get() = kotlin.math.PI * radius * radius
```

我们可以像使用实际属性一样使用扩展属性：

```kotlin
data class Point(val x: Int, val y: Int)

data class Circle(val cx: Int, val cy: Int, val radius: Int)

val Circle.area: Double
	get() = kotlin.math.PI * radius * radius

operator fun Circle.contains(point: Point) =
	(point.x - cx) * (point.x - cx) + (point.y - cy) * (point.y - cy) < radius * radius

fun main() {
	val circle = Circle(100, 100, 25)
	println("Area is ${circle.area}")	// Area is 1963.4954084936207
}
```

我们也可以为 `var` 扩展属性编写 `setter`。`setter` 必须依赖类的其他方法来实现其目标，就像扩展属性的 `getter` 一样，扩展属性的 `setter` 不能使用幕后字段。