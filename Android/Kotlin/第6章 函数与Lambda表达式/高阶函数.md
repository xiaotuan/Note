⾼阶函数是将函数⽤作参数或返回值的函数。

```kotlin
fun <T, R> Collection<T>.fold(
    initial: R,
    combine: (acc: R, nextElement: T) -> R
): R {
    var accumulator: R = initial
    for (element: T in this) {
        accumulator = combine(accumulator, element)
    }
    return accumulator
}
```

**函数类型**

Kotlin 使⽤类似 `(Int) -> String` 的⼀系列函数类型来处理函数的声明：`val onClick: () -> Unit = ...` 。

> 如需将函数类型指定为可空，请使⽤圆括号：`((Int, Int) -> Int)?`。
> 函数类型可以使⽤圆括号进⾏接合：`(Int) -> ((Int) -> Unit)`
> 箭头表⽰法是右结合的，`(Int) -> (Int) -> Unit` 与前述⽰例等价，但不等于 `((Int) -> (Int)) -> Unit`。

还可以通过使⽤类型别名给函数类型起⼀个别称：

```kotlin
typealias ClickHandler = (Button, ClickEvent) -> Unit
```

**函数类型实例化**

有⼏种⽅法可以获得函数类型的实例：

+ 使⽤函数字⾯值的代码块，采⽤以下形式之⼀：
    + `lambda 表达式`: `{ a, b -> a + b }` ,
    + 匿名函数: `fun(s: String): Int { return s.toIntOrNull() ?: 0 }`
    带有接收者的函数字⾯值可⽤作带有接收者的函数类型的值。
+ 使⽤已有声明的可调⽤引⽤：
    + 顶层、局部、成员、扩展函数：`::isOdd` 、`String::toInt` ，
    + 顶层、成员、扩展属性：`List<Int>::size` ，
    + 构造函数：`::Regex`
    这包括指向特定实例成员的绑定的可调⽤引⽤：foo::toString 。
+ 使⽤实现函数类型接⼝的⾃定义类的实例：

```kotlin
class IntTransformer: (Int) -> Int {
    override operator fun invoke(x: Int): Int = TODO()
} 
val intFunction: (Int) -> Int = IntTransformer()
```

如果有⾜够信息，编译器可以推断变量的函数类型：

```kotlin
val a = { i: Int -> i + 1 } // 推断出的类型是 (Int) -> Int
```

带与不带接收者的函数类型⾮字⾯值可以互换，其中接收者可以替代第⼀个参数，反之亦然。例如，`(A, B) -> C` 类型的值可以传给或赋值给期待 `A.(B) -> C` 的地⽅，反之亦然：

```kotlin
val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }
val twoParameters: (String, Int) -> String = repeatFun // OK
fun runTransformation(f: (String, Int) -> String): String {
    return f("hello", 3)
}
val result = runTransformation(repeatFun) // OK
```

> 请注意，默认情况下推断出的是没有接收者的函数类型，即使变量是通过扩展函数引⽤来初始化的。如需改变这点，请显式指定变量类型。

**函数类型实例调用**

函数类型的值可以通过其 `invoke(...)` 操作符调⽤：`f.invoke(x)` 或者直接 `f(x)` 。

```kotlin
val stringPlus: (String, String) -> String = String::plus
val intPlus: Int.(Int) -> Int = Int::plus

println(stringPlus.invoke("<-", "->"))
println(stringPlus("Hello, ", "world!"))

println(intPlus.invoke(1, 1))
println(intPlus(1, 2))
println(2.intPlus(3)) // 类扩展调⽤
```