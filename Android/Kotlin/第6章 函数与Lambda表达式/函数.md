**函数声明**

kotlin 中的函数使用 fun 关键字声明：

```kotlin
fun double(x: Int): Int {
    return 2 * x
}
```

**函数用法**

调⽤函数使⽤传统的⽅法：

```kotlin
val result = double(2)
```

调⽤成员函数使⽤点表⽰法：

```kotlin
Stream().read() // 创建类 Stream 实例并调⽤ read()
```

**参数**

函数参数使⽤ Pascal 表⽰法定义，即 name: type。参数⽤逗号隔开。每个参数必须有显式类型：

```kotlin
fun powerOf(number: Int, exponent: Int) { /*……*/ }
```

**默认参数**

函数参数可以有默认值，当省略相应的参数时使⽤默认值。

```kotlin
fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*……*/ }
```

覆盖⽅法总是使⽤与基类型⽅法相同的默认参数值。当覆盖⼀个带有默认参数值的⽅法时，必须从签名中省略默认参数值：

```kotlin
open class A {
    open fun foo(i: Int = 10) { /*……*/ }
} 
class B : A() {
    override fun foo(i: Int) { /*……*/ } // 不能有默认值
}
```

如果⼀个默认参数在⼀个⽆默认值的参数之前，那么该默认值只能通过使⽤具名参数调⽤该函数来使⽤：

```kotlin
fun foo(bar: Int = 0, baz: Int) { /*……*/ }
foo(baz = 1) // 使⽤默认值 bar = 0
```

如果在默认参数之后的最后⼀个参数是 `lambda` 表达式，那么它既可以作为具名参数在括号内传⼊，也可以在括号外传⼊：

```kotlin
fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }

foo(1) { println("hello") } // 使⽤默认值 baz = 1
foo(qux = { println("hello") }) // 使⽤两个默认值 bar = 0 与 baz = 1
foo { println("hello") } // 使⽤两个默认值 bar = 0 与 baz = 1
```

**具名参数**

可以在调⽤函数时使⽤具名的函数参数。给定以下函数：

```kotlin
fun reformat(str: String,
             normalizeCase: Boolean = true,
             upperCaseFirstLetter: Boolean = true,
             divideByCamelHumps: Boolean = false,
             wordSeparator: Char = ' ') {
    /*……*/
}
```

使⽤具名参数我们可以使代码更具有可读性：

```kotlin
reformat(str,
         normalizeCase = true,
         upperCaseFirstLetter = true,
         divideByCamelHumps = false,
         wordSeparator = '_'
)
```

并且如果我们不需要所有的参数：

```kotlin
reformat(str, wordSeparator = '_')
```

当⼀个函数调⽤混⽤位置参数与具名参数时，所有位置参数都要放在第⼀个具名参数之前。例如，允许调⽤ `f(1, y = 2)` 但不允许 `f(x = 1, 2)` 。

可以通过使⽤星号操作符将可变数量参数（`vararg`）以具名形式传⼊：

```kotlin
fun foo(vararg strings: String) { /*……*/ }
foo(strings = *arrayOf("a", "b", "c"))
```

**返回 Unit 的函数**

如果⼀个函数不返回任何有⽤的值，它的返回类型是 `Unit` 。这个值不需要显式返回：

```kotlin
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello ${name}")
    else
        println("Hi there!")
    // `return Unit` 或者 `return` 是可选的
}
或
fun printHello(name: String?) { ... }
```

**单表达式函数**

当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可：

```kotlin
fun double(x: Int): Int = x * 2
```

当返回值类型可由编译器推断时，显式声明返回类型是可选的：

```kotlin
fun double(x: Int) = x * 2
```

**可变数量的参数（Varargs）**

函数的参数（通常是最后⼀个）可以⽤ `vararg` 修饰符标记：

```kotlin
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
val list = asList(1, 2, 3)
```

只有⼀个参数可以标注为 vararg 。如果 vararg 参数不是列表中的最后⼀个参数，可以使⽤具名参数语法传递其后的参数的值。

当我们调⽤ vararg -函数时，我们可以⼀个接⼀个地传参，例如 asList(1, 2, 3) ，或者，如果我们已经有⼀个数组并希望将其内容传给该函数，我们使⽤伸展（spread）操作符（在数组前⾯加 * ）：

```kotlin
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
```

**中缀表示法**

标有 `infix` 关键字的函数也可以使⽤中缀表⽰法（忽略该调⽤的点与圆括号）调⽤。中缀函数必须满⾜以下要求：

+ 它们必须是成员函数或扩展函数；
+ 它们必须只有⼀个参数；
+ 其参数不得接受可变数量的参数且不能有默认值。

```kotlin
infix fun Int.shl(x: Int): Int { ... }
// ⽤中缀表⽰法调⽤该函数
1 shl 2
// 等同于这样
1.shl(2)
```

中缀函数调⽤的优先级低于算术操作符、类型转换以及 rangeTo 操作符。另⼀⽅⾯，中缀函数调⽤的优先级⾼于布尔操作符 && 与 ||、is- 与 in- 检测以及其他⼀些操作符。

请注意，中缀函数总是要求指定接收者与参数。当使⽤中缀表⽰法在当前接收者上调⽤⽅法时，需要显式使⽤ this ；不能像常规⽅法调⽤那样省略。

```kotlin
class MyStringCollection {
    infix fun add(s: String) { /*……*/ }
    fun build() {
       this add "abc" // 正确
       add("abc") // 正确
       //add "abc" // 错误： 必须指定接收者
    }
}
```