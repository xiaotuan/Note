**禁用内联**

如果希望只内联⼀部分传给内联函数的 lambda 表达式参数，那么可以⽤ `noinline` 修饰符标记不希望内联的函数参数：

```kotlin
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) { ... }
```

**非局部返回**

在 Kotlin 中，我们只能对具名或匿名函数使⽤正常的、⾮限定的 return 来退出。这意味着要退出⼀个lambda 表达式，我们必须使⽤⼀个标签，并且在 lambda 表达式内部禁⽌使⽤裸 return ，因为lambda 表达式不能使包含它的函数返回：

```kotlin
fun foo() {
    ordinaryFunction {
        return // 错误： 不能使 `foo` 在此处返回
    }
}
```

但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的：

```kotlin
fun foo() {
    inlined {
        return // OK： 该 lambda 表达式是内联的
    }
}
```

请注意，⼀些内联函数可能调⽤传给它们的不是直接来⾃函数体、⽽是来⾃另⼀个执⾏上下⽂的
lambda 表达式参数，例如来⾃局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许⾮局部控制流。为了标识这种情况，该 lambda 表达式参数需要⽤ crossinline 修饰符标记:

```kotlin
inline fun f(crossinline body: () -> Unit) {
    val f = object: Runnable {
        override fun run() = body()
    }
    // ...
}
```

**具体化的类型参数**

有时候我们需要访问⼀个作为参数传给我们的⼀个类型：

```kotlin
fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {
    var p = parent
    while (p != null && !clazz.isInstance(p)) {
        p = p.parent
    }
    @Suppress("UNCHECKED_CAST")
    return p as T?
}
```

为能够这么做，内联函数⽀持具体化的类型参数，于是我们可以这样写：

```kotlin
inline fun <reified T> TreeNode.findParentOfType(): T? {
    var p = parent
    while (p != null && p !is T) {
        p = p.parent
    }
    return p as T?
}
```

普通的函数（未标记为内联函数的）不能有具体化参数。

**内联属性**

`inline` 修饰符可⽤于没有幕后字段的属性的访问器。你可以标注独⽴的属性访问器:

```kotlin
val foo: Foo
    inline get() = Foo()

var bar: Bar
    get() = ...
    inline set(v) { ... }
```

你也可以标注整个属性，将它的两个访问器都标记为内联：

```kotlin
inline var bar: Bar
    get() = ...
    set(v) { ... }
```

**公有 API 内联函数的限制**

当⼀个内联函数是 `public` 或 `protected` ⽽不是 `private` 或 `internal` 声明的⼀部分时，就会认为它是⼀个模块级的公有 API。可以在其他模块中调⽤它，并且也可以在调⽤处内联这样的调⽤。

为了消除这种由⾮公有 API 变更引⼊的不兼容的⻛险，公有 API 内联函数体内不允许使⽤⾮公有声明，即，不允许使⽤ `private` 与 `internal` 声明以及其部件。

⼀个 `internal` 声明可以由 `@PublishedApi` 标注，这会允许它在公有 API 内联函数中使⽤。当⼀个 `internal` 内联函数标记有 `@PublishedApi` 时，也会像公有函数⼀样检测其函数体。