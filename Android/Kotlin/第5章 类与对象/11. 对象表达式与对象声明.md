要创建⼀个继承⾃某个（或某些）类型的匿名类的对象，我们会这么写：

```kotlin
window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { /*……*/ }
    override fun mouseEntered(e: MouseEvent) { /*……*/ }
})
```

如果超类型有⼀个构造函数，则必须传递适当的构造函数参数给它。多个超类型可以由跟在冒号后⾯的逗号分隔的列表指定：

```kotlin
open class A(x: Int) {
    public open val y: Int = x
} 
interface B { /*……*/ }

val ab: A = object : A(1), B {
    override val y = 15
}
```

任何时候，如果我们只需要“⼀个对象⽽已”，并不需要特殊超类型，那么我们可以简单地写：

```kotlin
fun foo() {
    val adHoc = object {
        var x: Int = 0
        var y: Int = 0
    } 
    print(adHoc.x + adHoc.y)
}
```

请注意，匿名对象可以⽤作只在本地和私有作⽤域中声明的类型。如果你使⽤匿名对象作为公有函数的返回类型或者⽤作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any 。在匿名对象中添加的成员将⽆法访问。

```kotlin
class C {
    // 私有函数， 所以其返回类型是匿名对象类型
    private fun foo() = object {
        val x: String = "x"
    } 
    
    // 公有函数， 所以其返回类型是 Any
    fun publicFoo() = object {
        val x: String = "x"
    } 

    fun bar() {
        val x1 = foo().x // 没问题
        val x2 = publicFoo().x // 错误： 未能解析的引⽤“x”
    }
}
```

单例模式在⼀些场景中很有⽤，⽽ Kotlin（继 Scala 之后）使单例声明变得很容易:

```kotlin
object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ……
    } 

    val allDataProviders: Collection<DataProvider>
        get() = // ……
}
```

如需引⽤该对象，我们直接使⽤其名称即可：

```kotlin
DataProviderManager.registerDataProvider(……)
```

这些对象可以有超类型:

```kotlin
object DefaultListener : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { …… }
    override fun mouseEntered(e: MouseEvent) { …… }
}
```

注意：对象声明不能在局部作⽤域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或⾮内部类中。

**伴生类**

类内部的对象声明可以⽤ `companion` 关键字标记：

```kotlin
class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
```

该伴⽣对象的成员可通过只使⽤类名作为限定符来调⽤：

```kotlin
val instance = MyClass.create()
```

可以省略伴⽣对象的名称，在这种情况下将使⽤名称 `Companion` ：

```kotlin
class MyClass {
    companion object { }
} 
val x = MyClass.Companion
```

其⾃⾝所⽤的类的名称（不是另⼀个名称的限定符）可⽤作对该类的伴⽣对象（⽆论是否具名）的引⽤：

```kotlin
class MyClass1 {
    companion object Named { }
} 

val x = MyClass1

class MyClass2 {
    companion object { }
} 

val y = MyClass2
```

请注意，即使伴⽣对象的成员看起来像其他语⾔的静态成员，在运⾏时他们仍然是真实对象的实例成员，⽽且，例如还可以实现接⼝：

```kotlin
interface Factory<T> {
    fun create(): T
} 

class MyClass {
    companion object : Factory<MyClass> {
        override fun create(): MyClass = MyClass()
    }
} 
val f: Factory<MyClass> = MyClass
```

**类型别名**

类型别名为现有类型提供替代名称。如果类型名称太⻓，你可以另外引⼊较短的名称，并使⽤新的名称替代原类型名。

```kotlin
typealias NodeSet = Set<Network.Node>

typealias FileTable<K> = MutableMap<K, MutableList<File>>
```

你可以为函数类型提供另外的别名：

```kotlin
typealias MyHandler = (Int, String, Any) -> Unit
typealias Predicate<T> = (T) -> Boolean
```

你可以为内部类和嵌套类创建新名称:

```kotlin
class A {
    inner class Inner
}
class B {
    inner class Inner
} 
typealias AInner = A.Inner
typealias BInner = B.Inner
```