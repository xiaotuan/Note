> 内联类仅在 Kotlin 1.3 之后版本可⽤，⽬前还是实验性的。

`内联类` 通过在类的前面定义一个 `inline` 修饰符来声明：

```kotlin
inline class Password(val value: String)
```

内联类必须含有唯⼀的⼀个属性在主构造函数中初始化。在运⾏时，将使⽤这个唯⼀属性来表⽰内联类的实例:

```kotlin
// 不存在 'Password' 类的真实实例对象
// 在运⾏时， 'securePassword' 仅仅包含 'String'
val securePassword = Password("Don't try this in production")
```

**成员**

内联类⽀持普通类中的⼀些功能。特别是，内联类可以声明属性与函数：

```kotlin
inline class Name(val s: String) {
    val length: Int
        get() = s.length
    
    fun greet() {
        println("Hello, $s")
    }
} 

fun main() {
    val name = Name("Kotlin")
    name.greet() // `greet` ⽅法会作为⼀个静态⽅法被调⽤
    println(name.length) // 属性的 get ⽅法会作为⼀个静态⽅法被调⽤
}
```

然⽽，内联类的成员也有⼀些限制：

+ 内联类不能含有 init 代码块
+ 内联类不能含有幕后字段
因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）内联类成员

**继承**

内联类允许去继承接⼝

```kotlin
interface Printable {
    fun prettyPrint(): String
} 

inline class Name(val s: String) : Printable {
    override fun prettyPrint(): String = "Let's $s!"
} 

fun main() {
    val name = Name("Kotlin")
    println(name.prettyPrint()) // 仍然会作为⼀个静态⽅法被调⽤
}
```

禁⽌内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类⽽且必须是 `final`。

**表示方式**

⼀般来说，只要将内联类⽤作另⼀种类型，它们就会被装箱。

```kotlin
interface I

inline class Foo(val i: Int) : I

fun asInline(f: Foo) {}
fun <T> asGeneric(x: T) {}
fun asInterface(i: I) {}
fun asNullable(i: Foo?) {}
fun <T> id(x: T): T = x

fun main() {
    val f = Foo(42)
    asInline(f) // 拆箱操作: ⽤作 Foo 本⾝
    asGeneric(f) // 装箱操作: ⽤作泛型类型 T
    asInterface(f) // 装箱操作: ⽤作类型 I
    asNullable(f) // 装箱操作: ⽤作不同于 Foo 的可空类型 Foo?
    // 在下⾯这⾥例⼦中， 'f' ⾸先会被装箱（当它作为参数传递给 'id' 函数时） 然后⼜被拆箱（当它从'id'函数中被返回时）
    // 最后， 'c' 中就包含了被拆箱后的内部表达(也就是 '42')， 和 'f' ⼀样
    val c = id(f)
}
```

引⽤相等对于内联类⽽⾔毫⽆意义，因此这也是被禁⽌的。

**名字修饰**

由于内联类被编译为其基础类型，因此可能会导致各种模糊的错误，例如意想不到的平台签名冲突：

```kotlin
inline class UInt(val x: Int)
// 在 JVM 平台上被表⽰为'public final void compute(int x)'
fun compute(x: Int) { }
// 同理， 在 JVM 平台上也被表⽰为'public final void compute(int x)'！
fun compute(x: UInt) { }
```

因此，`fun compute(x: UInt)` 将会被表⽰为 `public final void compute-<hashcode>(int x)` ，以此来解决冲突的问题。

> 请注意在 Java 中 - 是⼀个 ⽆效的 符号，也就是说在 Java 中不能调⽤使⽤内联类作为形参的函数。

**内联类与类型别名**

初看起来，内联类似乎与类型别名⾮常相似。然⽽，关键的区别在于类型别名与其基础类型(以及具有相同基础类型的其他类型别名)是 赋值兼容 的，⽽内联类却不是这样。

```kotlin
typealias NameTypeAlias = String
inline class NameInlineClass(val s: String)

fun acceptString(s: String) {}
fun acceptNameTypeAlias(n: NameTypeAlias) {}
fun acceptNameInlineClass(p: NameInlineClass) {}

fun main() {
    val nameAlias: NameTypeAlias = ""
    val nameInlineClass: NameInlineClass = NameInlineClass("")
    val string: String = ""
    acceptString(nameAlias) // 正确: 传递别名类型的实参替代函数中基础类型的形参
    acceptString(nameInlineClass) // 错误: 不能传递内联类的实参替代函数中基础类型的形参
    // And vice versa:
    acceptNameTypeAlias(string) // 正确: 传递基础类型的实参替代函数中别名类型的形参
    acceptNameInlineClass(string) // 错误: 不能传递基础类型的实参替代函数中内联类类型的形参
}
```

**内联类的实验性状态**

由于内联类是实验性的，因此在使用时会得到一个警告。如需移除警告，必须通过指定编译器参数 `-Xinline-classes` 来选择使用这项实验性的特性。

**在 Gradle 中启用内联类**

```
compileKotlin {
    kotlinOptions.freeCompilerArgs += ["-Xinline-classes"]
}

tasks.withType<KotlinCompile> {
    kotlinOptions.freeCompilerArgs += "-Xinline-classes"
}
```

**在 Maven 中启用内联类**

```
<configuration>
    <args>
        <arg>-Xinline-classes</arg>
    </args>
</configuration>
```