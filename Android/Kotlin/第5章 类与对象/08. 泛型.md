与 Java 类似，Kotlin 中的类也可以有类型参数：

```kotlin
class Box<T>(t: T) {
    var value = t
}
```

⼀般来说，要创建这样类的实例，我们需要提供类型参数：

```kotlin
val box: Box<Int> = Box<Int>(1)
```

但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数：

```kotlin
var box = Box(1)	// 1 具有类型 Int，所以编译器知道我们说的是 Box<Int>。
```

**声明处型变**

可以标注 Source 的类型参数 T 来确保它仅从 Source\<T\> 成员中返回（⽣产），并从不被消费。为此，我们提供 out 修饰符：

```kotlin
interface Source<out T> {
    fun nextT(): Target
}

fun demo(strs: Source<String>) {
    val objects: Source<Any> = strs	// 这个没问题，因为 T 是一个 out 参数
}
```

⼀般原则是：当⼀个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C\<Base\> 可以安全地作为 C\<Derived\> 的超类。

另外除了 out，Kotlin ⼜补充了⼀个型变注释：in。它使得⼀个类型参数逆变：只可以被消费⽽不可以被⽣产。逆变类型的⼀个很好的例⼦是 Comparable ：

```kotlin
interface Comparable<in T> {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable<Number>) {
    x.compareTo(1.0)	// 1.0 拥有类型 Double，它是 Number 的子类型
    // 因此，我们可以将 x 赋给类型为 Comparable<Cougle> 的变量
    var y: Comparable<Double> = x	// OK!
}
```

**类型投影**

`Array <T>` 在 T 上是不型变的，因此 `Array <Int>` 和 `Array<Any>` 都不是另⼀个的⼦类型。要确保的是 copy() 不会做任何坏事。我们想阻⽌它写到 from ，我们可以：

```kotlin
fun copy(from: Array<out Any>, to: Array<Any>) { …… }
```

这⾥发⽣的事情称为类型投影：我们说 from 不仅仅是⼀个数组，⽽是⼀个受限制的（投影的）数组：我们只可以调⽤返回类型为类型参数 T 的⽅法，如上，这意味着我们只能调⽤ get()。

你也可以使⽤ in 投影⼀个类型：

```kotlin
fun fill(dest: Array<in String>, value: String) { …… }
```

**星投影**

Kotlin 提供了所谓的星投影语法：

+ 对于 `Foo <out T : TUpper>` ，其中 T 是⼀个具有上界 `Upper` 的协变类型参数，`Foo <*>`等价于 `Foo <out TUpper>` 。这意味着当 `T` 未知时，你可以安全地从 `Foo <*>` 读取 `TUpper`的值。
+ 对于` Foo <in T>` ，其中 `T` 是⼀个逆变类型参数，`Foo <*>` 等价于 `Foo <in Nothing>` 。这意味着当 `T` 未知时，没有什么可以以安全的⽅式写⼊ `Foo <*>` 。
+ 对于 `Foo <T : TUpper>` ，其中 `T` 是⼀个具有上界 `TUpper` 的不型变类型参数，`Foo<*>` 对于读取值时等价于 `Foo<out TUpper>` ⽽对于写值时等价于 `Foo<in Nothing> `。

如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。例如，如果类型被声明为`interface Function <in T, out U>` ，我们可以想象以下星投影：

+ `Function<*, String>` 表⽰ `Function<in Nothing, String>` ；
+ `Function<Int, *>` 表⽰` Function<Int, out Any?>` ；
+ `Function<*, *>` 表⽰ `Function<in Nothing, out Any?>` 。

**泛型函数**

类型参数要放在函数名称之前：

```kotlin
fun <T> singletonList(item: T): List<T> {
// ……
} 

fun <T> T.basicToString(): String { // 扩展函数
// ……
}
```

要调⽤泛型函数，在调⽤处函数名之后指定类型参数即可：

```kotlin
val l = singletonList<Int>(1)
```

可以省略能够从上下⽂中推断出来的类型参数，所以以下⽰例同样适⽤：

```kotlin
val l = singletonList(1)
```

**泛型约束**

最常⻅的约束类型是与 `Java` 的 *extends* 关键字对应的 上界。冒号之后指定的类型是上界：只有 Comparable<T> 的⼦类型可以替代 T 。例如：

```kotlin
fun <T : Comparable<T>> sort(list: List<T>) { …… }
```

默认的上界（如果没有声明）是 `Any?` 。在尖括号中只能指定⼀个上界。如果同⼀类型参数需要多个上界，我们需要⼀个单独的 **where** ⼦句。所传递的类型必须同时满⾜ where ⼦句的所有条件。：

```kotlin
fun <T> copyWhenGreater(list: List<T>, threshold: T): List<String>
    where  T : CharSequence,
          T : Comparable<T> {
    return list.filter { it > threshold }.map { it.toString() }
}
```

**类型擦除**

Kotlin 为泛型声明⽤法执⾏的类型安全检测仅在编译期进⾏。运⾏时泛型类型的实例不保留关于其类型实参的任何信息。其类型信息称为被擦除。

因此，并没有通⽤的⽅法在运⾏时检测⼀个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器禁⽌这种 is 检测。  