**委托属性**

为了涵盖这些（以及其他）情况，Kotlin ⽀持 委托属性:

```kotlin
class Example {
    var p: String by Delegate()
}
```

语法是：`val/var <属性名>: <类型> by <表达式>` 。在 `by` 后⾯的表达式是该 委托，因为属性对应的 `get()`（与 `set()` ）会被委托给它的 `getValue()` 与 `setValue()` ⽅法。属性的委托不必实现任何的接⼝，但是需要提供⼀个 `getValue()` 函数（与 `setValue()` ⸺对于 `var` 属性）。例如:

```kotlin
import kotlin.reflect.KProperty
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    } 

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}
```

**延迟属性 Lazy**

`lazy()` 是接受⼀个 `lambda` 并返回⼀个 `Lazy <T>` 实例的函数，返回的实例可以作为实现延迟属性的委托：第⼀次调⽤ `get()` 会执⾏已传递给 `lazy()` 的 `lambda` 表达式并记录结果，后续调⽤ `get()` 只是返回记录的结果。

```kotlin
val lazyValue: String by lazy {
    println("Hello computed!")
} 

fun main() {
    println(lazyValue)
    println(lazyValue)
}
```

默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在⼀个线程中计算，并且所有线程会看到相同的值。

**可观察属性 Observable**

`Delegates.observable()` 接受两个参数：初始值与修改时处理程序（handler）。它有三个参数：被赋值的属性、旧值与新值：

```kotlin
import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
          println("$old -> $new")
    }
} 

fun main() {
    val user = User()
    user.name = "first"
    user.name = "second"
}
```

如果你想截获赋值并“否决”它们，那么使⽤ `vetoable()` 取代 `observable()` 。在属性被赋新值⽣效之前会调⽤传递给 vetoable 的处理程序。

**把属性存储在映射中**

⼀个常⻅的⽤例是在⼀个映射（map）⾥存储属性的值。这经常出现在像解析 JSON 或者做其他“动态”事情的应⽤中。在这种情况下，你可以使⽤映射实例⾃⾝作为委托来实现委托属性。

```kotlin
class User(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int by map
}
```

在这个例⼦中，构造函数接受⼀个映射参数：

```kotlin
val user = User(mapOf(
    "name" to "John Doe",
    "age" to 25
))
```

**局部委托属性**

你可以将局部变量声明为委托属性。例如，你可以使⼀个局部变量惰性初始化：

```kotlin
fun example(computeFoo: () -> Foo) {
    val memoizedFoo by lazy(computeFoo)
    if (someCondition && memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}
```

**属性委托要求**

对于⼀个只读属性（即 val 声明的），委托必须提供⼀个操作符函数 getValue() ，该函数具有以下参数：

+ `thisRef` ⸺ 必须与 属性所有者 类型（对于扩展属性⸺指被扩展的类型）相同或者是其超类型。
+ `property` ⸺ 必须是类型 `Property<*>` 或其超类型。

`getValue()` 必须返回与属性相同的类型（或其⼦类型）。

```kotlin
class Resource

class Owner {
    val valResource: Resource by ResourceDelegate()
} 

class ResourceDelegate {
    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {
        return Resource()
    }
}
```

对于⼀个可变属性（即 var 声明的），委托必须额外提供⼀个操作符函数 setValue() ，该函数具有以下参数：

+ `thisRef` ⸺ 必须与 属性所有者 类型（对于扩展属性⸺指被扩展的类型）相同或者是其超类型。
+ `property` ⸺ 必须是类型 `KProperty<*>` 或其超类型。
+ `value` — 必须与属性类型相同（或者是其超类型）。

```kotlin
class Resource

class Owner {
    var varResource: Resource by ResourceDelegate()
} 

class ResourceDelegate(private var resource: Resource = Resource()) {
    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {
        return resource
    }

    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {
        if (value is Resource) {
            resource = value
        }
    }
}
```

委托类可以实现包含所需 `operator` ⽅法的 `ReadOnlyProperty` 或 `ReadWriteProperty` 接⼝之⼀。这俩接⼝是在 Kotlin 标准库中声明的：

```kotlin
interface ReadOnlyProperty<in R, out T> {
    operator fun getValue(thisRef: R, property: KProperty<*>): T
} 

interface ReadWriteProperty<in R, T> {
    operator fun getValue(thisRef: R, property: KProperty<*>): T
    operator fun setValue(thisRef: R, property: KProperty<*>, value: T)
}
```

