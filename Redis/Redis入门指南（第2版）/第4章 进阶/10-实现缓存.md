### 4.2.4　实现缓存

为了提高网站的负载能力，常常需要将一些访问频率较高但是对CPU或IO资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间自动过期。比如教务网站要对全校所有学生的各个科目的成绩汇总排名，并在首页上显示前10名的学生姓名，由于计算过程较耗资源，所以可以将结果使用一个Redis的字符串键缓存起来。由于学生成绩总在不断地变化，需要每隔两小时就重新计算一次排名，这可以通过给键设置过期时间的方式实现。每次用户访问首页时程序先查询缓存键是否存在，如果存在则直接使用缓存的值；否则重新计算排名并将计算结果赋值给该键并同时设置该键的过期时间为两小时。伪代码如下：

```shell
$rank = GET cache:rank
if not $rank
　　$rank = 计算排名...
　　MUlTI 　　SET cache:rank, $rank
　　EXPIRE cache:rank, 7200
　　EXEC

```

然而在一些场合中这种方法并不能满足需要。当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致Redis占满内存；另一方面如果为了防止Redis占用内存过大而将缓存键的过期时间设得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制Redis能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存系统时非常实用。

具体的设置方法为：修改配置文件的 `maxmemory` 参数，限制Redis最大可用内存大小（单位是字节），当超出了这个限制时Redis会依据 `maxmemory-policy` 参数指定的策略来删除不需要的键直到Redis占用的内存小于指定内存。

`maxmemory-policy` 支持的规则如表4-1所示。其中的LRU（Least Recently Used）算法即“最近最少使用”，其认为最近最少使用的键在未来一段时间内也不会被用到，即当需要空间时这些键是可以被删除的。

<center class="my_markdown"><b class="my_markdown">表4-1 Redis支持的淘汰键的规则</b></center>

| 规　　则 | 说　　明 |
| :-----  | :-----  | :-----  | :-----  |
| `volatile-lru` | 使用LRU算法删除一个键（只对设置了过期时间的键） |
| `allkeys-lru` | 使用LRU算法删除一个键 |
| `volatile-random` | 随机删除一个键（只对设置了过期时间的键） |
| `allkeys-random` | 随机删除一个键 |
| `volatile-ttl` | 删除过期时间最近的一个键 |
| `noeviction` | 不删除键，只返回错误 |

如当 `maxmemory-policy` 设置为 `allkeys-lru` 时，一旦Redis占用的内存超过了限制值，Redis会不断地删除数据库中最近最少使用的键2，直到占用的内存小于限制值。

2事实上Redis并不会准确地将整个数据库中最久未被使用的键删除，而是每次从数据库中随机取3个键并删除这3个键中最久未被使用的键。删除过期时间最接近的键的实现方法也是这样。“3”这个数字可以通过Redis的配置文件中的 `maxmemory-samples` 参数设置。

