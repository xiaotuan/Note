### 5.6　在着色器中使用纹理：采样器变量和纹理单元

为了最大限度地提高性能，我们希望在硬件中执行纹理处理。这意味着我们的片段着色器需要一种访问我们在C++/OpenGL应用程序中创建的纹理对象的方法。它的实现机制是通过一个叫作统一采样器变量的特殊GLSL工具。这是一个变量，用于指示显卡上的纹理单元，从加载的纹理对象中提取或“采样”哪个纹素。

在着色器中声明一个采样器变量很简单——只需将其添加到您的统一变量中：

```c
layout (binding=0) uniform sampler2D samp;
```

我们声明的变量名字叫作“samp”。声明的“layout (binding=0)”部分指定此采样器与纹理单元0相关联。

纹理单元（和相关的采样器）可用于对您希望的任何纹理对象进行采样，并且可以在运行时进行更改。您的display()函数需要指定纹理单元要为当前帧采样的纹理对象。因此，每次绘制对象时，都需要激活纹理单元并将其绑定到特定的纹理对象，例如：

```c
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, brickTexture);
```

可用纹理单元的数量取决于图形卡上提供的数量。根据OpenGL API文档，OpenGL 4.5版要求每个着色器阶段至少有16个，所有阶段总共至少80个单元<sup class="my_markdown">[OP16]</sup>。在这个例子中，我们通过在glActiveTexture()调用中指定GL_TEXTURE0，使得第0个纹理单元处于激活状态。

要实际执行纹理处理，我们需要修改片段着色器输出颜色的方式。以前，我们的片段着色器要么输出一个固定的颜色常量，要么从顶点属性获取颜色。相反，这次我们需要使用从顶点着色器（通过光栅着色器）接收的插值纹理坐标来对纹理对象进行采样，像这样调用texture()函数：

```c
in vec2 tc;            // 纹理坐标
. . .
color = texture(samp, tc);
```

