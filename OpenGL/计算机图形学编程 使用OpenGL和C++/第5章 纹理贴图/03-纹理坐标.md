### 5.2　纹理坐标

现在我们已经有了将纹理图像加载到OpenGL中的方法，我们需要指定我们希望如何将纹理应用于对象的渲染表面。我们通过为模型中的每个顶点指定纹理坐标来完成此操作。

纹理坐标是对纹理图像（通常是2D）中的像素的引用。纹理图像中的像素被称为纹素（Texel），以便将它们与在屏幕上呈现的像素区分开。纹理坐标用于将3D模型上的点映射到纹理中的位置。除了将它定位在3D空间中的(x,y,z)坐标之外，模型表面上的每个点还具有纹理坐标(s,t)，用来指定纹理图像中的哪个纹素为它提供颜色。这样，物体的表面被按照纹理图像“涂画”。纹理在对象表面上的朝向由分配给对象顶点的纹理坐标来确定。

要使用纹理贴图，必须为要添加纹理的对象中的每个顶点提供纹理坐标。OpenGL将使用这些纹理坐标，查找存储在纹理图像中的引用的纹素的颜色，来确定模型中每个光栅化像素的颜色。为了确保渲染模型中的每个像素都使用纹理图像中的适当纹素进行绘制，纹理坐标也需要被放入顶点属性中，以便它们也由光栅着色器进行插值。以这种方式，纹理图像与模型顶点一起被插值或者填充。

对于通过顶点着色器的每组顶点坐标(x,y,z)，会有一组相应的纹理坐标(s,t)。因此，我们将设置两个缓冲区，一个用于顶点（每个条目中有3个分量x、y和z），另一个用于相应的纹理坐标（每个条目中有两个分量s和t）。这样，每次顶点着色器的调用接收到一个顶点的数据，现在包括了其空间坐标和相应的纹理坐标。

2D纹理坐标最为常见（OpenGL确实支持其他一些维度，但我们不会在本章中介绍它们）。2D纹理图像被设定为矩形，左下角的位置坐标为(0,0)，右上角的位置坐标为(1,1)。<sup class="my_markdown">[1]</sup>理想情况下，纹理坐标应该在[0…1]范围内取值。

考虑图5.2中的示例。回想一下，立方体模型由三角形构成。我们的示意图中突出显示了立方体一侧的4个角，但请记住，立方体的每个正方形侧面需要两个三角形。指定这一个立方体侧面的6个顶点中的每一个的纹理坐标沿着4个角列出，左上角和右下角各自由一对顶点组成。示例里也显示了纹理图像。纹理坐标（由s和t描述）将图像的部分（纹素）映射到模型正面的光栅化像素上。请注意，顶点之间的所有中间像素都已使用图像中间插值的纹素进行绘制。这正是因为纹理坐标在顶点属性中被发送到片段着色器，因此也像顶点本身一样被插值。

![127.png](../images/127.png)
<center class="my_markdown"><b class="my_markdown">图5.2　纹理坐标</b></center>

在这个示例中，出于说明的目的，我们故意指定了会导致奇怪的表面绘制的纹理坐标。仔细观察，您还可以看到图像看起来略微拉伸——这是因为纹理图像的长宽比与立方体面相关的给定纹理坐标的长宽比不匹配。

对于立方体或金字塔这样的简单模型，选择纹理坐标相对容易。但对于具有大量三角形的更复杂的弯曲模型，手动确定它们是不切实际的。在弯曲的几何形状（例如球形或环面）的情况下，可以通过算法或数学方式计算纹理坐标。对于使用Maya <sup class="my_markdown">[MA16]</sup>或Blender <sup>[BL16]</sup>等建模工具构建的模型，这些工具提供有“UV映射”功能（在本书范围之外），使得这项任务更容易。

让我们回去渲染我们的金字塔，只是这次用砖的图像添加纹理。我们需要指定：（a）引用纹理图像的整型ID；（b）模型顶点的纹理坐标；（c）用于保存纹理坐标的缓冲区；（d）顶点属性，以便顶点着色器可以接收并通过管线转发纹理坐标；（e）显卡上用于保存纹理对象的纹理单元；（f）我们将很快看到的用于访问GLSL中纹理单元的统一采样器变量。这些将在下一节中描述。

