### 补充说明

在本章中，我们仅给出了3D图形中阴影世界的最基本介绍。在更复杂的场景中，即便使用本章提供的基础阴影贴图方法，也可能需要进行进一步的研究。

例如，当场景中的某些对象拥有纹理的情况下，添加阴影时必须确保片段着色器正确区分阴影纹理和其他纹理。一种简单的方法是将它们绑定到不同的纹理单元，例如：

```c
layout (binding = 0) uniform sampler2DShadow shTex; 
layout (binding = 1) uniform sampler2D otherTexture;
```

然后，C++ / OpenGL应用程序可以通过它们的绑定值来引用两个采样器。

当场景使用多个灯光时，则需要多个阴影纹理——每个光源需要一个阴影纹理。此外，每个光源都需要单独执行第1轮渲染，并在第2轮渲染中合并结果。

尽管我们在阴影贴图的每个阶段都使用了透视投影，但值得注意的是，当光源是远距离光源和定向光源而非我们使用的位置光时，正射投影通常才是首选。

生成真实的阴影在计算机图形学中仍然是一个活跃而又复杂的领域，其中提出的许多技术超出了本书的范畴。我们鼓励对更多细节感兴趣的读者研究更专业的资源，如<sup class="my_markdown">[ES12], [GP10]</sup>和<sup>[MI16]</sup>。

8.7.3小节包含一个GLSL函数的例子（除了“main”）。与在C语言中一样，必须在调用它们之前（或“上方”）定义函数，否则必须提供前向声明。在该示例中则不需要前向声明，因为函数定义在调用代码上方。

