### 4.4　模型-视图和透视矩阵

渲染3D对象的一个基础步骤是创建适当的变换矩阵并将它们发送到统一变量，就像我们在4.2节中所做的那样。我们首先定义3个矩阵：

+ 一个模型矩阵；
+ 一个视图矩阵；
+ 一个透视矩阵。

模型矩阵在世界坐标空间中表示对象的位置和朝向。每个模型都有自己的模型矩阵，如果模型移动，则需要不断重建该矩阵。

视图矩阵移动并旋转世界中的模型，以模拟相机在所需位置的效果。回忆一下第2章，OpenGL相机存在于位置(0,0,0)并且面向负Z轴。为了模拟以某种方式移动的相机的表现，我们需要向相反的方向移动物体本身。例如，将摄像机向右移动会导致场景中的物体看起来像是向左移动；虽然OpenGL相机是固定的，但我们可以通过把对象向左移动的方式，让摄像机看起来向右移动了。

透视矩阵是一种变换，它根据所需的视锥提供3D效果，如前面第3章所述。

了解何时计算每种类型的矩阵也很重要。永远不会改变的矩阵可以在init()中构建，但那些会改变的矩阵需要在display()中构建，以便为每个帧重建它们。我们假设模型是动画的，相机是可移动的，那么：

+ 需要为每个模型和每个帧都创建模型矩阵；
+ 视图矩阵需要每帧创建一次（因为相机可以移动），但是对于在这一帧期间渲染的所有对象，它都是一样的；
+ 透视矩阵只需要创建一次［在init()中］，它需要使用屏幕窗口的宽度和高度（以及所需的视锥体参数），除非调整窗口大小，否则它通常保持不变。

然后在display()函数中生成模型和视图转换矩阵，如下所示。

（1）根据所需的摄像机位置和朝向构建视图矩阵。

（2）对于每个模型，进行以下操作。

i．根据模型的位置和朝向构建模型矩阵。

ii．将模型和视图矩阵结合成单个“MV”矩阵。

iii．将MV和投影矩阵发送到相应的着色器统一变量。

从技术上讲，没有必要将模型和视图矩阵合并成一个矩阵。也就是说，它们也可以用单独分开的矩阵的形式发送给顶点着色器。然而，将它们合并，并保持透视矩阵分离，有一些优点。例如，在顶点着色器中，模型中的每个顶点都需要乘以矩阵。由于复杂的模型可能有数百甚至数千个顶点，因此可以通过在将模型和视图矩阵发送到顶点着色器之前预先相乘一次来提高性能。稍后，我们将看到为什么需要将透视矩阵分开以用于光照的目的。

