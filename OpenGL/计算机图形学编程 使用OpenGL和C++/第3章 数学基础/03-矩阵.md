### 3.3　矩阵

矩阵是矩形的值阵列，它的元素通常使用下标访问。第一个下标表示行号，第二个下标表示列号，下标从0开始。我们在3D图形计算中要用到的矩阵大多数大小为4×4，如图3.2所示。

![55.png](../images/55.png)
<center class="my_markdown"><b class="my_markdown">图3.2　4×4矩阵</b></center>

GLSL语言中的mat4数据类型用来存储4×4矩阵。同样，GLM中有mat4类用以实例化并存储4×4矩阵。

单位矩阵中一条对角线的值为1，其余值全为0：



![56.gif](../images/56.gif)
任何值乘以单位矩阵都不会改变。在GLM中，调用构造函数glm::mat4 m(1.0f)以在变量m中生成单位矩阵。

矩阵转置的计算是通过交换矩阵的行和列完成的。例如：



![57.gif](../images/57.gif)
GLM库和GLSL库都有转置函数，分别是glm::transpose(mat4)和transpose(mat4)。

矩阵加法简单明了：



![58.gif](../images/58.gif)
在GLSL中，+运算符在mat4上进行了重载，以支持矩阵加法。

3D图形学中有很多有用的矩阵乘法操作。矩阵乘法一般可以从左向右或从右向左处理（注意，由于左乘和右乘是不同的，所以矩阵乘法不满足交换律）。

在3D图形学中，点与矩阵相乘通常从右向左，得到点，如：



![59.gif](../images/59.gif)
注意，我们用齐次坐标将点(X, Y, Z)表示为列数为1的矩阵。

GLSL和GLM都支持点（确切地说是vec4）与矩阵使用*操作符相乘。

4×4矩阵与4×4矩阵相乘如下：



![60.gif](../images/60.gif)
矩阵相乘也经常叫作合并，稍后我们会看到，它可以用于将一系列矩阵变换合并成一个矩阵。这种合并矩阵变换的能力来自矩阵乘法的结合律。

考虑如下运算序列：



![61.gif](../images/61.gif)
我们将一个点与Matrix<sub class="my_markdown">3</sub>相乘，之后将结果与Matrix<sub>2</sub>相乘，最后将结果与Matrix<sub>1</sub>相乘。其结果是一个新的点。结合律确保了之前的计算与如下计算相同：



![62.gif](../images/62.gif)
我们先将3个矩阵相乘，建立Matrix<sub class="my_markdown">1</sub>、Matrix<sub>2</sub>、Matrix<sub>3</sub>的连接。如果我们称其为Matrix<sub>C</sub>，我们就可以将之前的运算写作：



![63.gif](../images/63.gif)
我们稍后在第4章会看到这么做的好处是，我们需要经常将相同的一系列矩阵变换应用到场景中的每个点上。通过预先一次计算好这些矩阵的合并，就可以成倍减少总的矩阵运算量。

GLSL和GLM都支持使用重载后的*运算符进行矩阵乘法。

一个4×4矩阵的逆矩阵是另一个4×4矩阵，用**M**<sup class="my_markdown">−1</sup>表示，在矩阵乘法中有如下性质：



![64.jpg](../images/64.jpg)
在此我们就不展示计算逆矩阵的细节了。但是，需要知道的是计算矩阵的逆矩阵的运算量很大。幸运的是我们只有很少情况下需要用到它。在这些极少的情况下，GLSL和GLM都提供了mat4.inverse()函数。

