<center>正则表达式的重复字符语法</center>

| 字符 | 含义 |
| :- | :- |
| {n, m} | 匹配前一项至少 n 次，但不能超过 m 次 |
| {n, } | 匹配前一项 n 次或者更多次 |
| {n} | 匹配前一项 n 次 |
| ? | 匹配前一项 0 次或者 1 次，也就是说前一项是可选的，等价于 {0, 1} |
| + | 匹配前一项 1 次或多次，等价于 {1, } |
| * | 匹配前一项 0 次或多次，等价于 {0, } |

例如：

```js
/\d{2, 4}/           // 匹配 2 ~ 4 个数字
/\w{3}\d?/           // 精确匹配三个单词和一个可选的数字
/\s+java\s+/         // 匹配前后带有一个或多个空格的字符串 “java”
/[^(]*]/             // 匹配一个或多个非左括号的字符
```

在使用 “\*“ 和 ”?“ 时要注意，由于这些字符可能匹配 0 个字符，因此他们允许什么都不匹配。例如，正则表达式 `/a*/` 实际上与字符串 "bbbb" 匹配，因为这个字符串含有 0 个 a。 

上表中列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为”贪婪的“匹配。我们同样可以使用正则表达式进行非贪婪匹配。只须在待匹配的字符后跟随一个问号即可：`??`、`+?`、`*?` 或 `{1, 5}?`。比如，正则表达式 `/a+/` 可以匹配一个或多个连续的字母 a 。当使用 ”aaa“ 作为匹配字符串时，正则表达式会匹配它的三个字符。但是 `/a+?/` 也可以匹配一个或多个连续字母 a ，但它是尽可能少地匹配。我们同样将 "aaa" 作为匹配字符串，但后一个模式只能匹配第一个 a 。

使用非贪婪的匹配模式所得到的结果可能和期望并不一致。考虑以下正则表达式 `/a+b/`，它可以匹配一个或多个 a ，以及一个 b。当使用 “aaab” 作为匹配字符串时，它会匹配整个字符串。现在再试一下非贪婪匹配的版本 `/a+?b/`，它匹配尽肯能少的 a 和一个 b。当用它来匹配 “aaab” 时，你期望它能匹配一个 a 和最后一个 b。但实际上，这个模式确匹配了整个字符串，和该模式的贪婪匹配一模一样。这是因为正则表达式的匹配模式总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。