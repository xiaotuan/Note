[toc]

### 1. test 或 [ 命令

在实际工作中，大多数脚本程序都会广泛使用 shell 的布尔判断命令 [ 或 test。在一些系统上，这两个命令的作用是一样的，只是为了增强可读性，当使用 [ 命令时，我们还使用符号 ] 来结尾。把 [ 符号当作一条命令多少有点奇怪，但它在代码中确实会使命令的语法看起来更简单、更明确、更像其他程序语言。

> 注意
>
> 因为 test 命令在 shell 脚本程序以外用得很少，所以那些很少编写 shell 脚本的 Linux 用户往往会将自己编写的简单程序命名为 test。如果程序不能正常工作，很可能是因为它与 shell 中的 test 命令发生了冲突。要想查看系统中是否有一个指定名称的外部命令，你可以尝试使用 `which test` 这样的命令来检查执行的是哪一个 test 命令，或者使用 `./test` 这种执行方式以确保你执行的是当前目录下的脚本程序。如有以为，你只需养成在调用脚本的前面加上 `./` 的习惯即可。

我们以一个最简单的条件为例来介绍 test 命令的用法：检查一个文件是否存在。用于实现这一操作的命令是 `test -f <filename>`，所以在脚本程序里，你可以写出如下所示的代码：

```shell
if test -f fred.c
then
...
fi
```

或者

```shell
if [ -f fred.c ]
then
...
fi
```

> 注意
>
> 你必须在 [ 符号和被检查的条件之间留出空格。要记住这一点，你可以把 [ 符号看作和 test 命令一样，而 test 命令之后总是应该有一个空格。如果你喜欢把 then 和 if 放在同一行上，就必须要用一个分号把 test 语句和 then 语句隔开。如下所示：
>
> ```shell
> if [ -f fred.c ]; then
> ...
> fi
> ```

### 2. 比较字符串

| 字符串比较         | 结果                                    |
| ------------------ | --------------------------------------- |
| string1 = string2  | 如果两个字符串相同则结果为真            |
| string1 != string2 | 如果两个字符串不同则结果为真            |
| -n string          | 如果字符串不为空则结果为真              |
| -z string          | 如果字符串为 null（一个空串）则结果为真 |

### 3 算术比较

| 算术比较                    | 结果                                             |
| --------------------------- | ------------------------------------------------ |
| expression1 -eq expression2 | 如果两个表达式相等则结果为真                     |
| expression1 -ne expression2 | 如果两个表达式不等则结果为真                     |
| expression1 -gt expression2 | 如果 expression1 大于 expression2 则结果为真     |
| expression1 -ge expression2 | 如果 expression1 大于等于 expression2 则结果为真 |
| expression1 -lt expression2 | 如果 expression1 小于 expression2 则结果为真     |
| expression1 -le expression2 | 如果 expression1 小于等于 expression2 则结果为真 |
| ! expression                | 如果表达式为假则结果为真，反之亦然               |

### 4. 文件条件测试

| 文件条件测试 | 结果                                                         |
| ------------ | ------------------------------------------------------------ |
| -d file      | 如果文件是一个目录则结果为真                                 |
| -e file      | 如果文件存在则结果为真。要注意的是，历史上 -e 选项不可移植，所以通常使用的是 -f 选项 |
| -f file      | 如果文件时一个普通文件则结果为真                             |
| -g file      | 如果文件的 set-group-id 位被设置则结果为真                   |
| -r file      | 如果文件可读则结果为真                                       |
| -s file      | 如果文件的大小不为 0 则结果为真                              |
| -u file      | 如果文件的 wet-user-id 位被设置则结果为真                    |
| -w file      | 如果文件可写则结果为真                                       |
| -x file      | 如果文件可执行则结果为真                                     |

> 读者可能想知道什么是 set-group-id 和 set-user-id（也叫做 set-gid 和 set-uid）位。set-uid 位授予了程序其拥有者的访问权限而不是其使用者的访问权限，而 set-gid 位授予了程序其所在组的访问权限。这两个特殊位是通过 chmod 命令的选项 s 和 g 设置的。set-gid 和 set-uid 标志对 shell 脚本程序不起作用，它们只对可执行的二进制文件有用。

