### 14.1　Docker访问权限及其意味着什么

读者可能想知道一个用户如果可以运行Docker会造成多大的破坏。一个简单的例子是，下面这条命令（不要运行！）可能会删除宿主机/sbin目录下的所有二进制文件（如果拿掉了那个伪造的 `--donotrunme` 标志）：

```c
docker run --donotrunme -v /sbin:/sbin busybox rm -rf /sbin
```

值得指出的是，即使你不是root用户，这段代码仍然生效。

下面这条命令将会展示宿主机系统上安全shadow密码文件的内容：

```c
docker run -v /etc/shadow:/etc/shadow busybox cat /etc/shadow
```

Docker的不安全性经常遭到误解，一部分是由于对内核中的命名空间的好处的误解。Linux命名空间提供了对系统中其他部分的隔离，但是对Docker的隔离级别是由用户自行决定的（正如前述的几个 `docker run` 例子所展示的）。而且，Linux操作系统不是所有部分都能够使用命名空间。设备和内核模块就是两个没有使用命名空间的Linux核心功能的例子。



**提示**

Linux命名空间是设计来为进程提供独立于其他进程的系统视角的。例如，进程命名空间意味着容器只能够看到与容器有关的进程——在同一宿主机上运行的其他进程对其而言是不可见的。网络空间命名意味着容器似乎有自己独有的网络栈可用。命名空间成为Linux内核的一部分已有多年。



而且，由于用户在容器内部可以通过系统调用来与内核进行root级别的交互，所以任何的内核缺陷都可能在Docker容器内被root用户利用。当然，虚拟机通过访问hypervisor可以达到类似的攻击，因为hypervisor本身也被曝出一些安全缺陷。

另一种理解这一风险的方式是认为运行容器与能通过包管理工具安装程序没什么区别（从安全的角度看）。用户对运行Docker容器的安全需求应该和安装软件包是一样的。如果用户有Docker，可以作为root用户安装软件。这也是有人说Docker最好被理解为一个软件打包系统的部分原因。



**提示**

有些工作正在进行以期望通过用户命名空间来解除此风险，它可以把容器中的root用户映射到宿主机上的非特权用户。



