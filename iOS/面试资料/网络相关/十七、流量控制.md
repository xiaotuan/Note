###### 十七、流量控制

TCP连接的双方主机都会为该TCP连接分配缓存和变量。当该TCP连接收到正确、按序的字节后，就将数据放入`接收缓存`。上层的应用进程会从该缓存中读取数据，但不必是数据一到达就立即读取，因为此时应用程序可能在做其他事务。而如果应用层读取数据相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的`接收缓存`溢出。

所以，TCP为应用程序提供了**流量控制服务**（flow-control service），以消除发送方使接收方缓存溢出的可能性。

`流量控制`是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。
作为全双工协议，TCP会话的双方都各自维护一个**发送窗口**和一个**接收窗口**（receive window）的变量来提供流量控制。而`发送窗口`的大小是由对方`接收窗口`来决定的，`接收窗口`用于给发送方一个指示--该接收方还有多少可用的缓存空间。

**1、发送窗口**

发送方的发送缓存内的数据都可以被分为4类:

* 已发送，已收到ACK
* 已发送，未收到ACK
* 未发送，但允许发送
* 未发送，但不允许发送

则2和3属于`发送窗口`

* `发送窗口`只有收到`发送窗口`内字节的ACK确认，才会移动发送窗口的左边界

**2、接收窗口**

接收方的缓存数据分为3类：
1.已接收
2.未接收但准备接收
3.未接收而且不准备接收
则2 属于`接收窗口`（这里的接收指接收数据并确认）


* `接收窗口`只有在前面所有的报文段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，会先接收下来，`接收窗口`不会移动，并不对后续字节发送ACK确认报文，以此确保发送端会对这些数据重传。

我们定义以下变量：

* `LastByteRead`：接收方应用程序读取的数据流的最后一个字节编号。可以得知，这是`接收缓存`的起点

* `LastByteRcvd`：从网络中到达的并且已放入`接收缓存`中的数据流的最后一个自己的的编号。

可以得知：`LastByteRcvd` - `LastByteRead` <= `RcvBuffer`(接收缓存大小)
那么接收窗口`rwnd` =`RcvBuffer` - （`LastByteRcvd` - `LastByteRead`）
`rwnd`是随时间动态变化的，如果`rwnd`为0，则意味着接收缓存已经满了。
接收端在回复给发送端的ACK中会包含该rwnd，发送端则会根据ACK中的接收窗口的值来控制发送窗口。

有一个问题，如果当发送`rwnd`为0的`ACK`后，发送端停止发送数据。等待一段时间后，接收方应用程序读取了一部分数据，接收端可以继续接收数据，于是给发送端发送报文告诉发送端其`接收窗口`大小，但这个报文不幸丢失了，我们知道，**不含数据的ACK是不会超时重传的**，于是就出现发送端等待接收端的`ACK`通知||接收端等待发送端发送数据的死锁状态。

为了处理这种问题，TCP引入了`持续计时器`（Persistence timer），当发送端收到对方的`rwnd=0`的`ACK`通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的`接收窗口`大小，如果结果仍未0，则重设持续计时器，继续等待。
