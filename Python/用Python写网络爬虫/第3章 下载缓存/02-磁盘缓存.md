[toc]

为了保证在不同文件系统中，我们的文件路径都是安全的，就需要限制其只能包含数字、字母和基本符号，并将其他字符替换为下划线，其实现代码如下所示。

```python
import re
url = 'http://example.webscraping.com/default/view/Australia-1'
re.sub(r'[^/0-9a-zA-Z\-.,;_ ]', '_', filename)
# 'http_//example.webscraping.com/default/view/Australia-1'
```

文件名及其父目录的长度需要限制在 255 个字符以内，实现代码如下：

```python
filename = '/'.join(seg[:self.max_len] for seg in filename.split('/'))
```

还有一种边界情况需要考虑，那就是 URL 路径可能会以斜杠（/）结尾，此时斜杠后的空字符串就会成为一个非法的文件名。

+ http://example.webscraping.com/index/
+ http://example.webscraping.com/index/1

对于像第一个 URL 路径这样以斜杠结尾的情况，这里使用的解决方案是添加 index.html 作为其文件名。为了解析 URL，我们需要使用 urlparse.urlsplit() 函数，将 URL 分割成几个部分。

```python
import urlparse
components = urlparse.urlsplit('http://example.webscraping.com/index/')
print components
# SplitResult(scheme='http', netloc='example.webscraping.com', path='/index/', query='', fragment='')
print components.path
# '/index/'
```

下面是使用该模块对上述边界情况添加 index.html 的示例代码。

```python
path = components.path
if not path:
	path = '/index.html'
elif path.endswith('/'):
    path += 'index.html'
filename = components.netloc + path + components.query
print(filename)
# 'example.webscraping.com/index/index.html'
```

### 1. 实现

下面是 DiskCache 类的初始实现代码：

```python
import os
import json
import re
import zlib

from datetime import datetime, timedelta
from urllib.parse import urlsplit


class DiskCache:
    """ DiskCache helps store urls and their responses to disk
        Intialization components:
            cache_dir (str): abs file path or relative file path
                for cache directory (default: ../data/cache)
            max_len (int): maximum filename length (default: 255)
            compress (bool): use zlib compression (default: True)
            encoding (str): character encoding for compression (default: utf-8)
            expires (datetime.timedelta): timedelta when content will expire
                (default: 30 days ago)
    """
    def __init__(self, cache_dir='../data/cache', max_len=255, compress=True,
                 encoding='utf-8', expires=timedelta(days=30)):
        self.cache_dir = cache_dir
        self.max_len = max_len
        self.compress = compress
        self.encoding = encoding
        self.expires = expires

    def url_to_path(self, url):
        """ Return file system path string for given URL """
        components = urlsplit(url)
        # append index.html to empty paths
        path = components.path
        if not path:
            path = '/index.html'
        elif path.endswith('/'):
            path += 'index.html'
        filename = components.netloc + path + components.query
        # replace invalid characters
        filename = re.sub(r'[^/0-9a-zA-Z\-.,;_ ]', '_', filename)
        # restrict maximum number of characters
        filename = '/'.join(seg[:self.max_len] for seg in filename.split('/'))
        return os.path.join(self.cache_dir, filename)

    def __getitem__(self, url):
        """Load data from disk for given URL"""
        path = self.url_to_path(url)
        if os.path.exists(path):
            mode = ('rb' if self.compress else 'r')
            with open(path, mode) as fp:
                if self.compress:
                    data = zlib.decompress(fp.read()).decode(self.encoding)
                    data = json.loads(data)
                else:
                    data = json.load(fp)
            exp_date = data.get('expires')
            if exp_date and datetime.strptime(exp_date,
                                              '%Y-%m-%dT%H:%M:%S') <= datetime.utcnow():
                print('Cache expired!', exp_date)
                raise KeyError(url + ' has expired.')
            return data
        else:
            # URL has not yet been cached
            raise KeyError(url + ' does not exist')

    def __setitem__(self, url, result):
        """Save data to disk for given url"""
        path = self.url_to_path(url)
        folder = os.path.dirname(path)
        if not os.path.exists(folder):
            os.makedirs(folder)
        mode = ('wb' if self.compress else 'w')
        # Note: the timespec command requires Py3.6+ (if using 3.X you can
        # export using isoformat() and import with '%Y-%m-%dT%H:%M:%S.%f'
        result['expires'] = (datetime.utcnow() + self.expires).isoformat(
            timespec='seconds')
        with open(path, mode) as fp:
            if self.compress:
                data = bytes(json.dumps(result), self.encoding)
                fp.write(zlib.compress(data))
            else:
                json.dump(result, fp)
```

### 2. 缓存测试

我们可以通过执行如下脚本，使用链接爬虫测试磁盘缓存：

```shell
$ time python disk_cache.py
Downloading: http://example.webscraping.com
Downloading: http://example.webscraping.com/view/Afghanistan-1
...
Downloading: http://example.webscraping.com/view/Zimbabwe-252
23m38.289s
```

### 3. 节省磁盘空间

