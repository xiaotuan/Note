调用构造函数的一个重要特征是，构造函数的 `prototype` 属性被用作新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。

**示例代码：使用构造函数来定义 “范围类”**

```js
// 这是一个构造函数，用以初始化新创建的 "范围对象"
// 注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from, to) {
    // 存储 “范围对象” 的起始位置和结束位置（状态）
    // 这两个竖线是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}
// 所有的 “范围对象” 都继承自这个对象
// 注意，属性的名字必须是 "prototype"
Range.prototype = {
    // 如果 x 在范围内，则返回 true；否则返回 false
    // 这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes: function(x) {
        return this.from <= x && x <= this.to;
    },
    // 对于范围内的每个整数都调用一次 f
    // 这个方法只可用于数字范围
    foreach: function(f) {
        for (var x = Math.ceil(this.from); x <= this.to; x++) {
            f(x);
        }
    },
    // 返回表示这个范围的字符串
    toString: function() {
        return "(" + this.from + "..." + this.to + ")";
    }
};
// 这里是使用 “范围对象” 的一些例子
var r = new Range(1, 3);	// 创建一个范围对象
r.includes(2);	// => true; 2 在这个范围内
r.foreach(console.log);	// 输出 1 2 3 
console.log(r);	// 输出 (1...3)
```

> 注意：
>
> 首先，当工厂函数 `range()` 转化为构造函数时被重命名为 `Range()`。这里遵循了一个常见编程约定：从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。
>
> 再者，注意 `Range()` 构造函数是通过 `new` 关键字调用的，而 `range()` 工厂函数则不必使用 `new`。

`Range()` 构造函数只不过是初始化 this 而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。构造函数就是用来 “构造新对象” 的，它必须通过关键字 new 调用，如果将构造函数用做普通函数的话，往往不会正常工作。