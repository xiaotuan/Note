[toc]

### 1. 事件处理程序的参数

通常调用事件处理程序时把事件对象作为它们的一个参数（有一个例外，后面会介绍）。事件对象的属性提供了有关事件的详细信息。例如，`type` 属性指定了发生的事件类型。

在 IE8 及以前版本中，通过设置属性注册事件处理程序，当调用它们时并未传递事件对象。取而代之，需要通过全局对象 `window.event` 来获得事件对象。出于互通性，你能像如下那样编写事件处理程序，这样如果没有参数就使用 `window.event`：

```js
function handler(event) {
    event = event || window.event;
    // 处理程序代码出现在这里
}
```

向使用 `attachEvent()` 注册的事件处理程序传递事件对象，但它们也能使用 `window.event` 。

非IE浏览器使用 `event` 参数来构造函数，而IE在构造函数时没有要求参数。如果在这样的函数中使用 `event` 标识符，那么引用的正是 `window.event`。在这两种情况下，HTML 事件处理程序都能作为 `event` 引用事件对象。

### 2. 事件处理程序的运行环境

当通过设置属性注册事件处理程序时，这看起来好像是在文档元素上定义了新方法：

```js
e.onclick = function() { /* 处理程序代码 */ }
```

事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用并不出人意料。这就是说，在事件处理程序内，`this` 关键字指的是事件目标。

甚至当使用 `addEventListener()` 注册时，调用的处理程序使用事件目标作为它们的 `this` 值。但是，对于 `attachEvent()` 来讲这是不对的：使用 `attachEvent()` 注册的处理程序作为函数调用，它们的 `this` 值是全局（ `Window` ）对象。可以用如下代码来解决这个问题：

```js
/*
 * 在指定的事件目标上注册用于处理指定类型事件的指定处理程序函数
 * 确保处理程序一直作为事件目标的方法调用
 */
function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent("on" + type, function(event) {
            // 把处理程序作为事件目标的方法调用，
            // 传递事件对象
            return handler.call(target, event);
        });
    }
}
```

>   注意：使用这个方法注册的事件处理程序不能删除，因为传递给`attachEvent()` 的包装函数没有保留下来传递给 `detachEvent()`。
>

### 2. 事件处理程序的作用域

事件处理程序在其定义时的作用域而非调用时的作用域中执行，并且它们能存取那个作用域中的任何一个本地变量。

但是，通过 HTML 属性来注册事件处理程序是一个例外。它们被转换为能存取全局变量的顶级函数而非任何本地变量。但因为历史原因，它们运行在一个修改后的作用域链中。通过 HTML 属性定义的事件处理程序能好像本地变量一样使用目标对象、容器 `<form>` 对象（如果有）和 `Document` 对象的属性。

HTML 属性最不自然的地方包括冗长的代码串和修改后的作用域链允许有用的快捷方式。可以使用 `tagName` 替代 `this.tagName`，使用 `getElementById()` 替代 `document.getElementById()`。并且，对于  `<form>` 中的文档元素，能通过 ID 引用任何其他的表单元素，例如，用 zipcode 替代 this.form.zipcode。

