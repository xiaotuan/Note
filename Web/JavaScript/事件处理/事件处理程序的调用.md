[toc]

### 1. 事件处理程序的参数

通常调用事件处理程序时把事件对象作为它们的一个参数（有一个例外，后面会介绍）。事件对象的属性提供了有关事件的详细信息。例如，`type` 属性指定了发生的事件类型。

在 IE8 及以前版本中，通过设置属性注册事件处理程序，当调用它们时并未传递事件对象。取而代之，需要通过全局对象 `window.event` 来获得事件对象。出于互通性，你能像如下那样编写事件处理程序，这样如果没有参数就使用 `window.event`：

```js
function handler(event) {
    event = event || window.event;
    // 处理程序代码出现在这里
}
```

向使用 `attachEvent()` 注册的事件处理程序传递事件对象，但它们也能使用 `window.event` 。

非IE浏览器使用 `event` 参数来构造函数，而IE在构造函数时没有要求参数。如果在这样的函数中使用 `event` 标识符，那么引用的正是 `window.event`。在这两种情况下，HTML 事件处理程序都能作为 `event` 引用事件对象。

### 2. 事件处理程序的运行环境

当通过设置属性注册事件处理程序时，这看起来好像是在文档元素上定义了新方法：

```js
e.onclick = function() { /* 处理程序代码 */ }
```

事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用并不出人意料。这就是说，在事件处理程序内，`this` 关键字指的是事件目标。

甚至当使用 `addEventListener()` 注册时，调用的处理程序使用事件目标作为它们的 `this` 值。但是，对于 `attachEvent()` 来讲这是不对的：使用 `attachEvent()` 注册的处理程序作为函数调用，它们的 `this` 值是全局（ `Window` ）对象。可以用如下代码来解决这个问题：

```js
/*
 * 在指定的事件目标上注册用于处理指定类型事件的指定处理程序函数
 * 确保处理程序一直作为事件目标的方法调用
 */
function addEvent(target, type, handler) {
    if (target.addEventListener) {
        target.addEventListener(type, handler, false);
    } else {
        target.attachEvent("on" + type, function(event) {
            // 把处理程序作为事件目标的方法调用，
            // 传递事件对象
            return handler.call(target, event);
        });
    }
}
```

>   注意：使用这个方法注册的事件处理程序不能删除，因为传递给`attachEvent()` 的包装函数没有保留下来传递给 `detachEvent()`。
>

### 2. 事件处理程序的作用域

事件处理程序在其定义时的作用域而非调用时的作用域中执行，并且它们能存取那个作用域中的任何一个本地变量。

但是，通过 HTML 属性来注册事件处理程序是一个例外。它们被转换为能存取全局变量的顶级函数而非任何本地变量。但因为历史原因，它们运行在一个修改后的作用域链中。通过 HTML 属性定义的事件处理程序能好像本地变量一样使用目标对象、容器 `<form>` 对象（如果有）和 `Document` 对象的属性。

HTML 属性最不自然的地方包括冗长的代码串和修改后的作用域链允许有用的快捷方式。可以使用 `tagName` 替代 `this.tagName`，使用 `getElementById()` 替代 `document.getElementById()`。并且，对于  `<form>` 中的文档元素，能通过 ID 引用任何其他的表单元素，例如，用 zipcode 替代 this.form.zipcode。

另一方面，`HTML` 事件处理程序中修改的作用域链是陷阱之源，因为作用域链中每个对象的属性在全局对象中都有相同名字的属性。例如，由于 `Document` 对象定义 `open()` 方法，因此 `HTMl` 事件处理程序想调用 `Window` 对象的 `open()` 方法就必须显式地写 `window.open` 而不是 `open`。

### 3. 事件处理程序的返回值

通过设置对象属性或 `HTML` 属性注册事件处理程序的返回值有时是非常有意义的。通常情况下，返回值 `false` 就是告诉浏览器不要执行这个事件相关的默认操作。例如，表单提交按钮的 `onclick` 事件处理程序能返回 `false` 阻止浏览器提交表单。

`Window` 对象的 `onbeforeunload` 事件处理程序的返回值也非常有意义。当浏览器将要跳转到新页面时触发这个事件。如果事件处理程序返回一个字符串，那么它将出现在询问用户是否想离开当前页面的标准对话框中。

理解事件处理程序的返回值只对通过属性注册的处理程序才有意义这非常重要。接下来我们将看到使用 `addEventListener()` 或 `attachEvent()` 注册事件处理程序转而必须调用 `preventDefault()` 方法或设置事件对象的 `returnValue` 属性。

### 4. 调用顺序

文档元素或其他对象可以为指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照如下规定调用所有的事件处理程序：

+ 通过设置对象属性或 `HTML` 属性注册的处理程序一直优先调用。
+ 使用 `addEventListener()` 注册的处理程序按照它们的注册顺序调用。
+ 使用 `attachEvent()` 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。

### 5. 事件传播

当事件目标是 `Window` 对象或其他一些单独对象（比如 `XMLHttpRequest`）时，浏览器简单地通过调用对象上适当的处理程序响应事件。当事件目标是文档或文档元素时，情况比较复杂。

在调用在目标元素上注册的事件处理函数后，大部分事件会 "冒泡" 到 `DOM` 树根。调用目标的父元素的事件处理程序，然后调用在目标的祖父元素上注册的事件处理程序。这会一直到 `Document` 对象，最后到达 `Window` 对象。事件冒泡为在大量单独文档元素上注册处理程序提供了替代方案，即在共同的祖先元素上注册一个处理程序来处理所有的事件。例如，可以在 `<form>` 元素上注册 `change` 事件处理程序来取代在表单的每个元素上注册 `change` 事件处理程序。

发生在文档元素上的大部分事件都会冒泡，值得注意的例外是 `focus`、`blur` 和 `scroll` 事件。文档元素上的 `load` 事件会冒泡，但它会在 `Document` 对象上停止冒泡而不会传播到 `Window` 对象。只有当整个文档都加载完毕时才会触发 `Window` 对象的 `load` 事件。

事件传播的捕获阶段像反向的冒泡阶段。最先调用 `Window` 对象的捕获处理程序，然后是 `Document` 对象的捕获处理程序，接着是 `body` 对象的，再然后是 `DOM` 树向下，以此类推，直到调用事件目标的父元素的捕获事件处理程序。在目标对象本身上注册的捕获事件处理程序不会被调用。

### 6. 事件取消

在支持 `addEventListener()` 的浏览器中，也能通过调用事件对象的 `preventDefault()` 方法取消事件的默认操作。不过，在 `IE9` 之前的 `IE` 中，可以通过设置事件对象的 `returnValue` 属性为 `false` 来达到同样的效果。下面的代码假设一个事件处理程序，它使用全部三种取消技术：

```js
function cancelHandler(event) {
    var event = event || window.event;	// 用于 IE
    /* 这里是处理事件的代码 */
    // 现在取消事件相关的默认行为
    if (event.preventDefault) event.preventDefault();	// 标准技术
    if (event.returnValue) event.returnValue = false;	// IE 
    return false;	// 用于处理使用对象属性注册的处理程序
}
```

取消事件相关的默认操作只是事件取消中的一种，我们也可能取消事件传播。在支持 `addEventListener()` 的浏览器中，可以调用事件对象的一个 `stopPropagation()` 方法以阻止事件的继续传播。如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用 `stopPropagation()` 之后任何其他对象上的事件处理程序将不会被调用。`stopPropagation()` 方法可以在事件传播期间的任何时间调用。它能工作捕获期阶段、事件目标本身中和冒泡阶段。

`IE9` 之前的 `IE` 不支持 `stopPropagation()` 方法。相反，`IE` 事件对象有一个 `cancelBubble` 属性，设置这个属性为 `true` 能阻止事件进一步传播。（`IE8` 及之前版本不支持事件传播的捕获阶段，所以冒泡是唯一待取消的事件传播。）

当前的 `DOM` 事件规范草案在 `Event` 对象上定义另一个方法，命名为 `stopImmediatePropagation()`。类似 `stopPropagation()`，这个方法阻止了任何其他对象的事件传播，但也阻止了在相同对象上注册的任何其他事件处理程序的调用。
