[toc]

一个 Web 浏览器窗口可能在桌面上包含多个标签页。每一个标签页都是独立的 “浏览上下文” （browsing context），每一个上下文都有独立的 Window 对象，而且相互之间互不干扰。每个标签页中运行的脚本通常并不知道其他标签页的存在，更不用说和其他标签页的 `Window` 对象进行交互操作或者操作其他文档内容了。

但是窗口并不总是和其他窗口完全没有关系。一个窗口或标签页中的脚本可以打开新的窗口或标签页，当一个脚本这样做时，这样多个窗口或窗口与另一个窗口的文档之间就可以互操作。

HTML 文档经常使用 `<iframe>` 来嵌套多个文档。由 `<iframe>` 所创建的嵌套浏览上下文是用它自己的 `Window` 对象所表示的。对于客户端 `JavaScript` 来说，窗口、标签页、iframe 和框架都是浏览上下文；对于 `JavaScript` 来说，它们都是 `Window` 对象。和相互独立的标签页不同，嵌套的浏览上下文之间并不是相互独立的。在一个窗体中运行的 JavaScript 程序总是可以看到它的祖先和子孙窗体，尽管脚本查看这些窗体中的文档受到同源策略的限制。

因为 Window 是客户端 JavaScript 的全局对象，每个窗口或窗体都包含独立的 JavaScript 执行上下文。不过，在一个窗口中的 JavaScript 代码，如果有同源策略的限制，则可以使用另外一个窗口中定义的对象、属性和方法。

### 1. 打开和关闭窗口

使用 Window 对象的 `open()` 方法可以打开一个新的浏览器窗口。`Window.open()` 载入指定的 URL 到新的或已存在的窗口中，并返回代表那个窗口的 Window 对象。它有 4 个可选的参数。

`open()` 的第一个参数是要在新窗口中显示的文档的 URL。如果这个参数省略了（也可以是空字符串），那么会使用空页面的 URL `about: blank`。

`open()` 的第二个参数是新打开的窗口的名字。如果指定的是一个已存在的窗口的名字，会直接使用已存在的窗口。否则，会打开新的窗口，并将这个指定的名字赋值给它。如果省略此参数，会使用指定的名字 `_blank` 打开一个新的、未命名的窗口。

> 注意：脚本是无法通过简单地猜测窗口的名字来操控这个窗口中的 Web 应用的，只有设置了 “允许导航” 的页面才可以这样。宽泛地讲，当且仅当窗口包含的文档来自相同的源或者是这个脚本打开了那个窗口（或者递归地打开了窗口中打开的窗口），脚本才可以只通过名字来指定存在的窗口。还有，如果其中一个窗口是内嵌在另一个窗口里的窗体，那么在它们的脚步之间就可以相互导航。这种情况下，可以使用名字 `_top` （顶级祖先窗口）和 `_parent` （直接父级窗口）来获取彼此的浏览上下文。

窗口的名字是非常重要的，因为它允许 `open()` 方法引用已存在的窗口，并同时可以作为 `<a>` 和 `<form>` 元素上 HTML target 属性的值，用来表示引用的文档（或表单提交结果）应该显示在命名的窗口中。这个 `target` 属性的值可以设置为 `_blank`、`_parent` 或 `_top`，从而使引用的文档显示在新的空白窗口、父窗口、窗体或顶层窗口中。

Window 对象如果有 `name` 属性，就用它保存名字。该属性是可写的，并且脚本可以随意设置它。如果传递给 `window.open()` 一个除 `_blank` 之外的名字，通过该调用创建的窗口将以该名字作为 `name` 属性的初始值。如果 `<iframe>` 元素有 `name` 属性，表示该 `iframe` 的 `Window` 对象会用它作为 `name` 属性的初始值。

`open()` 的第三个可选参数是一个以逗号分隔的列表，包含大小和各种属性，用以表明新窗口是如何打开的。如果省略这个参数，那么新窗口就会用一个默认的大小，而且带有一整组标准的 UI 组件，即菜单栏、状态栏、工具栏等。

另一方面，如果指定这个参数，就可以指定窗口的尺寸，以及它包含的一组属性。（显式指定窗口尺寸更像是创建新窗口，而不是新标签。）

```js
var w = window.open("smallwin.html", "smallwin", "width=400,height=350,status=yes,resizable=yes");
```

`open()` 的第四个参数只在第二个参数命名的是一个存在的窗口时才有用。它是一个布尔值，声明了由第一个参数指定的 URL 是应用替换掉窗口浏览历史的当前条目（true），还是应该在窗口浏览历史中创建一个新的条目（false），后者是默认的设置。HTML5 规范主张浏览器应该忽略它。

`open()` 的返回值是代表命名或新创建的窗口的 Window 对象。可以在自己的 `JavaScript` 代码中使用这个 `Window` 对象来引用新创建的窗口，就像使用隐式的 Window 对象 window 来引用运行代码的窗口一样：

```js
var w = window.open();	// 打开一个新的空白窗口
w.alert("About to visit http://example.com");	// 调用 alert() 方法
w.location = "http://example.com";	// 设置它的 location 属性
```

在由 `window.open()` 方法创建的窗口中，`opener` 属性引用的是打开它的脚本的 Window 对象。在其他窗口中，`opener` 为 null：

```js
w.opener !== null;	// true,对于由 w 创建的任意窗口
w.open().opener === w;	// true，对于任意窗口 w
```

`Window.open()` 是广告商用来在你浏览网页时采用的 “页面之前弹出” 或 “页面之后弹出” 窗口的一种方法。由于对于这种烦人的弹出窗口的滥用，因此大部分浏览器增加了弹出窗口过滤系统。通常，`open()` 方法只有当用户手动单击按钮或者链接的时候才会调用。JavaScript 代码尝试在浏览器初始载入（或卸载）时开启一个弹出窗口时，通常会失败。

### 2. 关闭窗口

方法 `close()` 将关闭一个窗口。如果已经创建了 `Window` 对象 w，可以使用如下的代码将它关掉：

```js
w.close();
```

> 注意：要显示地使用标识符 window，这样可以避免混淆 Window 对象的 `close()` 方法和 Document 对象的 `close()`方法。

大多数浏览器只允许自动关闭由自己的 JavaScript 代码创建的窗口。如果要关闭其他窗口，可以用一个对话框提示用户，要求他对关闭窗口的请求进行确认（或取消）。在表示窗体而不是顶级窗口或标签页上的 Window 对象上执行 `close()` 方法不会有任何效果，它不能关闭一个窗体（反之可以从它包含的文档中删除 iframe）。

即时一个窗口关闭了，代表它的 Window 对象仍然存在。已关闭的窗口会有个值为 true 的 `closed` 属性，它的 `document` 会是 null，它的方法通常也不会再工作。

### 3. 窗体之间的关闭

任何窗口或窗体中的 JavaScript 代码都可以将自己的窗口和窗体引用为 `window` 或 `self`。窗体可以用 `parent` 属性引用包含它的窗口或窗体的 Window 对象：

```js
parent.history.back();
```

如果一个窗口是顶级窗口或标签，而不是窗体，那么其 `parent` 属性引用的就是这个窗口本身：

```js
parent === self;	// 只有顶级窗口才会返回 true
```

如果一个窗口包含在另一个窗体中，而后者又包含在顶级窗口中，那么该窗体就可以使用 `parent.parent` 来引用顶级窗口。`top` 属性是一个通用的快捷方式，无论一个窗体嵌套了几层，它的 `top` 属性引用的都是指向包含它的顶级窗口。如果一个 `Window` 对象代表的是一个顶级窗口，那么它的 `top` 属性引用的就是窗口本身。

可以用获取其他元素的方法来获取一个表示 `<iframe>` 的元素对象。假定文档里有 `<iframe id="f1">`。那么，表示该 iframe 的元素对象就是：

```js
var iframeElement = document.getElementById("f1");
```

`<iframe>` 元素有 `contentWindow` 属性，引用该窗体的 Window 对象，所以次窗体的 Window 对象就是：

```js
var childFrame = document.getElementById("f1").contentWindow;
```

可以反向操作——从表示窗体的 Window 对象来获取该窗体的 `<iframe>` 元素——用 Window 对象的 `frameElement` 属性。表示顶级窗口的 Window 对象的 `frameElement` 属性为 null，窗体中的 Window 对象的 `frameElement` 属性不是 null：

```js
var elt = document.getElementById("f1");
var win = elt.contentWindow;
win.frameElement === elt;	// 对于帧来说永远是 true
window.frameElement === null;	// 对于顶级窗口来说永远是 true
```

每个 `Window` 对象都有一个 `frames` 属性，它引用自身包含的窗口或窗体的子窗体。`frames` 属性引用的是类数组对象，并可以通过数字或窗体名进行索引。

> 注意：`frames[]` 数组里的元素是 Window 对象，而不是 `<iframe>` 元素。

如果指定 `<iframe>` 元素的 `name` 或 `id` 属性，那么除了用数字进行索引之外，还可以用名字来进行索引。例如，名字为 "f1" 的帧应该用 `frames["f1"]` 或 `frames.f1`。

### 4. 交互窗口中的 JavaScript

设想一个 Web 页面里有两个 `<iframe>` 元素，分别叫 "A" 和 "B"，并假设这些窗体所包含的文档来自相同的一个服务器，并且包含交互脚本。窗口 A 里的脚步定义了一个变量 i：

```js
var i = 3;
```

这个变量只是全局对象的一个属性，也是 Window 对象的一个属性。窗体 A 中的代码可以用标识符 i 来引用变量，或者用 window 对象显示地引用这个变量：

```js
window.i
```

由于窗体 B 中的脚步可以引用窗体 A 的 Window 对象，因此它也可以引用那个 Window 对象的属性：

```js
parent.A.i = 4;	// 改变窗体 A 中的变量 i 的值
```

调用其他窗口的方法也是一样的，同时也可以为其他窗口创建变量，例如：

```js
var s = new parent.Set();
```

和用户定义的类不同，内置的类（比如 `String`，`Date` 和 `RegExp`）都会在所有的窗口中自动预定义。但是要注意，每个窗口都有构造函数的一个独立副本的构造函数对应原型对象的一个独立副本。例如，每个窗口都有自己的 `String()` 构造函数和 `String.prototype` 对象的副本。因此，如果编写一个操作 JavaScript 字符串的新方法，并且通过把它赋值给当前窗口的 `String.prototype` 对象而使它成为 `String` 类的一个方法，那么该窗口中的所有字符串就都可以使用这个方法。但是，别的窗口中定义的字符串不能使用这个新方法。