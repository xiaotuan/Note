#### 14.6.1　声明和初始化结构指针

声明结构指针很简单：

```c
struct guy * him;
```

首先是关键字 `struct` ，其次是结构标记 `guy` ，然后是一个星号（*），其后跟着指针名。这个语法和其他指针声明一样。

该声明并未创建一个新的结构，但是指针 `him` 现在可以指向任意现有的 `guy` 类型的结构。例如，如果 `barney` 是一个 `guy` 类型的结构变量，可以这样写：

```c
him = &barney;
```

和数组不同的是，结构变量名并不是结构变量的地址，因此要在结构变量名前面加上 `&` 运算符。

在本例中， `fellow` 是一个结构数组，这意味着 `fellow[0]` 是一个结构。所以，要让 `him` 指向 `fellow[0]` ，可以这样写：

```c
him = &fellow[0];
```

输出的前两行说明赋值成功。比较这两行发现， `him` 指向 `fellow[0]` ， `him + 1` 指向 `fellow[1]` 。注意， `him` 加 `1` 相当于 `him` 指向的地址加 `84` 。在十六进制中， `874 - 820 = 54` （十六进制） `= 84` （十进制），因为每个 `guy` 结构都占用 `84` 字节的内存： `names.first` 占用 `20` 字节， `names.last` 占用 `20` 字节， `favfood` 占用 `20` 字节， `job` 占用 `20` 字节， `income` 占用 `4` 字节（假设系统中 `float` 占用 `4` 字节）。顺带一提，在有些系统中，一个结构的大小可能大于它各成员大小之和。这是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必须把每个成员都放在偶数地址上，或 `4` 的倍数的地址上。在这种系统中，结构的内部就存在未使用的“缝隙”。

