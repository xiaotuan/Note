#### 14.8.2　程序要点

首先，以 `"a+b"` 模式打开文件。 `a+` 部分允许程序读取整个文件并在文件的末尾添加内容。 `b` 是ANSI的一种标识方法，表明程序将使用二进制文件格式。对于不接受 `b` 模式的UNIX系统，可以省略 `b` ，因为UNIX只有一种文件形式。对于早期的ANSI实现，要找出和 `b` 等价的表示法。

我们选择二进制模式是因为 `fread()` 和 `fwrite()` 函数要使用二进制文件。虽然结构中有些内容是文本，但是 `value` 成员不是文本。如果使用文本编辑器查看 `book.dat` ，该结构本文部分的内容显示正常，但是数值部分的内容不可读，甚至会导致文本编辑器出现乱码。

`rewind()` 函数确保文件指针位于文件开始处，为读文件做好准备。

第1个 `while` 循环每次把一个结构读到结构数组中，当数组已满或读完文件时停止。变量 `filecount` 统计已读结构的数量。

第2个 `while` 循环提示用户进行输入，并接受用户的输入。和程序清单14.2一样，当数组已满或用户在一行的开始处按下Enter键时，循环结束。注意，该循环开始时 `count` 变量的值是第1个循环结束后的值。该循环把新输入项添加到数组的末尾。

然后 `for` 循环打印文件和用户输入的数据。因为该文件是以附加模式打开，所以新写入的内容添加到文件现有内容的末尾。

我们本可以用一个循环在文件末尾一次添加一个结构，但还是决定用 `fwrite()` 一次写入一块数据。对表达式 `count - filecount` 求值得新添加的书籍数量，然后调用 `fwrite()` 把结构大小的块写入文件。由于表达式 `&library[filecount]` 是数组中第1个新结构的地址，所以拷贝就从这里开始。

也许该例是把结构写入文件和检索它们的最简单的方法，但是这种方法浪费存储空间，因为这还保存了结构中未使用的部分。该结构的大小是 `2` × `40` × `sizeof(char)+sizeof(float)` ，在我们的系统中共84字节。实际上不是每个输入项都需要这么多空间。但是，让每个输入块的大小相同在检索数据时很方便。

另一个方法是使用可变大小的记录。为了方便读取文件中的这种记录，每个记录以数值字段规定记录的大小。这比上一种方法复杂。通常，这种方法涉及接下来要介绍的“链式结构”和第12章的动态内存分配。

