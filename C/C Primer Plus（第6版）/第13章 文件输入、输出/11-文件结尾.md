#### 13.2.4　文件结尾

从文件中读取数据的程序在读到文件结尾时要停止。如何告诉程序已经读到文件结尾？如果 `getc()` 函数在读取一个字符时发现是文件结尾，它将返回一个特殊值 `EOF` 。所以C程序只有在读到超过文件末尾时才会发现文件的结尾（一些其他语言用一个特殊的函数在读取之前测试文件结尾，C语言不同）。

为了避免读到空文件，应该使用入口条件循环（不是 `do` 　 `while` 循环）进行文件输入。鉴于 `getc()` （和其他C输入函数）的设计，程序应该在进入循环体之前先尝试读取。如下面设计所示：

```c
// 设计范例 #1
int ch;               // 用int类型的变量存储EOF
FILE * fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp);        // 获取初始输入
while (ch != EOF)
{
     putchar(ch);     // 处理输入
     ch = getc(fp);   // 获取下一个输入
}
```

以上代码可简化为：

```c
// 设计范例 #2
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (( ch = getc(fp)) != EOF)
{
     putchar(ch);    //处理输入
}
```

由于 `ch = getc(fp)` 是 `while` 测试条件的一部分，所以程序在进入循环体之前就读取了文件。不要设计成下面这样：

```c
// 糟糕的设计（存在两个问题）
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (ch != EOF)      // 首次使用ch时，它的值尚未确定
{
     ch = getc(fp);    // 获取输入
     putchar(ch);      // 处理输入
}
```

第1个问题是， `ch` 首次与 `EOF` 比较时，其值尚未确定。第2个问题是，如果 `getc()` 返回 `EOF` ，该循环会把 `EOF` 作为一个有效字符处理。这些问题都可以解决。例如，把 `ch` 初始化为一个哑值（dummy value），再把一个 `if` 语句加入到循环中。但是，何必多此一举，直接使用上面的设计范例即可。

其他输入函数也会用到这种处理方案，它们在读到文件结尾时也会返回一个错误信号（ `EOF` 或 `NULL` 指针）。

