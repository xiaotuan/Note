#### 11.5.7　其他字符串函数

ANSI C库有20多个用于处理字符串的函数，下面总结了一些常用的函数。

+ `char`  * `strcpy(char`  *  `restrict s1, const char`  *  `restrict s2);`
+ 该函数把 `s2` 指向的字符串（包括空字符）拷贝至 `s1` 指向的位置，返回值是 `s1` 。
+ `char`  * `strncpy(char`  *  `restrict s1, const char`  *  `restrict s2, size_t n);`
+ 该函数把 `s2` 指向的字符串拷贝至 `s1` 指向的位置，拷贝的字符数不超过 `n` ，其返回值是 `s1` 。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于 `n` 个，目标字符串就以拷贝的空字符结尾；如果源字符串有 `n` 个或超过 `n` 个字符，就不拷贝空字符。
+ `char`  * `strcat(char`  *  `restrict s1, const char`  *  `restrict s2);`
+ 该函数把 `s2` 指向的字符串拷贝至 `s1` 指向的字符串末尾。 `s2` 字符串的第 `1` 个字符将覆盖 `s1` 字符串末尾的空字符。该函数返回 `s1` 。
+ `char`  * `strncat(char`  *  `restrict s1, const char`  *  `restrict s2, size_t n);`
+ 该函数把 `s2` 字符串中的 `n` 个字符拷贝至 `s1` 字符串末尾。 `s2` 字符串的第 `1` 个字符将覆盖 `s1` 字符串末尾的空字符。不会拷贝 `s2` 字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回 `s1` 。
+ `int strcmp(const char`  *  `s1, const char`  *  `s2);`
+ 如果 `s1` 字符串在机器排序序列中位于 `s2` 字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回0；如果 `s1` 字符串在机器排序序列中位于 `s2` 字符串的前面，则返回一个负数。
+ `int strncmp(const char`  *  `s1, const char`  *  `s2, size_t n);`
+ 该函数的作用和 `strcmp()` 类似，不同的是，该函数在比较 `n` 个字符后或遇到第 `1` 个空字符时停止比较。
+ `char *strchr(const char * s, int c);`
+ 如果 `s` 字符串中包含 `c` 字符，该函数返回指向 `s` 字符串首次出现的 `c` 字符的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串 `s` 中未找到 `c` 字符，该函数则返回空指针。
+ `char`  * `strpbrk(const char`  *  `s1, const char`  *  `s2);`
+ 如果 `s1` 字符中包含 `s2` 字符串中的任意字符，该函数返回指向 `s1` 字符串首位置的指针；如果在 `s1` 字符串中未找到任何 `s2` 字符串中的字符，则返回空字符。
+ `char *strrchr(const char * s, char c);`
+ 该函数返回 `s` 字符串中 `c` 字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到 `c` 字符，则返回空指针。
+ `char *strstr(const char * s1, const char * s2);`
+ 该函数返回指向 `s1` 字符串中 `s2` 字符串出现的首位置。如果在 `s1` 中没有找到 `s2` ，则返回空指针。
+ `size_t strlen(const char * s);`
+ 该函数返回 `s` 字符串中的字符数，不包括末尾的空字符。

请注意，那些使用 `const` 关键字的函数原型表明，函数不会更改字符串。例如，下面的函数原型：

```c
char *strcpy(char * restrict s1, const char * restrict s2);
```

表明不能更改 `s2` 指向的字符串，至少不能在 `strcpy()` 函数中更改。但是可以更改 `s1` 指向的字符串。这样做很合理，因为 `s1` 是目标字符串，要改变，而 `s2` 是源字符串，不能更改。

关键字 `restrict` 将在第12章中介绍，该关键字限制了函数参数的用法。例如，不能把字符串拷贝给本身。

第5章中讨论过， `size_t` 类型是 `sizeof` 运算符返回的类型。C规定 `sizeof` 运算符返回一个整数类型，但是并未指定是哪种整数类型，所以 `size_t` 在一个系统中可以是 `unsigned int` ，而在另一个系统中可以是 `unsigned long` 。 `string.h` 头文件针对特定系统定义了 `size_t` ，或者参考其他有size_t定义的头文件。

前面提到过，参考资料V中列出了 `string.h` 系列的所有函数。除提供ANSI标准要求的函数外，许多实现还提供一些其他函数。应查看你所使用的C实现文档，了解可以使用哪些函数。

我们来看一下其中一个函数的简单用法。前面学过的 `fgets()` 读入一行输入时，在目标字符串的末尾添加换行符。我们自定义的 `s_gets()` 函数通过 `while` 循环检测换行符。其实，这里可以用 `strchr()` 代替 `s_gets()` 。首先，使用 `strchr()` 查找换行符（如果有的话）。如果该函数发现了换行符，将返回该换行符的地址，然后便可用空字符替换该位置上的换行符：

```c
char line[80];
char * find;
fgets(line, 80, stdin);
find = strchr(line, '\n');    // 查找换行符
if (find)                     // 如果没找到换行符，返回NULL
     *find = '\0';            // 把该处的字符替换为空字符
```

如果 `strchr()` 未找到换行符， `fgets()` 在达到行末尾之前就达到了它能读取的最大字符数。可以像在 `s_gets()` 中那样，给 `if` 添加一个 `else` 来处理这种情况。

接下来，我们看一个处理字符串的完整程序。

