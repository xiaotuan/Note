#### 10.1.2　指定初始化器（C99）

C99增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：

```c
int arr[6] = {0,0,0,0,0,212}; // 传统的语法
```

而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：

```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
```

对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为 `0` 。程序清单10.5中的初始化比较复杂。

程序清单10.5　 `designate.c` 程序

```c
// designate.c -- 使用指定初始化器
#include <stdio.h>
#define MONTHS 12
int main(void)
{
     int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
     int i;
     for (i = 0; i < MONTHS; i++)
          printf("%2d  %d\n", i + 1, days[i]);
     return 0;
}
```

该程序在支持C99的编译器中输出如下：

```c
 1    31
 2    29
 3    0
 4    0
 5    31
 6    30
 7    31
 8    0
 9    0
10    0
11    0
12    0
```

以上输出揭示了指定初始化器的两个重要特性。第一，如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段： `[4] = 31,30,31` ，那么后面这些值将被用于初始化指定元素后面的元素。也就是说，在 `days[4]` 被初始化为 `31` 后， `days[5]` 和 `days[6]` 将分别被初始化为 `30` 和 `31` 。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把 `days[1]` 初始化为 `28` ，但是 `days[1]` 又被后面的指定初始化 `[1] = 29` 初始化为 `29` 。

如果未指定元素大小会怎样？

```c
int stuff[] = {1, [6] = 23};          //会发生什么？
int staff[] = {1, [6] = 4, 9, 10};    //会发生什么？
```

编译器会把数组的大小设置为足够装得下初始化的值。所以， `stuff` 数组有7个元素，编号为0～6；而 `staff` 数组的元素比 `stuff` 数组多两个（即有9个元素）。

