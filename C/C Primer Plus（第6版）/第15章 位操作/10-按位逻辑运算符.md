#### 15.3.1　按位逻辑运算符

4个按位逻辑运算符都用于整型数据，包括 `char` 。之所以叫作按位（bitwise）运算，是因为这些操作都是针对每一个位进行，不影响它左右两边的位。不要把这些运算符与常规的逻辑运算符（ `&&` 、 `||` 和！）混淆，常规的逻辑运算符操作的是整个值。

#### 1．二进制反码或按位取反：～

一元运算符～把 `1` 变为 `0` ，把 `0` 变为 `1` 。如下例子所示：

```c
～(10011010)  // 表达式
(01100101)    // 结果值
```

假设 `val` 的类型是 `unsigned char` ，已被赋值为 `2` 。在二进制中， `00000010` 表示 `2` 。那么，～ `val` 的值是 `11111101` ，即 `253` 。注意，该运算符不会改变 `val` 的值，就像 `3`  *  `val` 不会改变 `val` 的值一样， `val` 仍然是 `2` 。但是，该运算符确实创建了一个可以使用或赋值的新值：

```c
newval = ～val;
printf("%d", ～val);
```

如果要把 `val` 的值改为～ `val` ，使用下面这条语句：

```c
val = ～val;
```

#### 2．按位与： `&` 

二元运算符 `&` 通过逐位比较两个运算对象，生成一个新值。对于每个位，只有两个运算对象中相应的位都为 `1` 时，结果才为 `1` （从真 `/` 假方面看，只有当两个位都为真时，结果才为真）。因此，对下面的表达式求值：

```c
(10010011) & (00111101)    // 表达式
```

由于两个运算对象中编号为4和0的位都为1，得：

```c
(00010001)    // 结果值
```

C有一个按位与和赋值结合的运算符： `&=` 。下面两条语句产生的最终结果相同：

```c
val &= 0377;
val = val & 0377;
```

#### 3．按位或： `|` 

二元运算符 `|` ，通过逐位比较两个运算对象，生成一个新值。对于每个位，如果两个运算对象中相应的位为 `1` ，结果就为 `1` （从真 `/` 假方面看，如果两个运算对象中相应的一个位为真或两个位都为真，那么结果为真）。因此，对下面的表达式求值：

```c
(10010011) | (00111101) // 表达式
```

除了编号为6的位，这两个运算对象的其他位至少有一个位为1，得：

```c
(10111111) // 结果值
```

`C` 有一个按位或和赋值结合的运算符： `|=` 。下面两条语句产生的最终作用相同：

```c
val |= 0377;
val = val | 0377;
```

#### 4．按位异或： `^` 

二元运算符 `^` 逐位比较两个运算对象。对于每个位，如果两个运算对象中相应的位一个为 `1` （但不是两个为 `1` ），结果为 `1` （从真 `/` 假方面看，如果两个运算对象中相应的一个位为真且不是两个为同为 `1` ，那么结果为真）。因此，对下面表达式求值：

```c
(10010011) ^ (00111101) // 表达式
```

编号为 `0` 的位都是 `1` ，所以结果为 `0` ，得：

```c
(10101110)    // 结果值
```

`C` 有一个按位异或和赋值结合的运算符： `^=` 。下面两条语句产生的最终作用相同：

```c
val ^= 0377;
val = val ^ 0377;
```

