#### 12.4.1　 `free()` 的重要性

静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用 `free()` 进行释放。例如，假设有一个创建数组临时副本的函数，其代码框架如下：

```c
...
int main()
{
     double glad[2000];
     int i;
     ...
     for (i = 0; i < 1000; i++)
          gobble(glad, 2000);
     ...
}
void gobble(double ar[], int n)
{
     double * temp = (double *) malloc( n * sizeof(double));
     ... /* free(temp); // 假设忘记使用free() */
}
```

第1次调用 `gobble()` 时，它创建了指针 `temp` ，并调用 `malloc()` 分配了16000字节的内存（假设 `double` 为8字节）。假设如代码注释所示，遗漏了 `free()` 。当函数结束时，作为自动变量的指针 `temp` 也会消失。但是它所指向的16000字节的内存却仍然存在。由于 `temp` 指针已被销毁，所以无法访问这块内存，它也不能被重复使用，因为代码中没有调用 `free()` 释放这块内存。

第2次调用 `gobble()` 时，它又创建了指针 `temp` ，并调用 `malloc()` 分配了16000字节的内存。第1次分配的16000字节内存已不可用，所以 `malloc()` 分配了另外一块16000字节的内存。当函数结束时，该内存块也无法被再访问和再使用。

循环要执行1000次，所以在循环结束时，内存池中有1600万字节被占用。实际上，也许在循环结束之前就已耗尽所有的内存。这类问题被称为内存泄漏（memory leak）。在函数末尾处调用 `free()` 函数可避免这类问题发生。

