### A.5　第5章复习题答案

1．a． `30`

b． `27` （不是 `3` ）。 `(12+6)/(2` * `3)` 得 `3` 。

c． `x = 1` ， `y = 1` （整数除法）。

d． `x = 3` （整数除法）， `y = 9` 。

2．a． `6` （由 `3 + 3.3` 截断而来）

b． `52`

c． `0` （ `0`  *  `22.0` 的结果）

d． `13` （ `66.0 / 5` 或 `13.2` ，然后把结果赋给 `int` 类型变量）

3．a． `37.5` （ `7.5`  *  `5.0` 的结果）

b． `1.5` （ `30.0 / 20.0` 的结果）

c． `35` （ `7`  *  `5` 的结果）

d． `37` （ `150 / 4` 的结果）

e． `37.5` （ `7.5`  *  `5` 的结果）

f． `35.0` （ `7`  *  `5.0` 的结果）

4．第 `0` 行：应增加一行 `#include <stdio.h>` 。

第3行：末尾用分号，而不是逗号。

第6行： `while` 语句创建了一个无限循环。因为 `i` 的值始终为 `1` ，所以它总是小于 `30` 。推测一下，应该是想写 `while(i++ < 30)` 。

第6～8行：这样的缩进布局不能使第 `7` 行和第 `8` 行组成一个代码块。由于没有用花括号括起来， `while` 循环只包括第 `7` 行，所以要添加花括号。

第7行：因为 `1` 和 `i` 都是整数，所以当 `i` 为 `1` 时，除法的结果是 `1` ；当 `i` 为更大的数时，除法结果为 `0` 。用 `n = 1.0/i` ， `i` 在除法运算之前会被转换为浮点数，这样就能得到非零值。

第8行：在格式化字符串中没有换行符（ `\n` ），这导致数字被打印成一行。

第10行：应该是 `return 0;`

下面是正确的版本：

```c
#include <stdio.h>
int main(void)
{
　　 int i = 1;
　　 float n;
　　 printf("Watch out! Here come a bunch of fractions!\n");
　　 while (i++ < 30)
　　 {
　　　　　n = 1.0/i;
　　　　　printf(" %f\n", n);
　　 }
　　 printf("That's all, folks!\n");
　　 return 0;
}
```

5．这个版本最大的问题是测试条件（ `sec` 是否大于 `0` ？）和 `scanf()` 语句获取 `sec` 变量的值之间的关系。具体地说，第一次测试时，程序尚未获得 `sec` 的值，用来与 `0` 作比较的是正好在 `sec` 变量内存位置上的一个垃圾值。一个比较笨拙的方法是初始化 `sec` （如，初始化为 `1` ）。这样就可通过第一次测试。不过，还有另一个问题。当最后输入 `0` 结束程序时，在循环结束之前不会检查 `sec` ，所以 `0` 也被打印了出来。因此，更好的方法是在 `while` 测试之前使用 `scanf()` 语句。可以这样修改：

```c
scanf("%d", &sec);
while ( sec > 0 ) {
　　 min = sec/S_TO_M;
　　 left = sec % S_TO_M;
　　 printf("%d sec is %d min, %d sec. \n", sec, min, left);
　　 printf("Next input?\n");
　　 scanf("%d", &sec);
}
```

`while` 循环第一轮迭代使用的是 `scanf()` 在循环外面获取的值。因此，在 `while` 循环的末尾还要使用一次 `scanf()` 语句。这是处理类似问题的常用方法。

6．下面是该程序的输出：

```c
%s! C is cool!
! C is cool!
11
11
12
11
```

解释一下。第 `1` 个 `printf()` 语句与下面的语句相同：

```c
printf("%s! C is cool!\n","%s! C is cool!\n");
```

第 `2` 个 `printf()` 语句首先把 `num` 递增为 `11` ，然后打印该值。第 `3` 个 `printf()` 语句打印 `num` 的值（值为 `11` ）。第 `4` 个 `printf()` 语句打印 `n` 当前的值（仍为 `12` ），然后将其递减为 `11` 。最后一个 `printf()` 语句打印 `num` 的当前值（值为 `11` ）。

7．下面是该程序的输出：

```c
SOS:4 4.00
```

表达式 `c1 -c2` 的值和 `'S' - '0'` 的值相同（其对应的 `ASCII` 值是 `83 - 79` ）。

8．把1～10打印在一行，每个数字占5列宽度，然后开始新的一行：

```c
1 2 3 4 5 6 7 8 9 10
```

9．下面是一个参考程序，假定字母连续编码，与 `ASCII` 中的情况一样。

```c
#include <stdio.h>
int main(void)
{
　　 char ch = 'a';
　　 while (ch <= 'g')
　　　　　 printf("%5c", ch++);
　　 printf("\n");
　　 return 0;
}
```

10．下面是每个部分的输出：

a． `1` 　 `2`

注意，先递增
`x`
的值再比较。光标仍留在同一行。

b． `101`

`102`

`103`

`104`

注意，这次 `x` 先比较后递增。在示例 `a` 和 `b` 中， `x` 都是在先递增后打印。另外还要注意，虽然第 `2` 个 `printf()` 语句缩进了，但是这并不意味着它是 `while` 循环的一部分。因此，在 `while` 循环结束后，才会调用一次该 `printf()` 语句。

c． `stuvw`

该例中，在第1次调用
`printf`
()语句后才会递增
`ch`
。

11．这个程序有点问题。 `while` 循环没有用花括号把两个缩进的语句括起来，只有 `printf()` 是循环的一部分，所以该程序一直重复打印消息 `COMPUTER BYTES DOG` ，直到强行关闭程序为止。

12．a． `x = x + 10;`

b． `x++; or ++x; or x = x + 1;`

c． `c = 2`  *  `(a + b);`

d． `c = a + 2` *  `b;`

13．a． `x--; or --x; or x = x - 1;`

b． `m = n % k;`

c． `p = q / (b - a);`

d． `x = (a + b) / (c`  *  `d);`

