#### 6.1.1　程序注释

先看 `while` 循环，该循环的测试条件是如下表达式：

```c
status == 1
```

==运算符是C的相等运算符（equality operator），该表达式判断 `status` 是否等于 `1` 。不要把 `status == 1` 与 `status = 1` 混淆，后者是把 `1` 赋给 `status` 。根据测试条件 `status == 1` ，只要 `status` 等于 `1` ，循环就会重复。每次循环， `num` 的当前值都被加到 `sum` 上，这样 `sum` 的值始终是当前整数之和。当 `status` 的值不为 `1` 时，循环结束。然后程序打印 `sum` 的最终值。

要让程序正常运行，每次循环都要获取 `num` 的一个新值，并重置 `status` 。程序利用 `scanf()` 的两个不同的特性来完成。首先，使用 `scanf()` 读取 `num` 的一个新值；然后，检查 `scanf()` 的返回值判断是否成功获取值。第4章中介绍过， `scanf()` 返回成功读取项的数量。如果 `scanf()` 成功读取一个整数，就把该数存入 `num` 并返回 `1` ，随后返回值将被赋给 `status` （注意，用户输入的值存储在 `num` 中，不是 `status` 中）。这样做同时更新了 `num` 和 `status` 的值， `while` 循环进入下一次迭代。如果用户输入的不是数字（如， `q` ）， `scanf()` 会读取失败并返回 `0` 。此时， `status` 的值就是 `0` ，循环结束。因为输入的字符 `q` 不是数字，所以它会被放回输入队列中（实际上，不仅仅是 `q` ，任何非数值的数据都会导致循环终止，但是提示用户输入 `q` 退出程序比提示用户输入一个非数字字符要简单）。

如果 `scanf()` 在转换值之前出了问题（例如，检测到文件结尾或遇到硬件问题），会返回一个特殊值 `EOF` （其值通常被定义为 `-1` ）。这个值也会引起循环终止。

如何告诉循环何时停止？该程序利用 `scanf()` 的双重特性避免了在循环中交互输入时的这个棘手的问题。例如，假设 `scanf()` 没有返回值，那么每次循环只会改变 `num` 的值。虽然可以使用 `num` 的值来结束循环，比如把 `num > 0` （ `num` 大于 `0` ）或 `num`  ！ `= 0` （ `num` 不等于 `0` ）作为测试条件，但是这样用户就不能输入某些值，如 `-3` 或 `0` 。也可以在循环中添加代码，例如每次循环时询问用户“是否继续循环？ `<y/n>` ”，然后判断用户是否输入 `y` 。这个方法有些笨拙，而且还减慢了输入的速度。使用 `scanf()` 的返回值，轻松地避免了这些问题。

现在，我们来看看该程序的结构。总结如下：

把
`sum`
初始化为
`0`

提示用户输入数据

读取用户输入的数据

当输入的数据为整数时，

输入添加给
`sum`
，

提示用户进行输入，

然后读取下一个输入

输入完成后，打印
`sum`
的值

顺带一提，这叫作伪代码（pseudocode），是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代表一块代码，不用考虑C的语法要用花括号把这部分代码括起来。

总之，因为 `while` 循环是入口条件循环，程序在进入循环体之前必须获取输入的数据并检查 `status` 的值，所以在 `while` 前面要有一个 `scanf()` 。要让循环继续执行，在循环内需要一个读取数据的语句，这样程序才能获取下一个 `status` 的值，所以在 `while` 循环末尾还要有一个 `scanf()` ，它为下一次迭代做好了准备。可以把下面的伪代码作为 `while` 循环的标准格式：

获得第1个用于测试的值

当测试为真时

处理值

获取下一个值

