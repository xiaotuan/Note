[toc]

### 1. 先来看下小区广播服务初始化流程

#### 1.1 小区广播管理类 CellBroadcastServiceManager.java

位置：`frameworks/opt/telephony/src/java/com/android/internal/telephony/CellBroadcastServiceManager.java`

当用户开启小区广播功能时，会调用 `CellBroadcastServiceManager.java` 类中的 `enable()` 方法。

```java
public void enable() {
    initCellBroadcastServiceModule();
}
```

在 `enable()` 方法中调用了 `initCellBroadcastServiceModule()` 方法。

```java
private void initCellBroadcastServiceModule() {
    mEnabled = true;
    if (sServiceConnection == null) {
        sServiceConnection = new CellBroadcastServiceConnection();
    }
    mCellBroadcastServicePackage = getCellBroadcastServicePackage();
    if (mCellBroadcastServicePackage != null) {
        mModuleCellBroadcastHandler = new Handler() {
            @Override
            public void handleMessage(@NonNull Message msg) {
                if (!mEnabled) {
                    Log.d(TAG, "CB module is disabled.");
                    return;
                }
                if (sServiceConnection.mService == null) {
                    final String errorMessage = "sServiceConnection.mService is null, ignoring message.";
                    Log.d(TAG, errorMessage);
                    CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_ERROR,
                                                CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_ERROR__TYPE__NO_CONNECTION_TO_CB_SERVICE,
                                                errorMessage);
                    return;
                }
                try {
                    ICellBroadcastService cellBroadcastService =
                        ICellBroadcastService.Stub.asInterface(
                        sServiceConnection.mService);
                    if (msg.what == EVENT_NEW_GSM_SMS_CB) {
                        mLocalLog.log("GSM SMS CB for phone " + mPhone.getPhoneId());
                        CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_REPORTED,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__TYPE__GSM,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__SOURCE__FRAMEWORK);
                        cellBroadcastService.handleGsmCellBroadcastSms(mPhone.getPhoneId(),
                                                                       (byte[]) ((AsyncResult) msg.obj).result);
                    } else if (msg.what == EVENT_NEW_CDMA_SMS_CB) {
                        mLocalLog.log("CDMA SMS CB for phone " + mPhone.getPhoneId());
                        SmsMessage sms = (SmsMessage) msg.obj;
                        CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_REPORTED,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__TYPE__CDMA,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__SOURCE__FRAMEWORK);
                        cellBroadcastService.handleCdmaCellBroadcastSms(mPhone.getPhoneId(),
                                                                        sms.getEnvelopeBearerData(), sms.getEnvelopeServiceCategory());
                    } else if (msg.what == EVENT_NEW_CDMA_SCP_MESSAGE) {
                        mLocalLog.log("CDMA SCP message for phone " + mPhone.getPhoneId());
                        CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_REPORTED,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__TYPE__CDMA_SPC,
                                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_REPORTED__SOURCE__FRAMEWORK);
                        Pair<SmsMessage, RemoteCallback> smsAndCallback =
                            (Pair<SmsMessage, RemoteCallback>) msg.obj;
                        SmsMessage sms = smsAndCallback.first;
                        RemoteCallback callback = smsAndCallback.second;
                        cellBroadcastService.handleCdmaScpMessage(mPhone.getPhoneId(),
                                                                  sms.getSmsCbProgramData(),
                                                                  sms.getOriginatingAddress(),
                                                                  callback);
                    }
                } catch (RemoteException e) {
                    final String errorMessage = "Failed to connect to default app: "
                        + mCellBroadcastServicePackage + " err: " + e.toString();
                    Log.e(TAG, errorMessage);
                    mLocalLog.log(errorMessage);
                    CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_ERROR,
                                                CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_ERROR__TYPE__NO_CONNECTION_TO_CB_SERVICE,
                                                errorMessage);
                    mContext.unbindService(sServiceConnection);
                    sServiceConnection = null;
                }
            }
        };

        Intent intent = new Intent(CellBroadcastService.CELL_BROADCAST_SERVICE_INTERFACE);
        intent.setPackage(mCellBroadcastServicePackage);
        if (sServiceConnection.mService == null) {
            boolean serviceWasBound = mContext.bindService(intent, sServiceConnection,
                                                           Context.BIND_AUTO_CREATE);
            Log.d(TAG, "serviceWasBound=" + serviceWasBound);
            if (!serviceWasBound) {
                final String errorMessage = "Unable to bind to service";
                Log.e(TAG, errorMessage);
                mLocalLog.log(errorMessage);
                CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_ERROR,
                                            CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_ERROR__TYPE__NO_CONNECTION_TO_CB_SERVICE,
                                            errorMessage);
                return;
            }
        } else {
            Log.d(TAG, "skipping bindService because connection already exists");
        }
        mPhone.mCi.setOnNewGsmBroadcastSms(mModuleCellBroadcastHandler, EVENT_NEW_GSM_SMS_CB,
                                           null);
    } else {
        final String errorMessage = "Unable to bind service; no cell broadcast service found";
        Log.e(TAG, errorMessage);
        mLocalLog.log(errorMessage);
        CellBroadcastStatsLog.write(CellBroadcastStatsLog.CB_MESSAGE_ERROR,
                                    CellBroadcastStatsLog.CELL_BROADCAST_MESSAGE_ERROR__TYPE__NO_CONNECTION_TO_CB_SERVICE,
                                    errorMessage);
    }
}
```

该方法首先创建与小区广播服务的连接（小区广播服务应用是：`packages\modules\CellBroadcastService`），然后初始化 `mModuleCellBroadcastHandler` 变量，最后通过 `mPhone.mCi` 的 `setOnNewGsmBroadcastSms` 的方法将 `mModuleCellBroadcastHandler` 变量设置到 `mPhone.mCi` 中。

#### 1.2 Phone.java 类

位置：`frameworks/opt/telephony/src/java/com/android/internal/telephony/Phone.java`

在 `CellBroadcastServiceManager.java` 类中使用到的 `mPhone.mCi` 变量是由 `Phone.java` 的构造函数设置的。

```java
protected Phone(String name, PhoneNotifier notifier, Context context, CommandsInterface ci,
                boolean unitTestMode, int phoneId,
                TelephonyComponentFactory telephonyComponentFactory) {
    mPhoneId = phoneId;
    mName = name;
    mNotifier = notifier;
    mContext = context;
    mLooper = Looper.myLooper();
    mCi = ci;
    ...
}
```

#### 1.3 BaseCommands.java

位置：`frameworks/opt/telephony/src/java/com/android/internal/telephony/BaseCommands.java`

在 `Phone.java` 的构造函数中 `CommandsInterface` 参数其实是一个接口，它最终的实现是 `RIL.java`。但是 `setOnNewGsmBroadcastSms()` 方法确是在 `BaseCommands.java` 中实现的。

```java
@Override
public void setOnNewGsmBroadcastSms(Handler h, int what, Object obj) {
    mGsmBroadcastSmsRegistrant = new Registrant (h, what, obj);
}

@Override
public void unSetOnNewGsmBroadcastSms(Handler h) {
    if (mGsmBroadcastSmsRegistrant != null && mGsmBroadcastSmsRegistrant.getHandler() == h) {
        mGsmBroadcastSmsRegistrant.clear();
        mGsmBroadcastSmsRegistrant = null;
    }
}
```

可以看到它只是使用传递过来的参数构建了一个 `Registrant` 对象。

#### 1.4 RadioIndication.java

位置：`frameworks/opt/telephony/src/java/com/android/internal/telephony/RadioIndication.java`

上面构建的 `Registrant` 对象其实是在 `RadioIndication.java` 类中使用的。

```java
public void newBroadcastSms(int indicationType, ArrayList<Byte> data) {
    mRil.processIndication(indicationType);

    byte response[] = RIL.arrayListToPrimitiveArray(data);
    if (RIL.RILJ_LOGD) {
        mRil.unsljLogvRet(RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS,
                          IccUtils.bytesToHexString(response));
    }

    if (mRil.mGsmBroadcastSmsRegistrant != null) {
        mRil.mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, response, null));
    }
}
```

可以看出 `newBroadcastSms()` 方法是在接收到新的广播信息时调用的。它通过 `mGsmBroadcastSmsRegistrant` 变量的 `notifyRegistrant()` 方法通知处理程序。

#### 1.5 Registrant.java

位置：`frameworks\base\core\java\android\os\Registrant.java`

我们来看下 `notifyRegistrant()` 方法：

```java
public void notifyRegistrant(AsyncResult ar) {
    internalNotifyRegistrant (ar.result, ar.exception);
}
```

在 `notifyRegistrant()` 方法中调用了 `internalNotifyRegistrant()` 方法：

```java
/*package*/ void internalNotifyRegistrant (Object result, Throwable exception) {
    Handler h = getHandler();

    if (h == null) {
        clear();
    } else {
        Message msg = Message.obtain();

        msg.what = what;

        msg.obj = new AsyncResult(userObj, result, exception);

        h.sendMessage(msg);
    }
}
```

从代码中可以看出 `internalNotifyRegistrant()` 最终调用了构造 `Registrant` 对象时传进来的 `Handler`，也就是 `CellBroadcastServiceManager.java` 类中的 `mModuleCellBroadcastHandler`。

#### 1.6 总结

从上面的分析中可以知道小区广播在底层中最终处理的地方是 `CellBroadcastServiceManager.java` 的 `mModuleCellBroadcastHandler`。而 `mModuleCellBroadcastHandler` 最终会调用小区广播服务进行处理。

### 2. 处理小区广播流程

#### 2.1 小区广播服务应用（CellBroadcastService）

位置：`packages\modules\CellBroadcastService`

##### 2.1.1 DefaultCellBroadcastService.java

位置：`packages\modules\CellBroadcastService\src\com\android\cellbroadcastservice\DefaultCellBroadcastService.java`

`DefaultCellBroadcastService.java` 服务继承于 `frameworks/base/telephony/java/android/telephony/CellBroadcastService.java`。当接收到 `GSM` 小区广播时会调用 `onGsmCellBroadcastSms()` 方法；当接收到 `CDMA` 小区广播时会调用 `onCdmaCellBroadcastSms()` 方法。