### 6.4.4　 `initrd` 探究

作为Linux引导过程的一部分，内核必须找到并挂载一个根文件系统。在引导过程的后期，内核通过函数 `prepare_namespace()` 决定要挂载的文件系统及挂载点，这个函数位于文件.../init/do_mounts.c中。如果内核支持 `initrd` （如图6-1所显示的那样）并且内核命令行也是按此进行配置的，内核会解压物理内存中的 `initrd` 镜像，并最终将这个文件的内容复制到一个ramdisk设备（/dev/ram）中。这时，我们拥有了一个位于内核ramdisk中的合适的文件系统。当文件系统被读入到ramdisk中后，内核实际上会挂载ramdisk设备作为其根文件系统。最后，内核生成一个内核线程，用以执行 `initrd` 镜像中的linuxrc文件。<a class="my_markdown" href="['#anchor0611']"><sup class="my_markdown">[11]</sup></a>

<a class="my_markdown" href="['#ac0611']">[11]</a>　由于篇幅有限，我们只是非常简单地描述了这一系列事件。实际的机制在概念上与此类似，但为了清晰起见，我们省略了几处重要的细节。我们建议你阅读内核源代码了解这些细节。请参考文件.../init/main.c和.../init/do_mounts*.c。

当linuxruc脚本执行完毕后，内核会卸载 `initrd` ，并继续执行系统引导的最后一些步骤。如果真正的根设备中有一个名为/initrd的目录，Linux会将initrd文件系统挂载到这个路径上（称为挂载点）。如果最终的根文件系统中不包含这个目录， `initrd` 镜像就简单地被丢弃了。

如果内核命令行中包含 `root=` 参数并指定一个ramdisk（比如 `root=/dev/ram0` ），那么前面所描述的 `initrd` 的行为会发生两个重要的改变。首先，linuxrc文件将不会得到处理。其次，内核不会尝试挂载另一个文件系统作为其根文件系统。这意味着你可以拥有一个Linux系统，其中initrd是它唯一的根文件系统。这对于小型的系统配置很有用，这类系统中唯一的根文件系统就是ramdisk。如果在内核命令行中指定/dev/ram0，当整个系统初始化完成后，initrd就会成为最终的根文件系统。

