### 14.2.5　调试非常早期的内核代码

前面所述的那些技术不能够用于调试内核初始化过程中非常早期的代码。实际上，你所能做的最多是调试串行端口驱动程序加载和注册之后的初始化代码。在某些架构和平台上，这种能力是由两个内核命令行参数提供的： `kgdbwait` 和 `kgdb8250` 。<a class="my_markdown" href="['#anchor145']"><sup class="my_markdown">[5]</sup></a>

<a class="my_markdown" href="['#ac145']">[5]</a>　这种调试早期内核代码的功能是由MontaVista公司在其针对MPC8548平台的商业嵌入式Linux发行版中提供的。目前，主线内核源码还不支持它。如果想复制这个功能，你必须为内核代码打补丁，在其中添加早期的串行端口驱动。

要想支持早期的内核调试，内核需要一个KGDB I/O驱动。在使用KGDB进行早期的内核调试时，最常用的（也是影响最小的）I/O方法是串行端口。前面所说的kgdb8250驱动就是这样的一个例子。显然，这个驱动应该被编译到内核中，以用于早期的内核调试。

正如我们在代码清单14-1中所看到的，我们用kgdb8250告诉KGDB使用哪个串行端口。然而，使用另一种语法格式，我们就能够调用一个早期的初始化函数，从而可以调试非常早期的内核代码。使用 `kgdbwait` 能够让内核停在初始化流程非常早期的阶段，并等待来自用户的命令。将以下这些变量添加到内核命令行中，我们就能够使用KGDB调试非常早期的内核代码了：



![394.png](../images/394.png)
有一点需要注意，这些命令行参数的顺序非常关键。必须首先提供KGDB I/O驱动（在这个例子中是kgdb8250），这样内核在处理kgdbwait之前才能完成这个驱动的初始化。由于 `kgdbwait` 基本上是设置一个调试断点，所以在设置断点之前，目标板与调试器之间的通信基础设施必须到位。

另一点需要记住的是，这种调试支持一般是和具体平台相关的。也就是说，你的内核和平台必须支持某种类型的用于早期内核调试的I/O驱动。为了实现这种调试，你的平台也许使用了不同的硬件，所以这需要由你（或嵌入式Linux厂商）来提供这个早期的内核调试I/O驱动。

对于kgdb8250 I/O驱动来说，你还可以在命令行中提供一个全面的参数说明，从而向这个驱动提供目标板的详细信息。其中可以包括访问这个驱动所需的I/O类型、它的基地址及可选的寄存器移位值、IRQ和波特率。采用这种形式时，它看上去会像是下面这样：



![395.png](../images/395.png)
