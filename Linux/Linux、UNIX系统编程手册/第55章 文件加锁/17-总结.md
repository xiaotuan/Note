### 55.8　总结

文件锁使得进程能够同步对一个文件的访问。Linux提供了两种文件加锁系统调用：从BSD衍生出来的flock()和从System V衍生出来的fcntl()。尽管这两组系统调用在大多数UNIX实现上都是可用的，但只有fcntl()加锁在SUSv3中进行了标准化。

flock()系统调用对整个文件加锁，可放置的锁有两种：一种是共享锁，这种锁与其他进程持有的共享锁是兼容的；另一种是互斥锁，这种锁能够阻止其他进程放置这两种锁。

fcntl()系统调用将一个文件的任意区域上放置锁（“记录锁”），这个区域可以是单个字节也可以是整个文件。可放置的锁有两种：读锁和写锁，它们之间的兼容性语义与flock()放置的共享锁和互斥锁之间的兼容性语义类似。如果一个阻塞式（F_SETLKW）锁请求将会导致死锁，那么内核会让其中一个受影响的进程的fcntl()失败（返回EDEADLK错误）。

使用flock()和fcntl()放置的锁之间是相互不可见的（除了在使用fcntl()实现flock()的系统）。通过flock()和fcntl()放置的锁在fork()中的继承语义和在文件描述符被关闭时的释放语义是不同的。

Linux特有的/proc/locks文件给出了系统中所有进程当期持有的文件锁。

#### 更多信息

[Stevens & Rago,2005]和[Stevens, 1999]对fcntl()记录加锁进行了详尽的讨论。[Bovet & Cesati, 2005]提供了Linux上flock()和fcntl()加锁的一些实现细节。[Tanenbaum, 2007]和[Deitel et al., 2004]从总体上描述了死锁的概念，包括死锁检测覆盖、避免以及防止。

