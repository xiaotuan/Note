### 55.9　习题

**55-1.** 　试验运行程序清单55-1中给出的程序（t_flock.c）的多个实例以确认下列有关flock()操作的各项要点：

(a)一系列取得一个文件上的共享锁的进程是否会导致一个尝试在该文件上放置互斥锁的进程饿死？

(b)假设一个文件被互斥地锁住了，并且其他进程正在等待在该文件上放置共享锁和互斥锁。那么当第一把锁被释放之后是否存在什么规则来确定哪个进程能够获取这把锁？如共享锁是否比互斥锁拥有更高的优先级，或反之亦然？锁的准予是否按照FIFO顺序？

(c)读者如果能够访问其他提供了flock()的UNIX实现，那么在该实现上对这些规则进行确认。

**55-2.** 　写一个程序来确认flock()在被两个进程用来锁住两个不同的文件时是否对死锁进行检测。

**55-3.** 　写一个程序来验证55.2.1节中有关flock()锁的继承和释放语义的论断。

**55-4.** 　试验运行程序清单55-1中的程序（t_flock.c）和程序清单55-2中的程序（i_fcntl_locking.c）来观察通过flock()和fcntl()取得的锁是否会相互影响。读者如果能够访问其他UNIX实现，那么请在那些实现上开展同样的实验。

**55-5.** 　55.3.4节中指出过在Linux上，添加或检查一把锁的存在性所需的时间取决于锁在该文件上所有锁的列表中的位置。编写两个程序验证：

(a)第一个程序应该在一个文件上获取（比如说）40 001个写锁。这些锁交替地被放置在文件中的各个字节上，即锁会被放置在字节0、2、4、6，以此类推直到（比如说）字节80 000。取得这些锁之后进程就进入睡眠。

(b)在第一个程序处于睡眠的时候，第二个程序循环（比如说）10 000次，在每个循环中使用F_SETLK来尝试锁住被上一个程序锁住的其中一个字节（这些加锁请求总是会失败）。不管在哪次运行中，这个程序总是尝试锁住文件的第N * 2个字节。

使用shell内置的time命令，测量N等于0、10 000、20 000、30 000以及40 000时执行第二个程序所需的时间。得到的结果是否与预期的线性行为匹配？

**55-6.** 　试验程序清单55-2中的程序（i_fcntl_locking.c）来验证55.3.6节中有关锁饿死和fcntl()记录锁优先级的论断。

**55-7.** 　读者如果能够访问其他UNIX实现，那么请使用程序清单55-2中的程序（i_fcntl_locking.c）来观察是否可以得出fcntl()记录加锁在写者饿死方面以及多个排队锁请求被准予的顺序方面的处理规则。

**55-8.** 　使用程序清单55-2中的程序（i_fcntl_locking.c）来说明内核会检测出包含三个（或更多）对同一文件进行加锁的进程的循环死锁。

**55-9.** 　编写一对程序（或使用一个子进程的单个程序）使它们使用55.4节中描述的强制式锁来造成死锁的情形。

**55-10.** 　阅读procmail提供的lockfile(1)实用工具的手册，为该程序编写一个简化版。



