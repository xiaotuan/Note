### 58.4　网络层：IP

位于数据链路层之上的是网络层，它关注的是如何将包（数据）从源主机发送到目标主机。这一层执行了很多任务，包括以下几个。

+ 将数据分解成足够小的片段以便数据链路层进行传输（如有必要的话）。
+ 在因特网上路由数据。
+ 为传输层提供服务。

在TCP/IP协议套件中，网络层的主要协议是IP。在4.2BSD实现中出现的IP的版本是IP版本4（IPv4）。在20世纪90年代早期设计出了IP的一个修正版：IP版本6（IPv6）。这两个版本之间最显著的差别在于IPv4使用32位地址来标识子网和主机，而IPv6则使用了128位的地址，从而能为主机提供更大的地址范围。虽然目前在因特网上IPv4仍然是使用最广的IP版本，但在将来它会被IPv6所取代。IPv4和IPv6都支持高层的UDP和TCP传输层协议（以及很多其他协议）。

> 尽管从理论上来讲，32位的地址空间提供了数以亿计的IPv4网络地址，但地址的结构和分配放置决定了实际可用的地址数量要少许多。IPv4地址空间的枯竭是创造IPv6主要原因。
> 有关IPv6的简史可在http://www.laynetworks.com/IPv6.htm处找到。
> IPv4和IPv6的存在引出了一个问题“IPv5呢？”事实上从来就没有IPv5这种东西。每个IP数据报头都包含一个4位的版本号字段（即IPv4数据报的这个字段值总是数字4），而版本号5则被指派给了一个试验协议因特网流协议Internet Stream Protocol。（RFC 1819描述了这个协议的第二版，简写为ST-II。）在20世纪70年代最初构想的时候，这个面向连接的协议就被设计成支持音频和视频传输以及分布式仿真。由于IP数据报版本号5已经被指派过了，因此IPv4的升级版就使用了版本号6。

图58-2给出了一个裸socket（SOCK_RAW），它允许应用程序直接与IP层进行通信。这里不会对裸socket的使用进行描述，因为大多数应用程序会使用基于其中一种传输层协议（TCP或UDP）之上的socket。[Stevens et al., 2004]的第28章对裸socket进行了描述。有关裸socket的使用方面的一个富有教育意义的例子是sendip程序（http://www.earth.li/projectpurple/progs/sendip.html），它是一个命令行驱动的工具，允许使用任意内容来构建和传输IP数据报（包括构建UDP数据报和TCP段的选项）。

#### IP传输数据报

IP以数据报（包）的形式来传输数据。在两个主机之间发送的每一个数据报都是在网络上独立传输的，它们经过的路径可能会不同。一个IP数据报包含一个头，其大小范围为20字节到60字节。这个头中包含了目标主机的地址，这样就可以在网络上将这个数据报路由到目标地址了。此外，它还包含了包的源地址，这样接收主机就知道数据报的源头。

> 发送主机可以伪造一个包的源地址，这也是SYN洪泛这种TCP拒绝服务攻击的基础。[Lemon, 2002]描述了这种攻击的细节以及现代TCP实现为解决这个问题所采取的措施。

一个IP实现可能会给它所支持的数据报的大小设定一个上限。所有IP实现都必须做到数据报的大小上限至少与规定的IP最小重组缓冲区大小（minimum reassembly buffer size）一样大。在IPv4中，这个限制值是576字节；在IPv6中，这个限制值是1500字节。

#### IP是无连接和不可靠的

IP是一种无连接协议，因为它并没有在相互连接的两个主机之间提供一个虚拟电路。IP也是一种不可靠的协议：它尽最大可能将数据报从发送者传输给接收者，但并不保证包到达的顺序会与它们被传输的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接收者。IP也没有提供错误恢复（头信息错误的包会被静默地丢弃）。可靠性是通过使用一个可靠的传输层协议（如TCP）或应用程序本身来保证的。

> IPv4为IP头提供了一个校验和，这样就能够检测出头中的错误，但并没有为包中所传输的数据提供任何错误检测机制。IPv6并没有为IP头提供检验和，它依赖高层协议来完成错误检测和可靠性。（UDP校验和在IPv4是可选的，但一般来讲都是启用的；UDP校验和在IPv6是强制的。TCP校验和在IPv4和IPv6中都是强制的。）
> IP数据报的重复是可能发生的，因为一些数据链路层采用了一些技术来确保可靠性以及IP数据报可能会以隧道形式穿越一些采用了重传机制的非TCP/IP网络。

#### IP可能会对数据报进行分段

IPv4数据报的最大大小为65 535字节。在默认情况下，IPv6允许一个数据报的最大大小为65 575字节（40字节用于存放头信息，65 535字节用于存放数据），并且为更大的数据报（所谓的jumbograms）提供了一个选项。

之前曾经提过大多数数据链路层会为数据帧的大小设定一个上限（MTU）。如在常见的以太网架构中这个上限值是1500字节（比一个IP数据报的最大大小要小得多）。IP还定义了路径MTU的概念，它是源主机到目的主机之间路由上的所有数据链路层的最小MTU。（在实践中，以太网MTU通常是路径中最小的MTU。）

当一个IP数据报的大小大于MTU时，IP会将数据报分段（分解）成一个个大小适合在网络上传输的单元。这些分段在达到最终目的地之后会被重组成原始的数据报。（每个IP分段本身就是包含了一个偏移量字段的IP数据报，该字段给出了一个该分段在原始数据报中的位置。）

IP分段的发生对于高层协议层是透明的，并且一般来讲也并不希望发生这种事情（[Kent & Mogul, 1987]）。这里的问题在于由于IP并不进行重传并且只有在所有分段都达到目的地之后才能对数据报进行组装，因此如果其中一些分段丢失或包含传输错误的话就会导致整个数据报不可用。在一些情况下，这会导致极高的数据丢失率（适用于不进行重传的高层协议，如UDP）或降低传输速率（适用于进行重传的高层协议，如TCP）。现代TCP实现采用了一些算法（路径MTU发现）来确定主机之间的一条路径的MTU，并根据该值对传递给IP的数据进行分解，这样IP就不会碰到需要传输大小超过MTU的数据报的情况了。UDP并没有提供这种机制，在58.6.2节中将会考虑基于UDP的应用程序如何处理IP分段的情况。

