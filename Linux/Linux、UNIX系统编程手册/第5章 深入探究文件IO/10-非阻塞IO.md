### 5.9　非阻塞I/O

在打开文件时指定O_NONBLOCK标志，目的有二。

+ 若open()调用未能立即打开文件，则返回错误，而非陷入阻塞。有一种情况属于例外，调用open()操作FIFO可能会陷入阻塞（参见44.7节）。
+ 调用open()成功后，后续的I/O操作也是非阻塞的。若I/O系统调用未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回EAGAIN或EWOULDBLOCK错误。具体返回何种错误将依赖于系统调用。Linux系统与许多UNIX实现一样，将两个错误常量视为同义。

管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式。（因为无法通过 open()来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用5.3节所述fcntl()的F_SETFL命令。）

正如13.1节所述，由于内核缓冲区保证了普通文件I/O不会陷入阻塞，故而打开普通文件时一般会忽略O_NONBLOCK标志。然而，当使用强制文件锁时（55.4节），O_NONBLOCK标志对普通文件也是起作用的。

更多关于非阻塞I/O的信息请参见44.9节和第63章。

> 历史上，派生自System V的系统提供有O_NDELAY标志，语义上类似于O_NONBLOCK标志。二者主要的区别在于：在System V系统中，若非阻塞的write()调用未能完成写操作，或者非阻塞的 read()调用无输入数据可读时，则两个调用将返回0。这对于read()调用来说会有问题，因为程序将无法区分返回0的read()到底是没有可用的输入数据，还是遇到了文件结尾<sup class="my_markdown">⑫</sup>。故而POSIX.1标准在初版中引入了O_NONBLOCLK标志。有些UNIX实现一直还在支持旧语义的O_NDELAY标志。Linux系统虽然也定义了 O_NDELAY常量，但其与O_NONBLOCK标志同义。

