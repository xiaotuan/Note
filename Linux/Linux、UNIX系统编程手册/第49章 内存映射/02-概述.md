### 49.1　概述

mmap()系统调用在调用进程的虚拟地址空间中创建一个新内存映射。映射分为两种。

+ 文件映射：文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容了。映射的分页会在需要的时候从文件中（自动）加载。这种映射也被称为基于文件的映射或内存映射文件。
+ 匿名映射：一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为0。

> 另一种看待匿名映射的角度（并且也接近于事实）是把它看成是一个内容总是被初始化为0的虚拟文件的映射。

一个进程的映射中的内存可以与其他进程中的映射共享（即各个进程的页表条目指向RAM中相同分页）。这种行为会在两种情况下发生。

+ 当两个进程映射了一个文件的同一个区域时它们会共享物理内存的相同分页。
+ 通过fork()创建的子进程会继承其父进程的映射的副本，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同。

当两个或更多个进程共享相同分页时，每个进程都有可能会看到其他进程对分页内容做出的变更，当然这要取决于映射是私有的还是共享的。

+ 私有映射（MAP_PRIVATE）：在映射内容上发生的变更对其他进程不可见，对于文件映射来讲，变更将不会在底层文件上进行。尽管一个私有映射的分页在上面介绍的情况中初始时是共享的，但对映射内容所做出的变更对各个进程来讲则是私有的。内核使用了写时复制（copy-on-write）技术完成了这个任务（参见24.2.3节）。这意味着每当一个进程试图修改一个分页的内容时，内核首先会为该进程创建一个新分页并将需修改的分页中的内容复制到新分页中（以及调整进程的页表）。正因为这个原因，MAP_PRIVATE映射有时候会被称为私有、写时复制映射。
+ 共享映射（MAP_SHARED）：在映射内容上发生的变更对所有共享同一个映射的其他进程都可见，对于文件映射来讲，变更将会发生在底层的文件上。

上面介绍的两个映射特性（文件与匿名以及私有和共享）可以以四种不同的方式加以组合，表49-1对此进行了总结。

<center class="my_markdown"><b class="my_markdown">表49-1：各种内存映射的用途</b></center>

| 变更的可见性 | 映 射 类 型 |
| :-----  | :-----  | :-----  | :-----  |
| 文　　件 | 匿　　名 |
| 私有 | 根据文件内容初始化内存 | 内存分配 |
| 共享 | 内存映射I/O；进程间共享内存（IPC） | 进程间共享内存（IPC） |

这四种不同的内存映射的创建和使用方式如下所述。

+ 私有文件映射：映射的内容被初始化为一个文件区域中的内容。多个映射同一个文件的进程初始时会共享同样的内存物理分页，但系统使用写时复制技术使得一个进程对映射所做出的变更对其他进程不可见。这种映射的主要用途是使用一个文件的内容来初始化一块内存区域。一些常见的例子包括根据二进制可执行文件或共享库文件的相应部分来初始化一个进程的文本和数据段。
+ 私有匿名映射：每次调用mmap()创建一个私有匿名映射时都会产生一个新映射，该映射与同一（或不同）进程创建的其他匿名映射是不同的（即不会共享物理分页）。尽管子进程会继承其父进程的映射，但写时复制语义确保在fork()之后父进程和子进程不会看到其他进程对映射所做出的变更。私有匿名映射的主要用途是为一个进程分配新（用零填充）内存（如在分配大块内存时malloc()会为此而使用mmap()）。
+ 共享文件映射：所有映射一个文件的同一区域的进程会共享同样的内存物理分页，这些分页的内容将被初始化为该文件区域。对映射内容的修改将直接在文件中进行。这种映射主要用于两个用途。第一，它允许内存映射I/O，这表示一个文件会被加载到进程的虚拟内存中的一个区域中并且对该块内容的变更会自动被写入到这个文件中。因此，内存映射I/O为使用read()和write()来执行文件I/O这种做法提供了一种替代方案。这种映射的第二种用途是允许无关进程共享一块内容以便以一种类似于System V共享内存段（第48章）的方式来执行（快速）IPC。
+ 共享匿名映射：与私有匿名映射一样，每次调用mmap()创建一个共享匿名映射时都会产生一个新的、与任何其他映射不共享分页的截然不同的映射。这里的差别在于映射的分页不会被写时复制。这意味着当一个子进程在fork()之后继承映射时，父进程和子进程共享同样的RAM分页，并且一个进程对映射内容所做出的变更会对其他进程可见。共享匿名映射允许以一种类似于System V共享内存段的方式来进行IPC，但只有相关进程之间才能这么做。

在本章余下的部分中将分别介绍各种映射的细节信息。

一个进程在执行exec()时映射会丢失，但通过fork()创建的子进程会继承映射，映射类型（MAP_PRIVATE或MAP_SHARED）也会被继承。

通过Linux特有的/proc/PID/maps文件能够查看在48.5节中介绍过的与一个进程的映射有关的所有信息。

> mmap()的另一个用途是与POSIX共享内存对象一起使用，它允许无关进程在不创建关联磁盘文件（共享文件映射需要这样的文件）的情况下共享一块内存区域。第54章将会介绍POSIX共享内存对象。

