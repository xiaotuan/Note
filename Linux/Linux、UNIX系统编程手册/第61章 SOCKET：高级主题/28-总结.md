### 61.14　总结

在许多情况下，当在流式套接字上执行I/O操作时会出现部分读取和部分写入的现象。我们给出了两个函数readn()以及writen()的实现，它们可用来确保将缓冲区中的数据完整地读取或写入。

shutdown()系统调用对连接终止提供了更加精细的控制。通过调用shutdown()，无论是否有其他打开的文件描述符指向套接字，我们都可以强行关闭双向通信流的其中一端或两端。

同read()和write()一样，recv()和send()也可用来在套接字上执行I/O操作，但需要提供一个额外的参数flags，该参数用来控制特定于套接字的I/O功能。

系统调用sendfile()允许我们高效地将文件内容拷贝到套接字上。获得高效性的原因在于我们不需要将文件数据在用户内存空间中来回拷贝，而read()和write()则需要这么处理。

系统调用getsockname()和getpeername()可以分别获取套接字绑定的本地地址以及连接的对端套接字地址。

我们对TCP协议的一些操作细节做了讨论，包括TCP的状态、TCP状态迁移图以及TCP连接的建立和终止。作为讨论的一部分，我们了解了为什么TIME_WAIT状态在TCP的可靠性保证中占据了重要的部分。尽管当重启服务器时，这个状态可以导致出现“地址已经使用”的错误。之后我们学习了SO_REUSEADDR套接字选项可用来避免出现这个错误，同时让TIME_WAIT状态达到其预期的目的。

netstat和tcpdump命令是用来监视和调试使用套接字的应用程序的优秀工具。

系统调用getsockopt()和setsockopt()可用来获取和修改影响套接字操作的相关选项。

在Linux上，当accept()调用返回一个新创建的套接字时，它并不会继承监听套接字上的与信号驱动I/O相关的打开文件状态标记、文件描述符标记以及文件描述符属性。但是，可以继承已设定的套接字选项。我们也提到了在SUSv3规范中，对于这些继承规则的细节并没有做说明，这些规则在不同的实现中有所不同。

尽管UDP没有提供TCP那样的可靠性保证，我们也了解到了对于某些应用程序来说为什么UDP是更加合适的选择。

最后，我们列出了一些套接字编程中的高级特性，本书并没有对此做详细的描述。

#### 更多信息

请参阅59.15节中列出的更多信息来源。

