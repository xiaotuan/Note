### 61.15　练习

**61-1.** 　假设修改了程序清单61-2（is_echo_cl.c）中的程序，使得程序不使用fork()创建两个子进程并行处理，相反只采用一个进程首先将标准输入拷贝到套接字，然后读取服务器端的响应。运行这个客户端程序时可能会出现什么问题？（参考图58-8。）

**61-2.** 　通过socketpair()来实现pipe()。利用shutdown()来确保得到的管道是单向的。

**61-3.** 　通过read()、write()和lseek()来实现sendfile()的替代品。

**61-4.** 　如果在调用bind()之前先在TCP套接字上调用listen()，那么内核会为套接字分配一个临时端口号。编写一个程序，利用getsockname()来显示这个结果。

**61-5.** 　编写一个客户端和服务器程序，使得客户端能够在服务器所在的主机上执行任意的shell命令。（如果这个应用中没有实现任何安全机制，你应该确保运行该服务器的用户账户不会被恶意用户利用并造成破坏。）客户端应该接受两个命令行参数：



![1576.png](../images/1576.png)
在连接到服务器之后，客户端将给定的命令发送到服务器，然后通过调用 shutdown()关闭本地套接字的写端，这样服务器会检测到文件结尾。服务器应该在单独的子进程中处理每个到来的连接（即，采用并发型设计）。对于每个到来的连接，服务器应该从套接字中读取命令（直到检测到文件结尾），之后调用一个 shell 进程来执行命令。这里给出两个提示。

+ 参见27.7节中对system()的实现，以此作为如何执行一个shell命令的例子。
+ 通过调用 dup2()，将套接字复制到标准输出和标准错误输出上，被执行的命令会自动写入到套接字上。

**61-6.** 　61.13.1节中提到还有一种其他的方法可处理带外数据。可以在客户端和服务器之间创建两条套接字连接：一条连接用于处理普通数据，另一条用于处理优先级数据。编写客户端和服务器程序来实现这个框架。这里有一些提示。

+ 服务器需要通过某些方法获知哪两个套接字是属于同一个客户端的。一种办法是让客户端先创建一个使用临时端口的监听套接字（即，绑定到端口0上）。在获得了监听套接字的临时端口号后（通过调用getsockname()），客户端将“普通”的套接字连接到服务器的监听套接字上，并发送一条包含了客户端监听套接字端口号的消息给服务器。之后客户端等待服务器利用客户端的监听套接字在相反的方向上建立一条用于处理“优先级”数据的连接。（服务器可以在针对普通连接的accept()调用中获取到客户端的IP地址。）
+ 实现一些安全保护机制，防止恶意进程尝试连接到客户端的监听套接字上。要做到这点，客户端可以通过普通套接字发送一个 cookie（即，某种类型的唯一标识消息）给服务器。之后服务器将这个 cookie 通过优先级套接字返回给客户端，以便客户端验证。
+ 为了试验将普通的和优先级数据从客户端传送到服务器，你需要在服务器端利用select()或者poll()（在63.2节中描述）对两个套接字的输入实现多路复用。

①译者注：原文为“On return, it contains the offset of the next byte following the last byte that was transferred from in_fd.”



