### 47.7　多个阻塞信号量操作的处理

如果多个因减小一个信号量值而发生阻塞的进程对该信号量减去的值是一样的，那么当条件允许时到底哪个进程会首先被允许执行操作是不确定的（即哪个进程能够执行操作依赖于各个内核自己的进程调度算法）。

另一方面，如果多个因减小一个信号量值而发生阻塞的进程对该信号量减去的值是不同的，那么会按照先满足条件先服务的顺序来进行。假设一个信号量的当值为0，进程A请求将信号量值减去2，然后进程B请求将信号量值减去1。如果第三个进程将信号量值加上了1，那么进程B首先会被解除阻塞并执行它的操作，即使进程A首先请求在该信号量上执行操作也一样。在一个糟糕的应用程序设计中，这种场景可能会导致饿死情况的发生，即一个进程因信号量的状态无法满足所请求的操作继续往前执行的条件而永远保持阻塞。回到本节的例子，考虑多个进程交替地调整信号量值使其值永远不会出现大于1的情况，这就会导致进程A永远保持阻塞。

当一个进程因试图在多个信号量上执行操作而发生阻塞时也可能会出现饿死的情况。考虑下面的这些在一组信号量上执行的操作，两个信号量的初始值都为0。

**1．** 进程A请求将信号量0和1的值减去1（阻塞）。

**2．** 进程B请求将信号量0的值减去1（阻塞）。

**3．** 进程C将信号量0的值加上1。

此刻，进程B解除阻塞并完成了它的请求，即使它发出请求的时间要晚于进程A。同样，也可以设计出一个让进程A饿死的同时让其他进程调整和阻塞于单个信号量值的场景。

