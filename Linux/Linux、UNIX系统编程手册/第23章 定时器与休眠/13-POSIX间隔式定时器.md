### 23.6　POSIX间隔式定时器

使用setitimer()来设置经典UNIX间隔式定时器，会受到如下制约。

+ 针对ITIMER_REAL、ITIMER_VIRTUAL和ITIMER_PROF这3类定时器，每种只能设置一个。
+ 只能通过发送信号的方式来通知定时器到期。另外，也不能改变到期时产生的信号。
+ 如果一个间隔式定时器到期多次，且相应信号遭到阻塞时，那么会只调用一次信号处理器函数。换言之，无从知晓是否出现过定时器溢出（timer overrun）的情况。
+ 定时器的分辨率只能达到微秒级。不过，一些系统的硬件时钟提供了更为精细的时钟分辨率，软件此时应采用这一较高分辨率。

POSIX.1b定义了一套API来突破这些限制，Linux 2.6实现了这一API。

> 在较老的Linux系统上，glibc通过基于线程的实现提供了这一API的不完整版。不过，这种用户空间内的实现是无法提供此处描述的所有特性的。

POSIX定时器API将定时器生命周期划分为如下几个阶段。

+ 以系统调用timer_create()创建一个新定时器，并定义其到期时对进程的通知方法。
+ 以系统调用timer_settime()来启动或停止一个定时器。
+ 以系统调用timer_delete()删除不再需要的定时器。

由fork()创建的子进程不会继承POSIX定时器。调用exec()期间亦或进程终止时将停止并删除定时器。

Linux上，调用POSIX定时器API的程序编译时应使用-lrt选项，从而与librt（实时）函数库相链接。

