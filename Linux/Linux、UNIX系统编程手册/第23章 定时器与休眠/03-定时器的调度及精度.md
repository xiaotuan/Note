### 23.2　定时器的调度及精度

取决于当前负载和对进程的调度，系统可能会在定时器到期的瞬间（通常是几分之一秒）之后才去调度其所属进程。尽管如此，由setitimer()或本章后续介绍的其他接口所创建的周期性定时器，在到期后依然会恪守其规律性。例如，假设设置一个实时定时器每两秒到期一次，虽然上述延迟可能会影响每个定时器事件的送达，但系统对后续定时器到期的调度依然会严格遵循两秒的时间间隔。换言之，间隔式定时器不受潜在错误左右。

虽然setitimer()使用的timeval结构提供有微秒级精度，但是传统意义上定时器精度还是受制于软件时钟（10.6节）频率。如果定时器值未能与软件时钟间隔的倍数严格匹配，那么定时器值则会向上取整。也就是说，假如有一个间隔为19100微秒（刚刚超过19毫秒）的定时器，如果jiffy（软件时钟周期）为4毫秒，那么定时器实际上会每隔20毫秒过期一次。

#### 高分辨率定时器

对于现代Linux内核而言，适才关于定时器分辨率受限于软件时钟频率的论断已经不再成立。自版本2.6.21开始，Linux内核可选择是否支持高分辨率定时器。如果选择支持（通过内核配置选项CONFIG_HIGH_RES_TIMERS），那么本章各种定时器以及休眠接口的的精度则不再受内核jiffy（软件时钟周期）的影响，可以达到底层硬件所支持的精度。在现代硬件平台上，精度达到微秒级是司空见惯的事情。

> 23.5.1节将介绍函数clock_getres()，可以用其返回值来判断系统是否支持高分辨率定时器。

