### 14.1　设备专用文件（设备文件）

本章会经常提到磁盘设备，因此这里先简要介绍一下设备文件的概念。

设备专用文件与系统的某个设备相对应。在内核中，每种设备类型都有与之相对应的设备驱动程序，用来处理设备的所有I/O请求。设备驱动程序属内核代码单元，可执行一系列操作，（通常）与相关硬件的输入/输出动作相对应。由设备驱动程序提供的API是固定的，包含的操作对应于系统调用open()、close()、read()、write()、mmap()以及ioctl()。每个设备驱动程序所提供的接口一致，这隐藏了每个设备在操作方面的差异，从而满足了I/O操作的通用性（请参见4.2节）。

某些设备是实际存在的，比如鼠标、磁盘和磁带设备。而另一些设备则是虚拟的，亦即并不存在相应硬件，但内核会（通过设备驱动程序）提供一种抽象设备，其所携带的API与真实设备一般无异。

可将设备划分为以下两种类型。

+ 字符型设备基于每个字符来处理数据。终端和键盘都属于字符型设备。
+ 块设备则每次处理一块数据。块的大小取决于设备类型，但通常为512字节的倍数。磁盘和磁带设备都属于块设备。

与其他类型的文件一样，设备文件总会出现在文件系统中，通常位于/dev目录下。超级用户可使用mknod命令创建设备文件，特权级程序（CAP_MKNOD）执行mknod()系统调用亦可完成相同任务。

> 本书不会对mknod()（make file-system i-node创建，文件系统i节点）系统调用做详细介绍，因为该系统调用的用法一目了然，而且如今仅用于创建设备文件，一般应用程序鲜有问津。当然，也可以使用mknod()创建FIFO（参见44.7节），但最好使用mkfifo()函数来完成该任务。早先，某些UNIX实现会使用mknod()来创建目录，但如今已为mkdir()系统调用所取代。然而，还有一些UNIX实现（Linux不在此列），为了保持向后兼容性，仍然在mknod()中保留了这一能力，详情请见mknod(2)手册页。

在Linux的早期版本中，/dev包含了系统中所有可能设备的条目，即使某些设备实际并未与系统连接。这意味着/dev会包含数以千计的未用设备项，从而导致了两个缺点：其一，对于需要扫描该目录内容的应用而言，降低了程序的执行速度；其二，根据该目录下的内容无法发现系统中实际存在哪些设备。Linux2.6运用udev程序解决了上述问题。该程序所依赖的sysfs文件系统，是装载于/sys下的伪文件系统，将设备和其他内核对象的相关信息导出至用户空间。

> [Kroah-Hartman，2003]一书简要介绍了 udev，并概述了该程序较之于devfs的优势，后者是 Linux2.4 内核对此类问题的解决方案。与 sysfs 文件系统有关的内容可见诸于Linux 2.6内核源码文件Documentation/filesystems/sysfs.txt和[Mochel，2005]一书。

