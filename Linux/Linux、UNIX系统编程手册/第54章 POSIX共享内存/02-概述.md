### 54.1　概述

POSIX共享内存能够让无关进程共享一个映射区域而无需创建一个相应的映射文件。Linux从内核2.4起开始支持POSIX共享内存。

SUSv3并没有对POSIX共享内存的实现细节进行规定，特别是没有要求使用一个（真实或虚拟）文件系统来标识共享内存对象，但很多UNIX实现都采用了文件系统来标识共享内存对象。一些UNIX实现将共享对象名创建为标准文件系统上一个特殊位置处的文件。Linux使用挂载于/dev/shm目录下的专用tmpfs文件系统（14.10节）。这个文件系统具有内核持久性——它所包含的共享内存对象会一直持久，即使当前不存在任何进程打开它，但这些对象会在系统关闭之后丢失。

> 系统上POSIX共享内存区域占据的内存总量受限于底层的tmpfs文件系统的大小。这个文件系统通常会在启动时使用默认大小（如256MB）进行挂载。如果有必要的话，超级用户能够通过使用命令mount –o remount,size=<num-bytes>重新挂载这个文件系统来修改它的大小。

要使用POSIX共享内存对象需要完成下列任务。

**1．** 使用shm_open()函数打开一个与指定的名字对应的对象。（在51.1节中介绍了控制POSIX共享内存对象的命名规则。）shm_open()函数与open()系统调用类似，它会创建一个新共享对象或打开一个既有对象。作为函数结果，shm_open()会返回一个引用该对象的文件描述符。

**2．** 将上一步中获得的文件描述符传入mmap()调用并在其flags参数中指定MAP_SHARED。这会将共享内存对象映射进进程的虚拟地址空间。与mmap()的其他用法一样，一旦映射了对象之后就能够关闭该文件描述符而不会影响到这个映射。然而，有可能需要将这个文件描述符保持在打开状态以便后续的fstat()和ftruncate()调用使用这个文件描述符（参见54.2节）。

> POSIX共享内存上shm_open()和mmap()的关系类似于System V共享内存上shmget()和shmat()的关系。使用POSIX共享内存对象需要两步式过程（shm_open()加上mmap()）而没有使用单个函数来执行两项任务是因为历史原因。在POSIX委员会增加这个特性时，mmap()调用已经存在了（[Stevens, 1999]）。实际上，这里所需要做的事情是使用shm_open()调用替换open()调用，其中的差别是使用shm_open()无需在一个基于磁盘的文件系统上创建一个文件。

由于共享内存对象的引用是通过文件描述符来完成的，因此可以直接使用UNIX系统中已经定义好的各种文件描述符系统调用（如ftruncate()）而无需增加新的用途特殊的系统调用（System V共享内存就需要这样做）。

