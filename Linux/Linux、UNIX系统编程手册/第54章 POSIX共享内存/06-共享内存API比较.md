### 54.5　共享内存API比较

到现在为止已经考虑了几种不同的在无关进程间共享内存区域的技术。

+ System V共享内存（第48章）。
+ 共享文件映射（49.4.2节）。
+ POSIX共享内存对象（本章的主题）。

> 本节中列出的很多要点也适用于共享匿名映射（49.7节），它用于通过fork()关联的进程间共享内存。

下列要点适用于所有这些技术。

+ 它们提供了快速IPC，应用程序通常必须要使用一个信号量（或其他同步原语）来同步对共享区域的访问。
+ 一旦共享内存对象区域被映射进进程的虚拟地址空间之后，它就与进程的内存空间中的其他部分无异了。
+ 系统会以类似的方式将共享内存区域放置进进程的虚拟地址空间中。在48.5节中介绍System V共享内存的时候对这种放置进行了概括。Linux特有的/proc/PID/maps文件会列出与所有种类的共享内存区域相关的信息。
+ 假设不会将一个共享内存区域映射到一个固定的地址处，那么就需要确保所有对区域中的位置的引用会使用偏移量来表示，而不是使用指针来表示，这是因为这个区域在不同进程中所处的虚拟地址可能是不同的（48.6节）。
+ 在第50章中介绍的操作虚拟内存区域的函数可被应用于使用这些技术中任意一项技术创建的共享内存区域。

在这些共享内存技术之间还存在一些显著的差异。

+ 一个共享文件映射的内容会与底层映射文件同步意味着存储在共享内存区域中的数据能够在系统重启之间得到持久保存。
+ System V和POSIX共享内存使用了不同的机制来标识和引用共享内存对象。System V使用了其自己的键和标识符模型，它们与标准的UNIX I/O模型是不匹配的并且需要单独的系统调用（如shmctl()）和命令（ipcs和ipcrm）。与之形成对比的是，POSIX共享内存使用了名字和文件描述符，其结果是使用各种既有的UNIX系统调用（如fstat()和fchmod()）就能够查看和操作共享内存对象了。
+ System V共享内存段的大小在创建时（shmget()）就确定了。与之形成对比的是，在基于文件的映射和POSIX共享内存对象上可以使用ftruncate()来调整底层对象的大小，然后使用munmap()和mmap()（或Linux特有的mremap()）重建映射。
+ 因为历史原因，System V共享内存受支持程度比mmap()和POSIX共享内存对象广得多，尽管现在大多数UNIX实现都已经提供所有这些技术。

除了最后有关可移植性的一点之外，上面列出的差异都是共享文件映射和POSIX共享内存对象的优势。因此在新应用程序中应该优先从这些接口中挑选一个使用，而不是System V共享内存。至于选择哪个接口则取决于是否需要一个持久性存储。共享文件映射提供了持久性存储，而POSIX共享内存对象则避免了在无需持久存储时使用磁盘文件所产生的开销。

