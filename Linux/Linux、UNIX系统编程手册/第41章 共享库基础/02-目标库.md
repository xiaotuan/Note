### 41.1　目标库

构建程序的一种方式是简单地将每一个源文件编译成目标文件，然后将这些目标文件链接在一起组成一个可执行程序，如下所示。



![1018.png](../images/1018.png)
> 链接实际上是由一个单独的链接器程序ld来完成的。当使用cc（或gcc）命令链接一个程序时，编译器会在幕后调用ld。在Linux上应该总是通过gcc间接地调用链接器，因为gcc能够确保使用正确的选项来调用ld并将程序与正确的库文件链接起来。

在很多情况下，源代码文件也可以被多个程序共享。因此要降低工作量的第一步就是将这些源代码文件只编译一次，然后在需要的时候将它们链接进不同的可执行文件中。虽然这项技术能够节省编译时间，但其缺点是在链接的时候仍然需要为所有目标文件命名。此外，大量的目标文件会散落在系统上的各个目录中，从而造成目录中内容的混乱。

为解决这个问题，可以将一组目标文件组织成一个被称为对象库的单元。对象库分为两种：静态的和共享的。共享库是一种更加现代化的对象库，它比静态库更具优势，41.3节将会对此予以介绍。

#### 题外话：在编译程序时包含调试器信息

在上面的cc命令中使用了-g选项以在编译过的程序中包含调试信息。一般来讲，创建允许调试的程序和库是一种比较好的做法。（在早期，有时候会忽略调试信息，这样产生的可执行文件会占用更少的磁盘和RAM，但现在磁盘和RAM已经非常便宜了。）

此外，在一些架构上，如x86-32，不应该指定–fomit–frame–pointer选项，因为这会使得无法调试。（在一些架构上，如x86-64，这个选项是默认启用的，因为它不会防止调试。）出于同样的原因，可执行文件和库不应该使用strip(1)删除调试信息。

