### 33.4　线程实现模型

本节将涉及一些理论知识，简要阐述实现线程API的3种不同模型，从而为33.5节中关于Linux线程实现的讨论提供必要的背景知识。这3种实现模型的差异主要集中在线程如何与内核调度实体（KSE，Kernel Scheduling Entity）相映射。KSE是内核分配CPU以及其他系统资源的（对象）单位。（在早于线程而出现的传统UNIX中，KSE等同于进程。）

#### 多对一（M:1）实现（用户级线程）

在M:1线程实现中，关乎线程创建、调度以及同步（互斥量的锁定，条件变量的等待等）的所有细节全部由进程内用户空间（user-space）的线程库来处理。对于进程中存在的多个线程，内核一无所知。

M:1实现的优势不多，其中最大的优点在于，许多线程操作（例如线程的创建和终止、线程上下文间的切换、互斥量以及条件变量操作）速度都很快，因为无需切换到内核模式。此外，由于线程库无需内核支持，所以M:1实现在系统间的移植相对要容易一些。

不过，M:1实现也存在一些严重缺陷。

+ 当一线程发起系统调用（如read()）时，控制由用户空间的线程库转交给内核。这就意味着，如果read()调用遭到阻塞，那么所有的线程都会被阻塞。
+ 内核无法调度进程中的这些线程。因为内核并不知晓进程中存在这些线程，也就无法在多处理器平台上将各线程调度给不同的处理器。另外，也不可能将一进程中某线程的优先级调整为高于其他进程中的线程，这是没有意义的，因为对线程的调度完全在进程中处理。

#### 一对一（1:1）实现（内核级线程）

在1:1线程实现中，每一线程映射一个单独的KSE。内核分别对每个线程做调度处理。线程同步操作通过内核系统调用实现。

1:1实现消除了M:1实现的种种弊端。遭阻塞的系统调用不会导致进程的所有线程被阻塞，在多处理器硬件平台上，内核还可以将进程中的多个线程调度到不同的CPU上。

不过，因为需要切换到内核模式，所以诸如线程创建、上下文切换以及同步操作就要慢一些。另外，为每个线程分别维护一个KSE也需要开销，如果应用程序包含大量线程，则可能对内核调度器造成严重的负担，降低系统的整体性能。

尽管有这些缺点，1:1实现通常更胜于M:1实现。LinuxThreads和NPTL都采用1:1模型。

> 在NPTL的开发期间，为了使得包含数以千计线程的进程得以高效运行，投入了巨大的努力，对内核调度器进行了重写并设计了新的线程实现。后续的测试也显示了预期目标的达成。

#### 多对多（M:N）实现（两级模型）

M:N实现旨在结合1:1和M:1模型的优点，避免二者的缺点。

在M:N模型中，每个进程都可拥有多个与之相关的KSE，并且也可以把多个线程映射到一个KSE。这种设计允许内核将同一应用的线程调度到不同的CPU上运行，同时也解决了随线程数量而放大的性能问题。

M:N模型的最大问题是过于复杂。线程调度任务由内核及用户空间的线程库共同承担，二者之间势必要进行分工协作和信息交换。在M:N模型下，按照SUSv3标准要求来管理信号也极为复杂。

> 最初曾考虑采用M:N模型来实现NPTL线程库，但若要保证Linux调度器即使在处理大量KSE的情况下也能应对自如，则需要对内核所作的改动范围过大，可能也没有必要，故而否决了这一方案。

