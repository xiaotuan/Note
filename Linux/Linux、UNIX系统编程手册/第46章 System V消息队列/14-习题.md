### 46.11　习题

**46-1.　** 试验程序清单46-1（svmsg_create.c）、程序清单46-2（svmsg_send.c）以及程序清单46-3（svmsg_receive.c）中的程序以验证对msgget()、msgsnd()以及msgrcv()系统调用的理解。

**46-2.** 　改造44.8节中的序号客户端-服务器应用程序使之使用System V消息队列。使用单个消息队列来传输客户端到服务器以及服务器到客户端之间的消息。使用46.8节中介绍的消息类型规范。

**46-3.** 　在46.8节中的客户端-服务器应用程序中，客户端为何在消息体（在clientId字段中）中传递其消息队列的标识符，而不是在消息类型（mtype）中传递？

**46-4.** 　对46.8节中的客户端-服务器应用程序做出下列变更。

（a）替换服务器中硬编码的消息队列键使之使用IPC_PRIVATE生成一个唯一的标识符，然后将这个标识符写入一个众所周知的文件中。客户端必须要从这个文件中读取标识符。服务器在终止时需要删除这个文件。

（b）在服务器程序的serveRequest()函数中并没有对系统调用错误进行诊断。添加使用syslog()（参见37.5节）记录错误的代码。

（c）在服务器中添加代码使之在启动时成为一个daemon（参见37.2节）。

（d）在服务器中为SIGTERM和SIGINT添加一个处理器来执行一个干净的退出。处理器需要删除消息队列以及（如果这个练习的前面一部分已经实现的话）用来存放服务器的消息队列标识符的文件。在处理器中加入分离处理器，然后再次触发同样一个调用该处理器的信号的代码（26.1.4节介绍了其中的原理以及完成这个任务的步骤）。

（e）服务器子进程并没有对客户端可能过早终止的情况进行处理，这样服务器子进程就会填充客户端的消息队列，然后无限阻塞下去。修改服务器使之处理这种情况，即像23.3节中描述的那样在调用msgsnd()时设置一个超时。如果服务器子进程确信客户端已经消失了，那么它就应该删除客户端的消息队列，然后退出（可能要在使用syslog()记录一条消息之后）。

**46-5.　** 程序清单46-9中给出的客户端（svmsg_file_client.c）没有对服务器发生故障的各种情况进行处理。特别是如果服务器消息队列被填满了（可能由于服务器终止而队列被其他客户端填满了），那么msgsnd()调用会无限阻塞下去。类似地，如果服务器没有成功地将响应发送给客户端，那么msgrcv()调用会无限阻塞下去。在客户端中添加代码使之在这些调用上设置超时（参见23.3节）。只要其中一个调用超时了，那么程序就需要将错误报告给用户并终止。

**46-6.　** 使用System V消息队列编写一个简单的聊天应用程序（与talk(1)类似，但没有curses界面）。为每个客户端使用一个消息队列。



