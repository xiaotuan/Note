### 35.5　总结

默认的内核调度算法采用的是循环时间分享策略。默认情况下，在这一策略下的所有进程都能平等地使用CPU，但可以将进程的nice值设置为一个范围从−20（高优先级）～+19（低优先级）的数字来影响调度器对进程的调度。但即使给一个进程设置了一个最低的优先级，它仍然有机会用到CPU。

Linux还实现了POSIX实时调度扩展。这些扩展允许应用程序精确地控制如何分配CPU给进程。运作在两个实时调度策略SCHED_RR（循环）和SCHED_FIFO（先入先出）下的进程的优先级总是高于运作在非实时策略下的进程。实时进程优先级的取值范围为1（低）～99（高）。只有进程处于可运行状态，那么优先级更高的进程就会完全将优先级低的进程排除在CPU之外。运作在SCHED_FIFO策略下的进程会互斥地访问CPU直到它执行终止或自动释放CPU或被进入可运行状态的优先级更高的进程抢占。类似的规则同样适用于SCHED_RR策略，但在该策略下，如果存在多个进程运行于同样的优先级下，那么CPU就会以循环的方式被这些进程共享。

进程的CPU亲和力掩码可以用来将进程限制在多处理器系统上可用CPU的子集中运行。这样就可以提高特定类型的应用程序的性能。

#### 更多信息

[Love，2010]提供了Linux上进程优先级和调度的背景资料。[Gallmeister, 1995]提供了POSIX实时调度 API的更多信息。虽然[Butenhof, 1996]中很多有关实时调度API的讨论都是针对POSIX线程的，但它也为本章中有关实时调度的讨论提供了有用的背景资料。

更多有关CPU亲和力以及控制多处理器系统上给线程分配CPU和内存节点的信息可以参见内核源文件Documentation/cpusets.txt、mbind(2)、set_mempolicy(2)以及cpuset(7)手册。

