### 35.6　习题

**35-1.** 　实现nice(1)命令。

**35-2.** 　编写一个与nice(1)命令类似的实时调度程序set-user-ID-root程序。这个程序的命令行界面如下所示：



![938.png](../images/938.png)
在上面的命令中，policy中r表示SCHED_RR，f表示SCHED_FIFO。基于在9.7.1节和38.3节中描述的原因，这个程序在执行命令前应该丢弃自己的特权ID。

**35-3.** 　编写一个运行于SCHED_FIFO调度策略下的程序，然后创建一个子进程。在两个进程中都执行一个能导致进程最多消耗3秒CPU时间的函数。（这可以通过使用一个循环并在循环中不断使用times()系统调用来确定累积消耗的CPU时间来完成。）每当消耗了1/4秒的CPU时间之后，函数应该打印出一条显示进程ID和迄今消耗的CPU时间的消息。每当消耗了1秒的CPU时间之后，函数应该调用sched_yield()来将 CPU 释放给其他进程。（另一种方法是进程使用sched_setparam()提升对方的调度策略。）从程序的输出中应该能够看出两个进程交替消耗了1秒的CPU时间。（注意在35.3.2节中给出的有关防止失控实时进程占住CPU的建议。）

**35-4.** 　如果两个进程在一个多处理器系统上使用管道来交换大量数据，那么两个进程运行在同一个CPU上的通信速度应该要快于两个进程运行在不同的CPU上，其原因是当两个进程运行在同一个 CPU 上时能够快速地访问管道数据，因为管道数据可以保留在 CPU 的高速缓冲器中。相反，当两个进程运行在不同的CPU 上时将无法享受 CPU 高速缓冲器带来的优势。读者如果拥有多处理器系统，可以编写一个使用sched_setaffinity()强制将两个进程运行在同一个CPU 上或运行在两个不同的 CPU 上的程序来演示这种效果。（第44章描述了管道的使用。）



