### 59.17　习题

**59-1.　** 当读取大量数据时，程序清单59-1给出的readLine()函数是低效的，因为每读取一个字符都需要使用一个系统调用。一个更加高效的接口是将一块字符读进缓冲器并每次从这个缓冲器中抽取出一行。这种接口可能由两个函数构成，其中第一个函数可能会被命名成readLineBufInit(fd, &rlbuf)，它初始化rlbuf指向的簿记数据结构。这个结构包括数据缓冲器所需的空间、这个缓冲器的大小以及指向缓冲器中下一个“未被读取的”字符的指针。它还包含了通过参数fd给出的文件描述符的一个副本。第二个函数readLineBuf(&rlbuf)返回与rlbuf相关联的缓冲器中的下一行。如果需要的话，这个函数可以从保存在rlbuf中的文件描述符中读取下一块数据。实现这两个函数。修改程序清单59-6中的程序（is_seqnum_sv.c）和程序清单59-7中的程序（is_seqnum_cl.c）使之使用这两个函数。

**59-2.** 　修改程序清单59-6中的程序（is_seqnum_sv.c）和程序清单59-7中的程序（is_seqnum_cl.c）使之使用程序清单59-9（inet_sockets.c）中给出的inetListen()和inetConnect()函数。

**59-3.** 　编写一个UNIX domain socket库使其API与59.12节中给出的Internet domain socket库的API类似。重写程序清单57-3中的程序（us_xfr_sv.c）和程序清单57-4中的程序（us_xfr_cl.c）使之使用这个库。

**59-4.** 　编写一个存储名字-值对的网络服务器。这个服务器应该允许客户端添加、删除、修改以及检索名字。编写一个或多个客户端程序来测试这个服务器。读者可根据自己的意愿实现某种安全机制，如只允许创建一个名字的客户端删除这个名字或修改与这个名字关联的值。

**59-5.** 　假设创建了两个被绑定到特定地址上的Internet domain数据报socket，并将第一个socket连接到第二个上。如果创建了第三个数据报socket并通过该socket尝试向第一个socket发送（sendto()）一个数据报会发生什么情况呢？编写一个程序确定这个问题的答案。



