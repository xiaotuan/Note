### 32.6　异步取消

如果设定线程为可异步取消时（取消性类型为PTHREAD_CANCEL_ASYNCHRONOUS），可以在任何时点将其取消（亦即，执行任何机器指令时），取消动作不会拖延到下一个取消点才执行。

异步取消的问题在于，尽管清理函数依然会得以执行，但处理函数却无从得知线程的具体状态。程序清单32-2采用了延时取消类型，只有在执行到pthread_cond_wait()这一唯一的取消点时，线程才会遭到取消。此时可知，已将buf初始化为指向新分配的内存块，并且锁定了互斥量mtx。不过，要是采用异步取消，就可以在任意点取消线程（例如，调用malloc()之前，调用malloc()与锁定互斥量之间，或者锁定互斥量之后）。清理函数无法知道将在哪里发生取消动作，或者准确地来说，清理函数不清楚需要执行哪些清理步骤。此外，线程也很可能在对malloc()的调用期间被取消，这极有可能造成后续的混乱（见7.1.3节）。

作为一般性原则，可异步取消的线程不应该分配任何资源，也不能获取互斥量或锁。这导致大量库函数无法使用，其中就包括Pthreads函数的大部分。（SUSv3中有3处例外pthread_cancel()、pthread_setcancelstate()以及pthread_setcanceltype()，规范明确要求将它们实现为“异步取消安全（async-cancel-safe）”，亦即，实现必须确保在可异步取消的线程中可以安全调用它们。）换言之，异步取消功能鲜有应用场景，其中之一就是：取消在执行计算密集型循环的线程。

