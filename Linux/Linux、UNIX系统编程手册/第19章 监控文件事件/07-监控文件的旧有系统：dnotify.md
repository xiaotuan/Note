### 19.6　监控文件的旧有系统：dnotify

Linux还为监控文件事件提供了另一种机制。该机制名为dnotify，问世于内核2.4版本，但inotify已令其“落伍”。相较于inotify，dnotify存在如下局限性。

+ dnotify机制通过向应用程序发送信号来通告事件。使用信号作为通告机制，会使应用程序的设计复杂化（请参见22.12节）。这也使得在函数库中使用dnotify变得困难，因为调用该函数的程序可能会改变对通告信号的处置（disposition）。而inotify机制则不使用信号。
+ dnotify的监控单元为目录。只要对该目录下的任一文件执行了任何操作，系统都会通知应用程序。相形之下，inotify的监控对象则既可以是单个文件，也能是目录。
+ 为监控目录，dnotify需要应用程序为该目录打开文件描述符。使用文件描述符会导致两个问题。其一，由于程序处于运行中，将无法卸载包含此目录的文件系统。其二，因为每个目录都需要一个文件描述符，所以应用程序最终可能会消耗大量文件描述符。而inotify不使用文件描述符，故而可以避免上述问题。
+ 与inotify相比，由dnotify提供的与文件事件相关的信息不够精确。当位于受监控目录下的文件发生改变时，dnotify只会通知有事件发生，但不会说明事件具体涉及了哪个文件。因此，应用程序必须通过缓存目录内容来进行判断。此外，针对已发生事件的类型，inotify所提供的信息也比dnotify更详细。
+ 在某些情况下，dnotify不支持可靠的文件事件通告机制。

在fcntl(2)手册页中对F_NOTIFY操作的描述部分，以及内核源码Documentation/dnotify.txt中，都可找到有关dnotify的更多信息。

