### 44.12　习题

**44-1.** 　编写一个程序使之使用两个管道来启用父进程和子进程之间的双向通信。父进程应该循环从标准输入中读取一个文本块并使用其中一个管道将文本发送给子进程，子进程将文本转换成大写并通过另一个管道将其传回给父进程。父进程读取从子进程过来的数据并在继续下一个循环之前将其反馈到标准输出上。

**44-2.** 　实现popen()和pclose()。尽管这些函数因无需完成在system()实现（参见27.7节）中的信号处理而得到了简化，但需要小心地将管道两端正确绑定到各个进程的文件流上并确保关闭所有引用管道两端的未使用的描述符。由于通过多个popen()调用创建的子进程可能会同时运行，因此需要需要维护一个将popen()分配的文件流与相应的子进程ID关联起来的数据结构。（如果使用数组，那么可以将fileno()函数的返回值作为数组的下标，这个函数能够取得与一个文件流对应的文件描述符。）从这个结构中取得正确的进程ID使得pclose()能够选择需等待的子进程。这个结构还满足了SUSv3的要求，即在新的子进程中必须要关闭所有通过之前的popen()调用仍然打开着的文件流。

**44-3.** 　程序清单44-7中的服务器（fifo_seqnum_server.c）每次在启动时都会从序号0开始赋序号值。修改程序使它使用一个在每次赋序号时都会更新的备份文件。（在4.3.1节中介绍的open() O_SYNC标记可能会有用。）在启动时，程序应该检查这个文件是否存在，如果存在的话就使用其中包含的值来初始化序号。如果在启动时没有找到备份文件，那么程序应该创建一个新文件并从0开始赋序号。（另一种方法是使用在49章中介绍的内存映射文件。）

**44-4.** 　在程序清单44-7中的服务器（fifo_seqnum_server.c）中添加代码使它在收到SIGINT或SIGTERM信号时删除服务器FIFO并终止。

**44-5.** 　程序清单44-7中的服务器（fifo_seqnum_server.c）在FIFO上执行第二次带O_WRONLY标记的打开操作使之在从FIFO的读取描述符（serverFd）中读取数据时永远不会看到文件结束。除了这种做法之外，还可以尝试另一种方法：当服务器在读取描述符中看到文件结束时关闭这个描述符，然后再次打开FIFO以便读取数据。（这个打开操作将会阻塞直到下一个客户端因写入而打开FIFO为止。）这种方法错在哪里了？

**44-6.** 　程序清单44-7中的服务器（fifo_seqnum_server.c）假设客户端进程的行为是正常的。如果一个行为异常的客户端创建了一个客户端FIFO和向服务器发送了一个请求，但并没有打开其FIFO，那么服务器在打开客户端的FIFO时将会被阻塞，从而造成其他客户端的请求被无限延迟。（如果是恶意的，那么就可以认定为DoS攻击。）设计一个模型来解决这个问题，对服务器（可能还要加上程序清单44-8中的客户端）进行相应的扩展。

**44-7.** 　编写程序验证FIFO上非阻塞打开和非阻塞I/O的操作（参见44.9节）。



