### 6.5　处理器亲和力（Affinity）

Linux在单个系统中支持多处理器，除了启动进程，支持多处理器的大多数工作都依赖于进程调度器。在多处理机上，进程调度器必须决定在每个CPU上运行哪个进程。

因此，必须解决两大难题：调度器必须尽量充分利用系统的处理器，因为当某个进程在等待运行时有个CPU空闲，性能就不会很高。但是，如果一个进程曾在某一CPU上运行，后面再运行时，进程调度器还应该尽量把它再放到同一个CPU上，因为处理器间的进程迁移会带来性能损失。

处理器间的进程迁移最大的性能损失来自于“缓存效应（cache effects）”。现代对称多处理（SMP）系统的设计中，每个处理器的缓存是各自独立的，而且相互不同。也就是说，处理器并不共享缓存中的数据。因此，当进程迁移到新处理器上后写入新数据到内存时，原有处理器的缓存就过期了，如果依赖原来这份缓存可能会带来损坏（corruption）。为了避免这种情况，缓存读入新的一块内存数据时会标记其他缓存无效。因此，在任意时刻，任意数据仅在一个处理器的缓存中有效（假设该数据被缓存）。因此，当进程在处理器间迁移时，就会带来两方面的代价：一是进程不再能访问缓存数据，二是原处理器的缓存中的数据必须标记为无效。考虑到这些代价，进程调度器会尽量让进程尽可能在固定的某个处理器上运行。

当然，进程调度器的两个目标有潜在的冲突。如果一个处理器比另一个处理器的负载大得多——或者更糟的是，如果一个处理器很忙而另一个空闲——这样，把某些进程重新调度到不忙碌的CPU上就很有意义。决定何时移动进程来避免不平衡，称为负载均衡，对SMP机器的性能至关重要。

处理器亲和力（processor affinity）表明一个进程会一直被调度到同一处理器上的可能性。术语“软亲和力（soft affinity）”表明调度器持续调度进程到同一处理器上的自然倾向，从上文的讨论可以看到，这是非常有价值的特性。Linux调度器尽可能地这样做，只有当负载极端不平衡的时候，才考虑迁移进程，从而，最小化迁移的缓存效应，还能保证系统中的处理器负载基本平衡。

但是，有些时候，用户或者应用需要保证进程和处理器间的绑定，这通常发生在进程非常依赖缓存（cache-sensitive），期望能够在同一个处理器下运行。把进程绑定到特定处理器并强制内核保证这种绑定关系，这称为“硬亲和力（hard affinity）”。

