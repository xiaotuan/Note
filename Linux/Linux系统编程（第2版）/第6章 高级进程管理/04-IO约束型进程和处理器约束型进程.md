### 6.1.2　I/O约束型进程和处理器约束型进程

一直消耗完所有可用时间片的进程称为“处理器约束型进程（process-bound process）”。这类进程需要获取大量CPU资源，会消耗掉调度器分配的全部CPU。最简单的例子就是如下所示的一个无限循环：



![259.png](../images/259.png)
其他的例子包括科学计算、数学演算和图像处理，它们没有上例那么极端。

相反，多数时间处于阻塞状态等待资源的进程称为“I/O约束型进程（I/O-bound process）”。I/O约束型进程经常发起和等待文件或网络I/O，阻塞在键盘输入，或等待用户移动鼠标。关于I/O约束型进程的应用的例子包括一些文件处理小工具，它们除了请求内核执行I/O操作外几乎什么都不做，比如 cp 或者 mv；还包括很多GUI应用，花费了大量时间在等待用户输入。

处理器约束型应用和I/O约束型应用之间的区别在于：其相应最佳调度器的行为不同。处理器约束的应用期望会获取尽可能长的时间片，从而最大化缓存命中率（通过时间局部性原理），尽快完成任务。相反地，I/O约束型应用不需要很长的时间片，因为它们一般在发出I/O请求前只会运行很短的一段时间，然后阻塞在某些内核资源。对于I/O约束型应用，如果调度器能够优先执行，则自然会受益。对于这类应用，在阻塞后越快被唤醒，就可以调度越多的I/O请求，应用就能更好地利用系统硬件资源。更进一步说，如果一个在等待用户输入的程序，被调度的速度越快，越能给用户无缝运行的感觉。

平衡处理器约束型应用和I/O约束型应用之间的不同需求难比登天。实际上，大多数应用是混合约束型：有些进程是I/O约束型，有些进程是处理器约束型。音频/视频的编码/解码就是一个很好的例子，无法把它简单地划分成任意一种。许多游戏也是混合约束型。因此，对于一个应用，并非总是能够判断出它属于哪一种约束型，而且一个进程在不同时间可能会有不同的行为。

