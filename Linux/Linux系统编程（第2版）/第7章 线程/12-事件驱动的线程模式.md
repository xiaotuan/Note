### 7.4.2　事件驱动的线程模式

事件驱动的线程模式和“每个连接对应一个线程”的模式是对立的。以Web服务器为例。对于计算能力，当前硬件可以同时处理多个请求。在“每个连接对应一个线程”模式中，就需要很多线程。线程自身的成本是固定的，主要需要内核和用户空间栈。这些固有成本带来了可扩展性上限，对一个进程中的线程数有上限，尤其是对于32位的系统（对于64位的系统而言，“每个连接对应一个线程”模式的局限性不是那么明显，但是事件驱动还是更优的选择）。系统可能有计算资源可以处理数千个正在执行的连接，但是运行这么多并发线程会带来可扩展性上限。

在寻求备选方案时，系统设计人员发现很多线程执行很多等待操作：读文件，等待数据库返回结果，发送远程过程调用。实际上，回顾第201页关于“多线程”的探讨：使用的线程数如果超出系统的处理器个数，并不会给并发带来任何好处。相反，这种线程使用方式反映了一种编程抽象，敏捷编程方式可以通过更正式的控制流模式来实现复制。

有了这些观察之后，就提出了“事件驱动的线程模式”。因为在“每个连接对应一个线程”模式中大部分工作负荷是在等待，我们把这些等待操作从线程中剥离出来。转而通过发送异步I/O请求和使用I/O多路复用（参见2.10节）来管理服务器中的控制流。在这种模式下，请求处理转换成一系列异步I/O请求及其关联的回调函数。这些回调函数可能会通过I/O多路复用方式来等待，完成该操作的进程称为“事件循环（event loop）”。当返回I/O请求时，事件循环会向等待的线程发送回调。

和“每个连接对应一个线程”模式一样，事件驱动模式本身也都不需要线程。实际上，如果一个单线程的进程执行回调时，事件循环可以完全没有。只有当真正可以提供并发时，才使用线程。在这个模式中，线程数没有理由要大于处理器数。

不同模式随着欢迎程度不断兴衰变更，事件驱动模式是当前设计多线程服务器的最佳选择。举个例子，在过去几年发展起来的除了Apache外的其他服务器，都是事件驱动模式。在设计多线程的系统软件时，建议首先考虑事件驱动模式：异步I/O、回调、事件循环，一个很小的线程池，每个处理器只有一个线程。

