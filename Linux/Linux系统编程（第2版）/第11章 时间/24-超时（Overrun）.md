### 11.7.5　超时（Overrun）

本节讨论的所有接口都保证进程至少睡眠指定的时间（或者返回错误来表示其他情况）。睡眠进程不达到指定的时间绝不返回成功。但是存在某种可能，会使睡眠时间超过指定时间。

这种现象可以归结于简单的调度行为——指定的时间可能已经过去了，内核可能会及时唤醒进程，但调度器可能选择了另外一个任务运行。

然而，这里还可能存在一个更加隐蔽的原因：定时器超时（timer overruns）。当定时器的粒度比要求的时间间隔大时，就会发生这种情况。举例来说，假设系统定时器每10毫秒产生一次报时信号，而进程要求1毫秒的睡眠。系统只能在10毫秒的精度下测量并响应时间相关的事件（例如把进程从睡眠中唤醒）。如果进程发起睡眠请求时，定时器距离下次报时信号还有1毫秒，一切都将正常——在1毫秒内，请求的时间（1毫秒）将会过去，而内核将唤醒进程。然而，如果定时器在进程请求睡眠时刚好产生报时信号，接下来的10毫秒将不会产生报时信号。那么，进程将会多睡眠9毫秒！也就是说，会有9个1毫秒的超时发生。平均来说，一个有X度量单位的定时器会有X/2的几率超时。

使用如POSIX时钟这样高精度的时间源，或者用较高的Hz值，可以减少定时器超时。

