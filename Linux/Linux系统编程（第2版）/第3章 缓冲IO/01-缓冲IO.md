### 第3章　缓冲I/O

在第1章中，我们已经提到块（block）是文件系统中最小存储单元的抽象。在内核中，所有的文件系统操作都是基于块来执行的。实际上，块是I/O中的基本概念。因此，所有I/O操作都是在块大小或者块大小的整数倍上执行，也就是说，也许你只想读取一个字节，实际上需要读取整个块。想写4.5个块的数据？你需要写5个块的数据，也就是说读取最后一块整块的数据，更新（删掉）后半部分内容，然后再把整个块写出去。

你很快会发现这个问题：对非整数倍块大小的操作效率很低。操作系统需要对I/O进行“修补”，确保所有操作都是在块大小整数倍上执行，并且和下一个最大块对齐。问题在于，用户空间的应用在实现时并不会考虑到块的概念。绝大多数应用都是在更高层抽象上执行的，比如成员变量和字符串，其大小变化和块大小无关。最糟糕的是，用户空间应用可能每次只读写一个字节！这会带来很多不必要的开销。实际上，对于每次写一个字节的应用，实际上往往也是要写整个块。

额外的系统调用所带来的开销会导致操作性能急剧下降。举个例子，假设要读取1 024个字节，如果每次读一个字节需要执行1 024次调用，而如果一个读取1 024字节的块则只需要调用一次。对于前一种，提升其性能的途径是“用户缓冲I/O”（user-buffered I/O），通过缓冲I/O，从用户角度，读写数据并没有任何变化，而实际上，只有当数据量大小达到文件系统块大小整数倍时，才会执行真正的I/O操作。

