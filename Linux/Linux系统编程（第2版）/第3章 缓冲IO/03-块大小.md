### 块大小

实际应用中，块大小一般是512字节、1 024字节、2 048字节或4 096字节。如表3-1所示，把每次操作的数据设置为块大小的整数倍或约数，可以实现大规模的效率提升。内核和硬件之间的交互单元是块，因此，使用块大小或者块大小的约数可以保证I/O请求是块对齐的，可以避免内核内其他冗余操作。

通过系统调用stat()（将在第7章讨论）或stat(1)，可以轻松为给定设备指定块大小。 不过，实际上，一般情况下我们不需要知道精确的块大小.

为I/O操作设置缓冲大小的主要目标是不要选择类似1 130这种古怪的值。对于UNIX系统，块长度从未出现过是1 130字节，选择这样的块大小会在第一次请求操作后导致I/O不对齐。设置成块大小的整数倍或约数都可以避免不对齐的情况。因此，只要设置的大小保证所有操作都是块对齐，I/O性能就会很高。设置较大的块大小整数倍时减少了系统调用次数。

因此，I/O操作最简单的方式是设置一个较大的缓冲区大小，是标准块大小的整数倍，比如设置成4 096或8 192，性能都不错。

那么，每次I/O请求都处理4KB或8KB的块大小，性能一定就会很高吗？不一定。问题在于程序很少是以块为单位处理的。程序处理的是变量、行和字符，而不是像块这样的抽象单元。因此，应用使用自己的抽象结构，通过用户缓冲I/O，实现块操作。其工作原理很简单，却很有效：当数据被写入时，它会被存储到程序地址空间的缓冲区中。当缓冲区数据大小达到给定值，即缓冲区大小（buffer size），整个缓冲区会通过一次写操作全部写出。同样，读操作也是一次读入缓冲区大小且块对齐的数据。应用的各种大小不同的读请求不是直接从文件系统读取，而是从缓冲区中一块块读取。应用读取的数据越来越多，缓冲区一块块给出数据。最后，当缓冲区为空时，会读取另一个大的块对齐的数据。通过这种方式，虽然应用设置的读写大小很不合理，数据会从缓冲区中获取，因此对文件系统还是发送大的块对齐的读写请求。其最终结果是对于大量数据，系统调用次数更少，且每次请求的数据大小都是块对齐的，通过这种方式，可以确保有很大的性能提升。

用户可以在自己的程序中实现缓冲，实际上很多关键应用就是自己实现了用户缓冲。不过，大部分程序可以通过标准I/O库（C标准库）或iostream库（C++标准库）来实现，它们实现了健壮有效的用户缓冲方案。

