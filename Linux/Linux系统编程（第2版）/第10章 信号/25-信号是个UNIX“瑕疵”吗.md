### 10.7　信号是个UNIX“瑕疵”吗

信号在很多UNIX编程人员中的名声很坏。它们是古老、过时的内核和用户之间的通信机制，最多也只是一种原始的进程间通信机制。在多线程程序和循环事件中，信号显得很不合时宜。对于已经“饱经风霜”的UNIX系统而言，它从一开始就提倡原生编程规范，从这个角度看，信号是个“失误”。我觉得信号被人们过分轻视了，而一个更易于说明、易于扩展、线程安全和基于文件描述符的解决方案无疑是个不错的开始。

然而，不管是好是坏，我们还是需要信号。信号是从内核接收许多通知（例如通知进程执行了非法的操作码）的唯一方式。此外，信号还是UNIX（Linux也一样）终止进程和管理父/子进程关系的方式。因此，编程人员必须理解信号，并使用它们。

信号备受诟病的主要原因之一在于，很难写出一个安全的、可重入的信号处理程序。如果你能简化你的信号处理程序，并且只使用表10-3列出的函数（如果用到的话），它们就应该是安全的。

信号另一个不足在于，许多编程人员仍然使用signal()和kill()，而不是sigaction()和sigqueue()来管理信号。正如最后两个小节所显示的，当使用SA_SIGINFO风格的处理程序时，信号的健壮性和表达力会显著增强。虽然我本人并不喜欢信号，但是绕过它们的缺陷并使用Linux的高级信号接口，确实可以避免很多麻烦或痛苦。

<a class="my_markdown" href="['#ac101']">[1]</a> 注：只有Alpha结构的机器定义了该信号。所有其他的机器结构中，该信号不存在。

<a class="my_markdown" href="['#ac102']">[2]</a> 因此，pause()是第二简单的系统调用。并列第一的是getpid()和gettid()，它们只有一行。



