### 9.7　选择合适的内存分配机制

本章讨论了很多内存分配方式，这可能会使得编程人员陷入迷茫，无法确定某个任务到底应该使用哪种方式。在大部分的情况下，使用malloc()是最好的选择。但是，在某些情况下，采用其他方法会更好一些。表8-2总结了选择内存分配机制的几条原则。

<center class="my_markdown"><b class="my_markdown">表9-2　在Linux中的内存分配方式</b></center>

| 分配方式 | 优　　点 | 缺　　点 |
| :-----  | :-----  | :-----  | :-----  | :-----  |
| malloc() | 简单，方便，最常用 | 返回的内存为用零初始化 |
| calloc() | 使数组分配变得容易，用0初始化了内存 | 在分配非数组空间时显得较复杂 |
| realloc() | 调整已分配的空间大小 | 只能用来调整已分配空间的大小 |
| brk()和sbrk() | 允许对堆进行深入控制 | 对大多数使用者来说过于底层 |
| 匿名内存映射 | 使用简单，可共享，允许开发者调整保护等级并提供建议，适合大空间的分配 | 不适合小分配。最优时malloc()会自动使用匿名内存映射 |
| posix_memalign() | 分配的内存按照任何合理的大小进行对齐 | 相对较新，因此可移植性是一个问题；对于对齐的要求不是很迫切的时候，则没有必要使用 |
| memalign()和valloc() | 相比posix_memalign()在其他的UNIX系统上更常见 | 不是POSIX标准，对对齐的控制能力不如posix_memalign() |
| alloca() | 最快的分配方式，不需要知道确切的大小，对于小的分配非常适合 | 不能返回错误信息，不适合大分配，在一些UNIX系统上表现不好 |
| 变长数组 | 与alloca()类似，但在退出此层循环时释放空间，而不是函数返回时 | 只能用来分配数组，在一些情况下alloca()的释放方式更加适用，在其他UNIX系统中没有alloca()常见 |

最后，不要忘记以上分配方式之外的其他两个选择：自动内存分配和静态内存分配。一般来说，在栈中分配自动变量或者在堆中分配全局变量往往更简单，而且不需要编程人员对指针进行操作，也不需要关心释放内存。

