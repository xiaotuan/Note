### 9.2.1　数组分配

当所需分配的内存大小本身是可变时，动态分配内存将变得更加复杂。一个很好的例子就是为数组分配动态内存，其中数组元素的大小是固定的，但是要分配的元素个数却是动态变化的。为了便于处理这种情况，C 提供calloc()函数：



![407.png](../images/407.png)
调用calloc()成功时会返回一个指针，指向一块可以存储下整个数组的内存（nr个元素，每个为size个字节）。所以，下面两种内存申请方式得到的内存大小是一样的（返回的内存可能比请求的多，但不会少）：



![408.png](../images/408.png)
但是，这两个函数的行为是有区别的。和malloc不同的是，calloc将分配的区域全部用0进行初始化。因此y中的50个元素都被赋值为0，但x数组里面的元素却是未定义的。如果程序不马上给所有的50个元素赋值，编程人员就应该使用calloc()来保证数组里面的元素不会被其他莫名其妙的值填充。另外要注意的是，二进制0值和浮点0值是不一样的。

> <img class="my_markdown" src="../images/1.png" style="width:62px;  height: 63px; "/> **关于calloc()的源起**
> 不存在关于calloc()的源起的文档说明。UNIX历史学家对calloc()的起源有争议：c是否表示count（计数）？因为该函数接收一个数组元素个数作为参数；还是表示clear（清除）？因为该函数会清空内存。你认为是哪个？这个争论一直没有结论。
> 为了追求真理，我咨询了Brian Kernighan，他是早期的Linux贡献者。Brian说他并不是该函数的原始作者，但他认为“c表示clear”。这是我所能得到的最权威的解答了。

用户经常希望用0来初始化动态分配得到的内存，即使这块内存不是用来保存数组。在这章的后面，我们将会探讨memset()函数，它提供了一个接口，可以用指定的值填充指定的内存块。但是使用calloc()会更快，因为内核可以为该调用提供本已清0的内存块。

当分配失败时，和malloc()一样，calloc()会返回NULL，并设置errno为ENOMEM。

我们不清楚为什么C标准不提供一个类似calloc()的函数用来分配以及初始化。但是开发者可以很容易地定义他们自己的接口：



![409.png](../images/409.png)
另外，可以非常方便地将malloc0()和我们之前的xmalloc()函数结合起来：



![410.png](../images/410.png)
