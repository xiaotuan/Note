### 9.8.3　字节移动

memmove()会把src的前n个字节复制到dst，并返回dst：



![458.png](../images/458.png)
同样，BSD也提供了一个接口来实现相同的功能，但该接口也已经废弃：



![459.png](../images/459.png)
需要注意的是，尽管memmove()和bcopy()这两个函数的参数相同，但它们的位置是不一样的。和memmove()相比，bcopy()中前两个参数的位置刚好与之相反。

bcopy()和 memmove()都可以安全处理内存区域重叠问题（也就是说，dst的一部分是在src 里面）。通过这种方式，可以允许内存块在一个给定区域内向上或下移动。虽然这种情况很少见，但是如果出现这种情况，编程人员应该了解。C标准定义了memmove()变体，它不支持内存区域覆盖。这个变体可能会更快一些：



![460.png](../images/460.png)
除了dst和src间不能重叠，这个函数基本和memmove()一样。如重叠了，函数的结果是未被定义的。另外一个安全的复制函数是memccpy()：



![461.png](../images/461.png)
memccpy()和memcpy()类似，区别在于对于memccpy()，当它在src指向的前n个字节中找到字节c时，就会停止拷贝。它返回指向dst中字节c的下一个字节的指针，没有找到c时，返回NULL。

最后，也可以使用mempcpy()来拷贝内存：



![462.png](../images/462.png)
函数mempcpy()的功能和memcpy()几乎一样，区别在于memccpy()返回的指针指向被复制的最后一个字节的下一个字节。当在内存中有连续的一系列数据需要拷贝时，该函数很有用，但是它并没有带来很大的性能提升，因为返回的指针只是dst+n。这个函数是GNU中特有的。

