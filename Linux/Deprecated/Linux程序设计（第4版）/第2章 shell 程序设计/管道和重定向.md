### 1.重定向输出

读者可能已经对某些类型的重定向比较熟悉了，例如：

```shell
$ ls -l > lsoutput.txt
```

现在你只需知道文件描述符 0 代表一个程序的标准输入，文件描述符 1 代表标准输出，而文件描述符 2 代表标准错误输出。

上面的例子通过 `>` 操作符把标准输出重定向到一个文件。在默认情况下，如果该文件已经存在，它的内容将被覆盖。如果你想改变默认行为，你可以使用命令 `set–onoclobber` (或 `set–C` )命令设置 `noclobber` 选项，从而阻止重定向操作对一个已有文件的覆盖。你可以使用 `set+onoclobber` 命令取消该选项。你将在本章后面的内容中看到更多的set命令选项。

你可以用 `>>` 操作符将输出内容附加到一个文件中。例如：

```shell
$ ps >>lsoutput.txt
```

这条命令会将 `ps`命令的输出附加到指定文件的尾部。

如果想对标准错误输出进行重定向，你需要把想要重定向的文件描述符编号加在 `>` 操作符的前面。因为标准错误输出的文件描述符编号是 2，所以使用 `2>` 操作符。当需要丢弃错误信息并阻止它显示在屏幕上时，这个方法很有用。

下面的命令将把标准输出和标准错误输出分别重定向到不同的文件中：

```shell
$ kill -HUP 1234 > killout.txt 2> killerr.txt
```

如果你想把两组输出都重定向到一个文件中，你可以用 `>&` 操作符来结合两个输出。如下所示：

```shell
$ kill -l 1234 > killouterr.txt 2>&1
```

请注意操作符出现的顺序。这条命令的含义是“将标准输出重定向到文件 killouterr.txt，然后将标准错误输出重定向到与标准输出相同的地方。”如果顺序有误，重定向将不会按照你预期的那样执行。

你可以用 Linux 的通用“回收站" `/dev/null` 来有效地丢弃所有的输出信息，如下所示：

```shell
$ kill -l 1234 > /dev/null 2>&1
```

### 2.重定向输入

你不仅可以重定向标准输出，还可以重定向标准输入。例如：

```shell
$ more < killout.txt
```

### 3.管道

你可以用管道操作符 `|` 来连接进程。

举一个简单的例子，你可以使用 `sort` 命令对 `ps` 命令的输出进行排序。如果不使用管道，你就必须分几个步骤来完成这个任务，如下所示：

```shell
$ ps > psout.txt
$ sort psout.txt > passort.out
```

一个更精巧的解决方案是用管道来连接进程，如下所示：

```shell
$ ps | sort > passort.out
```

如果想在屏幕上分页显示输出结果，你可以再连接第三个进程 `more`，将它们都放在同一个命令行上，如下所示：

```shell
$ ps | sort | more
```

允许连接的进程数目是没有限制的。假设你想看看系统中运行的所有进程的名字，但不包括 shell 本身，可以使用下面的命令：

```shell
$ ps -xo comm | sort | uniq | grep -v sh | more
```

这个命令首先按字母顺序排序 `ps` 命令的输出，再用 `uniq` 命令去除名字相同的进程，然后用 `grep –v sh` 命令删除名为 `sh` 的进程，最终将结果分页显示在屏幕上。

但这里有一点需要引起注意：如果你有一系列的命令需要执行，相应的输出文件是在这一组命令被创建的同时立刻被创建或写入的，所以决不要在命令流中重复使用相同的文件名。如果你尝试执行如下命令：

```shell
$ cat mydata.txt | sort | uniq > mydata.txt
```

你最终将得到一个空文件，因为你在读取文件 mydata.txt 之前就已经覆盖了这个文件的内容。

File: F:\upgrade\zg-full-SDYD_Hi-100.492.001-20210325115709-cmdc-hunan-sign.zip
Size: 342758596 bytes
Modified: 2021年3月25日, 14:59:14
MD5: 3896490D55300FE1FD277698A714123B
SHA1: 4A320894656FAAE2DF5C45D46A8BF43A363CECC4
CRC32: 93047128