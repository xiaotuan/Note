### 5.3.1　内置类型

内置类型是由语言提供的一组类型。我们已经见过这些类型，分别是数值类型、字符串类型和布尔类型。这些类型本质上是原始的类型。因此，当对这些值进行增加或者删除的时候，会创建一个新值。基于这个结论，当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。让我们看一下标准库里使用这些内置类型的值的函数，如代码清单5-23所示。

代码清单5-23　golang.org/src/strings/strings.go：第620行到第625行

```go
620 func Trim(s string, cutset string) string {
621　　 if s == "" || cutset == "" {
622　　　　 return s
623　　 }
624　　 return TrimFunc(s, makeCutsetFunc(cutset))
625 }
```

在代码清单5-23中，可以看到标准库里 `strings` 包的 `Trim` 函数。 `Trim` 函数传入一个 `string` 类型的值做操作，再传入一个 `string` 类型的值用于查找。之后函数会返回一个新的 `string` 值作为操作结果。这个函数对调用者原始的 `string` 值的一个副本做操作，并返回一个新的string值的副本。字符串（ `string` ）就像整数、浮点数和布尔值一样，本质上是一种很原始的数据值，所以在函数或方法内外传递时，要传递字符串的一份副本。

让我们看一下体现内置类型具有的原始本质的第二个例子，如代码清单5-24所示。

代码清单5-24　golang.org/src/os/env.go：第38行到第44行

```go
38 func isShellSpecialVar(c uint8) bool {
39　　 switch c {
40　　 case '*', '#', '$', '@', '!', '?', '0', '1', '2', '3', '4', '5',
　　　　　　　　　　　　　　　　　　　 　　　　　　　　　 '6', '7', '8', '9':
41　　　　 return true
42　　 }
43　　 return false
44 }
```

代码清单5-24展示了 `env` 包里的 `isShellSpecialVar` 函数。这个函数传入了一个 `int8` 类型的值，并返回一个 `bool` 类型的值。注意，这里的参数没有使用指针来共享参数的值或者返回值。调用者传入了一个 `uint8` 值的副本，并接受一个返回值 `true` 或者 `false` 。

