### 4.1.5　在函数间传递数组

根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。

为了考察这个操作，我们来创建一个包含100万个 `int` 类型元素的数组。在64位架构上，这将需要800万字节，即8 MB的内存。如果声明了这种大小的数组，并将其传递给函数，会发生什么呢？如代码清单4-14所示。

代码清单4-14　使用值传递，在函数间传递大数组

```go
// 声明一个需要8 MB的数组
var array [1e6]int
// 将数组传递给函数foo
foo(array)
// 函数foo接受一个100万个整型值的数组
func foo(array [1e6]int) {
　　...
}
```

每次函数 `foo` 被调用时，必须在栈上分配8 MB的内存。之后，整个数组的值（8 MB的内存）被复制到刚分配的内存里。虽然Go语言自己会处理这个复制操作，不过还有一种更好且更有效的方法来处理这个操作。可以只传入指向数组的指针，这样只需要复制8字节的数据而不是8 MB的内存数据到栈上，如代码清单4-15所示。

代码清单4-15　使用指针在函数间传递大数组

```go
// 分配一个需要8 MB的数组
var array [1e6]int
// 将数组的地址传递给函数foo
foo(&array)
// 函数foo接受一个指向100万个整型值的数组的指针
func foo(array *[1e6]int) {
　　...
}
```

这次函数 `foo` 接受一个指向100万个整型值的数组的指针。现在将数组的地址传入函数，只需要在栈上分配8字节的内存给指针就可以。

这个操作会更有效地利用内存，性能也更好。不过要意识到，因为现在传递的是指针，所以如果改变指针指向的值，会改变共享的内存。如你所见，使用切片能更好地处理这类共享问题。

