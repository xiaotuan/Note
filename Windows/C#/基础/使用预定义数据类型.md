[toc]

数据类型的 `C#` 关键字（如 `int`、`short` 和 `string`）从编译器映射到 `.NET` 数据类型。例如，在 `C#` 中声明一个 `int` 类型的数据时，声明的实际上是 `.NET struct (System.Int32)` 的一个实例。所有基本数据类型都提供了可供调用的方法。例如，要把 `int i` 转换为 `string` 类型，可以编写下面的代码：

```c#
string s = i.ToString();
```

### 1. 整型

`C#` 支持使用不同位数的整型，并且区分了只支持正数的类型和支持一定范围内的正数和负数的类型。`byte` 和 `sbyte` 类型使用 8 位。`byte` 类型允许 0 ~ 255 之间的值（只有正值），而 `sbyte` 中的 `s` 意味着使用符号（`sign`），所以该类型支持 -128 ~ 127 之间的值。

`short` 和 `ushort` 类型使用 16 位。`short` 类型的取值范围为 -32768 ~ 32767。`ushort` 类型中的 `u` 代表无符号（`unsigned`），它的取值范围为 0 ~ 65535。类似，`int` 类型是带符号 32 位整数，`uint` 类型为无符号整数。`long` 和 `ulong` 使用 64 位。在后台，`C#` 关键字 `sbyte`、`short`、`int` 和 `long` 映射到 `System.SByte`、`System.Int16`、`System.Int32` 和 `System.Int64`。无符号版本映射到 `System.Byte` 、`System.UInt16`、`System.UInt32` 和 `System.UInt64`。

要检查类型的最大值和最小值，可以使用 `MaxValue` 和 `MinValue` 属性。

### 2. BigInteger

如果需要的数字比 64 位的 `long` 类型能够表示的值更大，则可以使用 `BigInteger` 类型。该结构对于位数没有限制，可以一直增长下去，直到没有可用的内存。这个类型没有对应的 `C#` 关键字，所以需要使用 `BigInteger` 。因为它能够无限增长，所以无法提供 `MinValue` 和 `MaxValue` 属性。该类型提供了内置的计算方法，如 `Add()`、`Subtract()`、`Divide()`、`Multiply()`、`Log()`、`Log10()`、`Pow()` 等。

### 3. 本机整数类型

如果应用程序是 32 位或 64 位应用程序，则 `int`、`short` 和 `long` 类型的位数和可用大小是独立的。`C# 9` 为平台特定的值提供了新的关键字：`nint` 和 `nuint`（分别代表本机整数和本机无符号整数）。在 64 位应用程序中，这些整数类型使用 64 位，而在 32 位应用程序中，只使用 32 位。

### 4. 数字分隔符

为了提高数字的可读性，可以使用数字分隔符。可以像数字添加下划线：

```c#
long value = 0x_123_4567_89ab_cedf;
```

因为编译器只会忽略下划线，所以你要自己负责确保可读性。可以在任何位置放置下划线，所以不恰当地放置下划线可能对于提高可读性并没有帮助：

```c#
long value = 0x_12345_6789_abc_ed_f;
```

### 5. 二进制

除了提供数字分隔符，`C#` 还便于把二进制值赋值给整数类型。如果在变量值前面加上 `0b` 字面值作为前缀，只允许使用 0 和 1：

```c#
uint binary = 0b_1111_1110_1101_1100_1011_1010_1001_1000;
```

也可以使用十六进制记数法：

```c#
uint hex = 0xfedcba98;
```

### 6. 浮点类型

`C#` 还基于 `IEEE 754` 标准，指定了使用不同位数的浮点类型。`Half` 类型（`.NET 5` 新增）使用 16 位，`float` （映射到 `.NET` 中的 `Single` 类型）使用 32 位，`double`（映射到 `.NET` 中的 `Double` 类型）使用 64 位。这些数据类型中有 1 位用作符号。取决于具体类型，可能有 10 ~ 52 位用作有效位，有 5 ~ 11 位用作指数。

| C# 关键字 | .NET 类型       | 说明              | 有效位数 | 指数位数 |
| --------- | --------------- | ----------------- | -------- | -------- |
|           | `System.Half`   | 16 位单精度浮点数 | 10       | 5        |
| `float`   | `System.Single` | 32 位单精度浮点数 | 23       | 8        |
| `double`  | `System.Double` | 64 位双精度浮点数 | 52       | 11       |

赋值的时候，如果硬编码了一个非整数值（如 12.3），则编译器一般假定该变量是 `double`。如果像指定该值为 `float`，可以在其后加上字符`F`（或 `f`）：

```c#
float f = 12.3F;
```

使用 `decimal` 类型（`.NET` 结构 `Decimal` ）时，`.NET` 有一个高精度的浮点类型，它使用 128 位，可用于财务计算。在这 128 位中，有 1 位用作符号，96 位用作整数。剩下的位指定了比例因子。要把数字指定为 `decimal` 类型而不是 `double` 、`float` 或整数类型，可以在数字的后面加上字符 `M`（或 `m`），如下所示：

```c#
decimal d = 12.30M;
```

### 7. bool 类型

`C#` 的 `bool` 类型用于包含布尔值 `true` 或 `false`。

`bool` 值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为 `bool` 类型，就只能使用值 `true` 和 `false`。如果试图使用 0 表示 `false`，非 0 表示 `true`，就会出错。

### 8. 字符类型

`.NET` 字符串由两个字节的字符组成。`C#` 关键字 `char` 映射到 `.NET`类型 `Char`。使用单引号（如 `'A'`）创建一个 `char` 类型的值；使用双引号则会创建一个字符串。

除了把 `char` 表示字符串字面量之外，还可以用 4 位十六进制的 `Unicode` 值（如 `\u0041`）、带有强制类型转换的整数值（如 `(char)65`）或十六禁止数（如 `\x0041`）表示它们。它们还可以用转义序列表示：

| 转义序列 | 字符       |
| -------- | ---------- |
| `\'`     | 单引号     |
| `\"`     | 双引号     |
| `\\`     | 反斜杠     |
| `\0`     | 空         |
| `\a`     | 警告       |
| `\b`     | 退格       |
| `\f`     | 换页       |
| `\n`     | 换行       |
| `\r`     | 回车       |
| `\t`     | 水平制表符 |
| `\v`     | 垂直制表符 |

### 9. 数字的字面值

| 字面值  | 位置 | 说明                          |
| ------- | ---- | ----------------------------- |
| `U`     | 后缀 | `unsigned int`                |
| `L`     | 后缀 | `long`                        |
| `UL`    | 后缀 | `unsigned long`               |
| `F`     | 后缀 | `float`                       |
| `M`     | 后缀 | `decimal`（货币）             |
| `0x`    | 前缀 | 十六进制数字，允许使用 0 ~ F  |
| `0b`    | 前缀 | 二进制数字，只允许使用 0 和 1 |
| `true`  | `NA` | 布尔值                        |
| `false` | `NA` | 布尔值                        |

### 10. object 类型

除了值类型，使用 `C#` 关键字还可以定义两种引用类型：`object` 关键字映射到 `Object` 类，`string` 关键字映射到 `String` 类。`Object` 类是所有引用类型最终的基类，它可以用于两个目的：

+ 可以使用 `object` 引用来绑定任何特定子类型的对象。`object` 引用也可以用于反射，此时必须有代码来处理类型未知的对象。
+ `object` 类型实现了许多一般用途的基本方法，包括 `Equals()`、`GetHashCode()`、`GetType()` 和 `ToString()`。用户定义的类可能需要使用一种面向对象技术——重写，来提供其中一些方法的替代实现代码。如果类中没有提供这些方法的实现代码，编译器就会使用 `object` 类型中的实现代码，返回类的名称。
